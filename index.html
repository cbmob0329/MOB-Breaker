<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>MOB SideAction – Prototype v2 (fix size/ground/UI overlap)</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{
    --ui-h: 210px;            /* 下パッドの高さ（安全領域は別で足す） */
    --hud:#0f1118cc;
    --fg:#e7eefb;
    --btn:#151a24;
    --btn2:#0d111a;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#05070c;color:#fff;overscroll-behavior:none;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none}
  body{font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic UI", sans-serif;}

  /* レイアウト：上=ゲーム、下=操作 */
  #root{position:fixed;inset:0;display:grid;grid-template-rows:1fr auto;background:#000}
  #gameWrap{position:relative;overflow:hidden;background:#0b0f17}
  canvas#game{display:block;width:100%;height:100%}

  /* HUD */
  .hud{
    position:absolute;left:0;right:0;top:0;display:flex;gap:8px;align-items:center;
    padding:8px max(env(safe-area-inset-right),12px) 6px max(env(safe-area-inset-left),12px);
    background:linear-gradient( to bottom, rgba(0,0,0,.55), rgba(0,0,0,0));
    font-size:12px;z-index:5;pointer-events:none;
  }
  .chip{background:var(--hud);color:var(--fg);backdrop-filter:blur(6px);padding:6px 10px;border-radius:10px;border:1px solid #1b2231}
  .hpbar{min-width:120px;height:10px;background:#2a2f3b;border-radius:999px;overflow:hidden;border:1px solid #1e2330}
  .hpfill{height:100%;background:linear-gradient(90deg,#37ff9d,#1effe6)}

  /* 下部：操作UI（ゲームと明確に分離） */
  #pad{
    height:calc(var(--ui-h) + env(safe-area-inset-bottom));
    padding:12px max(env(safe-area-inset-right),12px) calc(12px + env(safe-area-inset-bottom)) max(env(safe-area-inset-left),12px);
    background:linear-gradient( to top, #06080d 0%, #070b12 45%, #0a0f18 100%);
    border-top:1px solid #0f1522; display:grid; gap:12px;
    grid-template-columns:1fr 1fr; position:relative;
  }
  /* 上下の区切り線（見た目のグリッド境界） */
  #pad::before{
    content:""; position:absolute; left:0; right:0; top:-1px; height:1px; background:#1a2333; opacity:.9;
  }
  .panel{background:linear-gradient(180deg,#0b1019,#070b12); border:1px solid #121b2a; border-radius:14px; position:relative; overflow:hidden; box-shadow:0 6px 20px rgba(0,0,0,.25) inset;}
  .panel .grid{
    position:absolute; inset:0; background:
      linear-gradient(#10182766,#10182766) top/100% 1px,
      linear-gradient(90deg,#10182766,#10182766) left/1px 100%;
    background-repeat:no-repeat;
    pointer-events:none;
  }

  /* 左：バーチャルスティック */
  #stickZone{touch-action:none}
  .stickBase,.stickKnob{
    position:absolute; border-radius:999px; border:1px solid #1a2233; background:rgba(17,26,39,.55); backdrop-filter:blur(6px);
  }
  .stickBase{width:150px;height:150px;left:18px;bottom:18px}
  .stickKnob{width:88px;height:88px;left:0;top:0;transform:translate(18px,80px)}

  /* 右：ボタン */
  #btns{display:grid;grid-template-areas:
      ".  k2"
      "k1 sk"
      "jp sk";
    gap:14px; place-items:center; height:100%; touch-action:none; padding:16px;
  }
  .btn{
    width:84px;height:84px;border-radius:16px;background:linear-gradient(180deg,var(--btn),var(--btn2));
    border:1px solid #1c2434; box-shadow:0 4px 16px rgba(0,0,0,.4), inset 0 1px 0 rgba(255,255,255,.06);
    display:grid;place-items:center;font-weight:700;font-size:26px;letter-spacing:.02em;
    color:#d7e6ff;text-shadow:0 1px 0 #0008;
    -webkit-tap-highlight-color:transparent; user-select:none;
  }
  .btn:active{transform:translateY(2px);box-shadow:0 2px 10px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04)}
  #btnK1{grid-area:k1}  /* ■ */
  #btnK2{grid-area:k2}  /* ▲ */
  #btnSK{grid-area:sk; height:182px}  /* ● */
  #btnJP{grid-area:jp}  /* × */

  .lab{position:absolute;bottom:8px;left:8px;color:#8fa6c9;font-size:11px;opacity:.8;pointer-events:none}

  @media(min-width:820px){
    #root{max-width:540px;margin:0 auto;left:0;right:0}
  }
</style>
</head>
<body>
<div id="root">
  <div id="gameWrap">
    <canvas id="game" width="540" height="900" aria-label="Game Canvas"></canvas>
    <div class="hud">
      <div class="chip">⏱ <span id="tm">0:00</span></div>
      <div class="chip">残機 <span id="life">3</span></div>
      <div class="chip" style="display:flex;align-items:center;gap:8px;">
        HP
        <div class="hpbar" style="width:140px;"><div id="php" class="hpfill" style="width:100%"></div></div>
      </div>
      <div class="chip" style="display:flex;align-items:center;gap:8px;">
        ENEMY
        <div class="hpbar" style="width:120px;"><div id="ehp" class="hpfill" style="width:100%;background:linear-gradient(90deg,#ff7a7a,#ffb36e)"></div></div>
      </div>
      <div class="chip">FPS <span id="fps">60</span></div>
    </div>
  </div>

  <div id="pad" role="group" aria-label="Virtual Controls">
    <div id="stickZone" class="panel">
      <div class="grid"></div>
      <div class="lab">スティック（左/右/上=ジャンプ）</div>
      <div class="stickBase" id="stickBase"></div>
      <div class="stickKnob" id="stickKnob"></div>
    </div>
    <div id="btns" class="panel">
      <div class="grid"></div>
      <button id="btnK1" class="btn" aria-label="攻撃1">■</button>
      <button id="btnK2" class="btn" aria-label="攻撃2">▲</button>
      <button id="btnSK" class="btn" aria-label="スキル">●</button>
      <button id="btnJP" class="btn" aria-label="ジャンプ">×</button>
      <div class="lab" style="right:8px;left:auto">■攻撃1 / ▲攻撃2 / ●スキル / ×ジャンプ</div>
    </div>
  </div>
</div>

<script>
/* ============================================================
   Prototype v2 修正点
   - 地面Yの計算を「キャンバス高のみ基準」に変更（UI高さの二重控除を削除）
   - 初期Yと床影を見やすく調整 → キャラが沈まない
   - 右下UIとゲーム領域は完全分離（キャンバスが上段、UIは別段）
   - 画像スケール統一：立ち絵高さ=基準（全モーション同率・縦横比維持）
   ============================================================ */

(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = () => canvas.width;
  const H = () => canvas.height;

  // HUD refs
  const tmEl = document.getElementById('tm');
  const lifeEl = document.getElementById('life');
  const phpEl = document.getElementById('php');
  const ehpEl = document.getElementById('ehp');
  const fpsEl = document.getElementById('fps');

  // Assets
  const ASSETS = {
    player:{
      stand: 'M1-1.png',
      walk: ['M1-2.png','M1-3.png','M1-4.png'],
      atk:{ pose:'K1-3.png', up:'K1-1.png', dash:'K1-2.png', fin:'K1-4.png', upper:'K1-5.png' },
      spin:['h1.png','h2.png','h3.png','h4.png']
    },
    enemy:{
      stand:'EN1-1.png',
      walk:['EN1-2.png','EN1-3.png'],
      atk:{ small:['EN1-4.png','EN1-5.png'], mid:['EN1-4.png','EN1-6.png'] }
    },
    tile:'S1.png'
  };

  // ---- 重要：サイズ最適化と地面位置 ----
  const TARGET = {
    playerH: 112,  // 画面比に合わせ微調整（歩き/攻撃も同率）
    enemyH: 112
  };
  const FLOOR_MARGIN = 96; // キャンバス下端からの床位置。UIとは無関係（=重ならない）

  // Loader
  const cache = {};
  function loadImage(src){ return new Promise((res,rej)=>{ if(cache[src]) return res(cache[src]); const i=new Image(); i.onload=()=>{cache[src]=i;res(i)}; i.onerror=rej; i.src=src; }); }

  // Offscreen for red-flash mask
  const off = document.createElement('canvas'); off.width=512; off.height=512;
  const offCtx = off.getContext('2d');

  class Sprite {
    set(img, desiredH){ this.img=img; const r=img.width/img.height; this.h=desiredH; this.w=desiredH*r; }
    draw(x,y,flip=false,rot=0,alpha=1,flash=false){
      if(!this.img) return;
      ctx.save();
      ctx.translate(x,y); if(rot) ctx.rotate(rot);
      const w=this.w,h=this.h; const originX=flip?w/2:-w/2; const sx=flip?-1:1; ctx.scale(sx,1);
      if(!flash){
        ctx.globalAlpha=alpha; ctx.drawImage(this.img, originX,-h/2,w,h);
      }else{
        offCtx.clearRect(0,0,off.width,off.height);
        offCtx.save(); offCtx.translate(off.width/2,off.height/2); offCtx.scale(sx,1);
        offCtx.drawImage(this.img, originX,-h/2,w,h);
        offCtx.globalCompositeOperation='source-atop'; offCtx.fillStyle='rgba(255,60,60,0.85)';
        offCtx.fillRect(-off.width/2,-off.height/2,off.width,off.height);
        offCtx.restore();
        ctx.globalAlpha=alpha;
        ctx.drawImage(off, -w/2,-h/2,w,h);
      }
      ctx.restore();
    }
  }

  class Actor{
    constructor(){ this.x=0; this.y=0; this.vx=0; this.vy=0; this.onGround=false; this.dir=1; this.hp=100; this.maxhp=100; this.dead=false; this.alpha=1; this.rot=0; this.flashT=0; this.width=60; this.height=100; this.spr=null; }
    rect(){ return {x:this.x-this.width/2, y:this.y-this.height, w:this.width, h:this.height}; }
    hurt(dmg,kd=0){ if(this.dead) return; this.hp=Math.max(0,this.hp-dmg); this.flashT=180; this.vx=(kd||-this.dir)*-3.2; this.vy=-6; if(this.hp<=0) this.kill(kd); }
    kill(kd=0){ this.dead=true; this.vx=(kd||-this.dir)*-4; this.vy=-8; this.deadT=0; }
    updateDeath(dt){ if(!this.dead) return false; this.deadT+=dt; this.rot+=0.5; this.alpha-=0.01; return this.alpha<=0; }
  }

  class Player extends Actor{
    constructor(imgs){ super();
      this.maxhp=1000; this.hp=1000; this.img=imgs; this.state='idle'; this.stateT=0; this.dir=1; this.canCtrl=true;
      this.combo=[]; this.chargeT=0; this.spinLoops=0; this.spinIndex=0; this.gauge=0; this.gaugeVis=0;
      this.baseH=TARGET.playerH;
      this.sStand=new Sprite(); this.sStand.set(this.img.stand,this.baseH);
      this.sWalk=this.img.walk.map(i=>{const s=new Sprite(); s.set(i,this.baseH); return s;});
      this.sAtkPose=new Sprite(); this.sAtkPose.set(this.img.atk.pose,this.baseH);
      this.sAtkUp=new Sprite(); this.sAtkUp.set(this.img.atk.up,this.baseH);
      this.sAtkDash=new Sprite(); this.sAtkDash.set(this.img.atk.dash,this.baseH);
      this.sAtkFin=new Sprite(); this.sAtkFin.set(this.img.atk.fin,this.baseH);
      this.sUpper=new Sprite(); this.sUpper.set(this.img.atk.upper,this.baseH);
      this.sSpin=this.img.spin.map(i=>{const s=new Sprite(); s.set(i,this.baseH); return s;});
      // 当たり判定はスプライトに追従（歩き/攻撃も同率なのでサイズブレなし）
      this.width=this.sStand.w*0.55; this.height=this.sStand.h*0.90;
    }
    think(input,dt,world){
      if(this.canCtrl && !['atk1','atk2','skill'].includes(this.state)){
        const sp=3.0; this.vx=sp*input.ax; if(Math.abs(input.ax)>0.1){ this.dir=input.ax>0?1:-1; if(this.onGround) this.state='walk'; } else { if(this.onGround) this.state='idle'; this.vx*=0.85; }
      }else{ this.vx*=0.95; }
      if(input.jumpPressed && this.onGround){ this.vy=-10.5; this.onGround=false; this.state='jump'; }
      if(input.k1Pressed) this.combo.push('K1');
      if(input.k2Down) this.chargeT+=dt;
      if(input.k2Released){ this.combo.push({type:'K2',charged:(this.chargeT>=500)}); this.chargeT=0; }
      if(input.skDown){ this.gauge=Math.min(1000,this.gauge+dt); this.gaugeVis=this.gauge; }
      if(input.skReleased){ const charged=this.gauge>=1000; this.startSkill(charged?4:2); this.gauge=0; }

      if((this.state==='idle'||this.state==='walk'||(this.onGround&&this.state==='jump')) && this.combo.length>0){
        const c=this.combo.shift();
        if(c==='K1') this.startAtk1_1();
        else if(c.type==='K2') this.startAtk2(c.charged);
      }
    }
    startAtk1_1(){ this.state='atk1'; this.stateT=0; this.phase=1; this.canCtrl=false; }
    startAtk1_2(){ this.state='atk1'; this.stateT=0; this.phase=2; this.canCtrl=false; }
    startAtk1_3(){ this.state='atk1'; this.stateT=0; this.phase=3; this.canCtrl=false; }
    startAtk2(ch){ this.state='atk2'; this.stateT=0; this.k2Charged=ch; this.canCtrl=false; }
    startSkill(n){ this.state='skill'; this.stateT=0; this.spinLoops=n; this.spinIndex=0; this.canCtrl=false; }

    attackHB(){
      const L=[];
      if(this.state==='atk1'){
        if(this.phase===1 && this.stateT>200 && this.stateT<520){ const r=this.rect(); const ox=this.dir*(r.w*0.6); L.push({x:r.x+r.w/2+ox,y:r.y+r.h*0.45,w:50,h:60,dmg:5,kb:this.dir}); if(this.onGround) this.vx=this.dir*1.2; }
        if(this.phase===2 && this.stateT>200 && this.stateT<420){ const r=this.rect(); const ox=this.dir*(r.w*0.8); L.push({x:r.x+r.w/2+ox,y:r.y+r.h*0.5,w:56,h:56,dmg:8,kb:this.dir}); if(this.onGround) this.vx=this.dir*2.2; }
        if(this.phase===3 && this.stateT>200 && this.stateT<420){ const r=this.rect(); const ox=this.dir*(r.w*0.9); L.push({x:r.x+r.w/2+ox,y:r.y+r.h*0.48,w:60,h:60,dmg:10,kb:this.dir}); if(this.onGround) this.vx=this.dir*2.4; }
      }else if(this.state==='atk2'){
        if(this.stateT>500 && this.stateT<840){ const r=this.rect(); const ox=this.dir*(r.w*0.42); L.push({x:r.x+r.w/2+ox,y:r.y+r.h*0.2,w:54,h:90,dmg:this.k2Charged?24:15,kb:this.dir}); if(this.onGround) this.vx=this.dir*1.0; }
      }else if(this.state==='skill'){
        const r=this.rect(); L.push({x:r.x+r.w/2+this.dir*(r.w*0.3),y:r.y+r.h*0.4,w:70,h:70,dmg:(this.spinLoops>=4?40:25),kb:this.dir});
      }
      return L;
    }
    update(dt,input,world){
      this.stateT+=dt;
      this.think(input,dt,world);
      this.vy+=world.g; this.x+=this.vx; this.y+=this.vy;

      const gy=world.groundY; // ← v2: キャンバス基準の床
      if(this.y>=gy){ this.y=gy; this.vy=0; if(!this.onGround){ this.onGround=true; if(this.state==='jump') this.state='idle'; } } else this.onGround=false;

      if(this.y > H()+400) world.onPlayerDeath();

      if(this.flashT>0) this.flashT-=dt;

      if(this.state==='atk1'){
        if(this.phase===1 && this.stateT>=520){ if(this.combo[0]==='K1'){ this.combo.shift(); this.startAtk1_2(); } else this.finishAtk(); }
        if(this.phase===2 && this.stateT>=420){ if(this.combo[0]==='K1'){ this.combo.shift(); this.startAtk1_3(); } else this.finishAtk(); }
        if(this.phase===3 && this.stateT>=420){ this.finishAtk(); }
      }else if(this.state==='atk2'){
        if(this.stateT>=800) this.finishAtk();
      }else if(this.state==='skill'){
        if(this.stateT>=80){ this.stateT=0; this.spinIndex++; if(this.spinIndex >= this.spinLoops*4) this.finishAtk(); }
      }
    }
    finishAtk(){ this.state='idle'; this.stateT=0; this.canCtrl=true; }
    draw(){
      let s=this.sStand;
      if(this.state==='walk') s=this.sWalk[Math.floor((performance.now()/120))%this.sWalk.length];
      else if(this.state==='jump') s=this.sWalk[1];
      else if(this.state==='atk1'){
        if(this.phase===1) s=(this.stateT<200)?this.sAtkPose:this.sAtkUp;
        else if(this.phase===2) s=(this.stateT<200)?this.sAtkPose:this.sAtkDash;
        else s=(this.stateT<200)?this.sAtkPose:this.sAtkFin;
      }else if(this.state==='atk2') s=(this.stateT<500)?this.sAtkPose:this.sUpper;
      else if(this.state==='skill') s=this.sSpin[this.spinIndex%4];
      const flip=(this.dir<0); const flash=(this.flashT>0 && Math.floor(performance.now()/70)%2===0);
      s.draw(this.x, this.y - this.height/2, flip, this.rot, this.alpha, flash);

      if(this.gaugeVis>0){
        const p=Math.min(1,this.gaugeVis/1000); const w=50,h=6;
        ctx.fillStyle='#001525aa'; ctx.fillRect(this.x-w/2, this.y - this.height - 18, w,h);
        ctx.fillStyle='#00d9ff';  ctx.fillRect(this.x-w/2, this.y - this.height - 18, w*p,h);
        this.gaugeVis-=20; if(this.gaugeVis<0) this.gaugeVis=0;
      }
    }
  }

  class Enemy extends Actor{
    constructor(imgs){ super();
      this.maxhp=500; this.hp=500; this.img=imgs; this.state='idle'; this.stateT=0; this.dir=-1; this.cd=0;
      this.baseH=TARGET.enemyH;
      this.sStand=new Sprite(); this.sStand.set(this.img.stand,this.baseH);
      this.sWalk=this.img.walk.map(i=>{const s=new Sprite(); s.set(i,this.baseH); return s;});
      this.sSmA=this.img.atk.small.map(i=>{const s=new Sprite(); s.set(i,this.baseH); return s;});
      this.sMdA=this.img.atk.mid.map(i=>{const s=new Sprite(); s.set(i,this.baseH); return s;});
      this.width=this.sStand.w*0.55; this.height=this.sStand.h*0.90;
    }
    ai(dt,world,player){
      if(this.dead) return;
      this.stateT+=dt; if(this.cd>0) this.cd-=dt;
      const dx=player.x-this.x; this.dir=dx>0?1:-1;
      if(['idle','walk'].includes(this.state)){
        if(Math.abs(dx)>120){ this.vx=1.5*Math.sign(dx); if(this.onGround) this.state='walk'; }
        else{ this.vx=0; if(this.cd<=0){
          if(Math.random()<0.4){ this.state='atkS'; this.stateT=0; this.cd=600; }
          else if(Math.random()<0.4){ this.state='atkM'; this.stateT=0; this.cd=800; }
          else{ this.state='atkChain'; this.stateT=0; this.chain=0; this.cd=1200; }
        }}
      }
      this.vy+=world.g; this.x+=this.vx; this.y+=this.vy;
      const gy=world.groundY;
      if(this.y>=gy){ this.y=gy; this.vy=0; this.onGround=true; } else this.onGround=false;

      this.hitboxes=[];
      if(this.state==='atkS'){
        if(this.stateT>80 && this.stateT<380){ const r=this.rect(); const ox=this.dir*(r.w*0.7); this.hitboxes.push({x:r.x+r.w/2+ox,y:r.y+r.h*0.5,w:50,h:50,dmg:5,kb:this.dir}); }
        if(this.stateT>420){ this.state='idle'; this.stateT=0; }
      }else if(this.state==='atkM'){
        if(this.stateT>120 && this.stateT<420){ const r=this.rect(); const ox=this.dir*(r.w*0.6); this.hitboxes.push({x:r.x+r.w/2+ox,y:r.y+r.h*0.45,w:56,h:70,dmg:8,kb:this.dir,launch:true}); }
        if(this.stateT>520){ this.state='idle'; this.stateT=0; }
      }else if(this.state==='atkChain'){
        if(this.chain===0){
          if(this.stateT>80 && this.stateT<320){ const r=this.rect(); const ox=this.dir*(r.w*0.65); this.hitboxes.push({x:r.x+r.w/2+ox,y:r.y+r.h*0.5,w:50,h:50,dmg:5,kb:this.dir}); }
          if(this.stateT>340){ this.chain=1; this.stateT=0; }
        }else{
          if(this.stateT>100 && this.stateT<360){ const r=this.rect(); const ox=this.dir*(r.w*0.6); this.hitboxes.push({x:r.x+r.w/2+ox,y:r.y+r.h*0.48,w:56,h:66,dmg:8,kb:this.dir}); }
          if(this.stateT>420){ this.state='idle'; this.stateT=0; }
        }
      }

      if(this.flashT>0) this.flashT-=dt;
    }
    draw(){
      let s=this.sStand;
      if(this.state==='walk') s=this.sWalk[Math.floor((performance.now()/140))%this.sWalk.length];
      else if(this.state==='atkS') s=this.sSmA[(this.stateT<200)?0:1];
      else if(this.state==='atkM' || (this.state==='atkChain'&&this.chain===1)) s=this.sMdA[(this.stateT<200)?0:1];
      else if(this.state==='atkChain' && this.chain===0) s=this.sSmA[(this.stateT<200)?0:1];
      const flip=(this.dir<0); const flash=(this.flashT>0 && Math.floor(performance.now()/70)%2===0);
      s.draw(this.x, this.y - this.height/2, flip, this.rot, this.alpha, flash);
    }
  }

  // World（v2: キャンバス内で完結）
  const world = {
    g:0.55,
    w:4000,
    get groundY(){ return H() - FLOOR_MARGIN; }, // ← UIと独立。沈まない＆被らない
    camX:0, camY:0,
    onPlayerDeath(){ lives=Math.max(0,lives-1); lifeEl.textContent=lives; respawnPlayer(); }
  };

  // Input
  const input = { ax:0, k1Pressed:false, k2Down:false, k2Released:false, skDown:false, skReleased:false, jumpPressed:false, dt:16 };
  function clearEdges(){ input.k1Pressed=false; input.k2Released=false; input.skReleased=false; input.jumpPressed=false; }

  // Stick
  const stickZone=document.getElementById('stickZone');
  const stickBase=document.getElementById('stickBase');
  const stickKnob=document.getElementById('stickKnob');
  let stickCenter={x: stickBase.offsetLeft+stickBase.offsetWidth/2, y: stickBase.offsetTop+stickBase.offsetHeight/2};
  stickZone.addEventListener('pointerdown',e=>{ e.preventDefault(); stickMove(e); stickZone.setPointerCapture(e.pointerId); });
  stickZone.addEventListener('pointermove',e=>{ if(e.pressure!==0){ e.preventDefault(); stickMove(e);} });
  stickZone.addEventListener('pointerup',e=>{ e.preventDefault(); stickEnd(); });
  stickZone.addEventListener('pointercancel',e=>{ e.preventDefault(); stickEnd(); });
  function stickMove(e){
    const r=stickZone.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top;
    const dx=x-stickCenter.x, dy=y-stickCenter.y; const len=Math.hypot(dx,dy); const max=52;
    const nx=len?dx/len:0, ny=len?dy/len:0; const mag=Math.min(1,len/max);
    input.ax=nx*mag; if(ny<-0.75 && Math.abs(dx)<40) input.jumpPressed=true;
    stickKnob.style.transform=`translate(${stickCenter.x-44 + nx*max}px, ${stickCenter.y-44 + ny*max}px)`;
  }
  function stickEnd(){ input.ax=0; stickKnob.style.transform=`translate(${stickCenter.x-44}px, ${stickCenter.y-44}px)`; }

  // Buttons
  const btnK1=document.getElementById('btnK1');
  const btnK2=document.getElementById('btnK2');
  const btnSK=document.getElementById('btnSK');
  const btnJP=document.getElementById('btnJP');
  btnK1.addEventListener('pointerdown',e=>{ e.preventDefault(); input.k1Pressed=true; });
  btnK2.addEventListener('pointerdown',e=>{ e.preventDefault(); input.k2Down=true; });
  btnK2.addEventListener('pointerup',e=>{ e.preventDefault(); input.k2Down=false; input.k2Released=true; });
  btnSK.addEventListener('pointerdown',e=>{ e.preventDefault(); input.skDown=true; });
  btnSK.addEventListener('pointerup',e=>{ e.preventDefault(); input.skDown=false; input.skReleased=true; });
  btnJP.addEventListener('pointerdown',e=>{ e.preventDefault(); input.jumpPressed=true; });

  // Keyboard
  const keys={};
  addEventListener('keydown',e=>{
    keys[e.code]=true;
    if(e.code==='KeyA'||e.code==='ArrowLeft') input.ax=-1;
    if(e.code==='KeyD'||e.code==='ArrowRight') input.ax=1;
    if(e.code==='KeyW'||e.code==='Space'||e.code==='ArrowUp') input.jumpPressed=true;
    if(e.code==='KeyJ') input.k1Pressed=true;
    if(e.code==='KeyK') input.k2Down=true;
    if(e.code==='KeyL') input.skDown=true;
  }, {passive:false});
  addEventListener('keyup',e=>{
    keys[e.code]=false;
    if(!keys.KeyA && !keys.ArrowLeft && !keys.KeyD && !keys.ArrowRight) input.ax=0;
    if(e.code==='KeyK'){ input.k2Down=false; input.k2Released=true; }
    if(e.code==='KeyL'){ input.skDown=false; input.skReleased=true; }
  });

  // Init
  let player, enemy, tileImg, lives=3, start=performance.now(), last=performance.now(), fpsS=60;
  Promise.all([
    loadImage(ASSETS.player.stand),
    ...ASSETS.player.walk.map(loadImage),
    loadImage(ASSETS.player.atk.pose),
    loadImage(ASSETS.player.atk.up),
    loadImage(ASSETS.player.atk.dash),
    loadImage(ASSETS.player.atk.fin),
    loadImage(ASSETS.player.atk.upper),
    ...ASSETS.player.spin.map(loadImage),
    loadImage(ASSETS.enemy.stand),
    ...ASSETS.enemy.walk.map(loadImage),
    ...ASSETS.enemy.atk.small.map(loadImage),
    ...ASSETS.enemy.atk.mid.map(loadImage),
    loadImage(ASSETS.tile)
  ]).then(img=>{
    const p={ stand:img[0], walk:img.slice(1,4), atk:{ pose:img[4], up:img[5], dash:img[6], fin:img[7], upper:img[8] }, spin:img.slice(9,13) };
    const eBase=13, e={ stand:img[eBase+0], walk:img.slice(eBase+1,eBase+3), atk:{ small:img.slice(eBase+3,eBase+5), mid:img.slice(eBase+5,eBase+7) } };
    tileImg=img[eBase+7];
    init(p,e); requestAnimationFrame(loop);
  });

  function init(pimgs,eimgs){
    player=new Player(pimgs);
    // v2: 初期位置を「床より少し左」に
    player.x=200; player.y=world.groundY;

    enemy=new Enemy(eimgs);
    enemy.x=620; enemy.y=world.groundY;
  }
  function respawnPlayer(){
    player=new Player({
      stand:cache[ASSETS.player.stand],
      walk:ASSETS.player.walk.map(p=>cache[p]),
      atk:{ pose:cache[ASSETS.player.atk.pose], up:cache[ASSETS.player.atk.up], dash:cache[ASSETS.player.atk.dash], fin:cache[ASSETS.player.atk.fin], upper:cache[ASSETS.player.atk.upper] },
      spin:ASSETS.player.spin.map(p=>cache[p])
    });
    player.x=200; player.y=world.groundY; player.dir=1;
  }

  // AABB
  function hit(a,b){ return a.x<a.x+a.w, a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

  function loop(t){
    const dt=Math.min(32,t-last); last=t; input.dt=dt;
    fpsS=fpsS*0.9+(1000/dt)*0.1; fpsEl.textContent=Math.round(fpsS);
    update(dt); draw(); clearEdges(); requestAnimationFrame(loop);
  }

  function update(dt){
    player.update(dt,input,world);
    enemy.ai(dt,world,player);

    // Player -> Enemy
    for(const hb of player.attackHB()){
      const er=enemy.rect();
      if(hb && er && hb.x < er.x+er.w && hb.x+hb.w > er.x && hb.y < er.y+er.h && hb.y+hb.h > er.y && !enemy.dead){
        enemy.hurt(hb.dmg,hb.kb); ehpEl.style.width=`${Math.max(0,(enemy.hp/enemy.maxhp)*100)}%`;
      }
    }
    // Enemy -> Player
    if(enemy.hitboxes){
      for(const hb of enemy.hitboxes){
        const pr=player.rect();
        if(hb && pr && hb.x < pr.x+pr.w && hb.x+hb.w > pr.x && hb.y < pr.y+pr.h && hb.y+hb.h > pr.y && !player.dead){
          player.hurt(hb.dmg,hb.kb); if(hb.launch) player.vy=-8.5; phpEl.style.width=`${Math.max(0,(player.hp/player.maxhp)*100)}%`;
        }
      }
    }

    // カメラ：前方オフセット
    const margin=140;
    world.camX=Math.max(0, Math.min(player.x - W()/2 + margin*player.dir, world.w - W()));

    // 敵リスパン（テスト）
    if(enemy.dead && enemy.updateDeath(dt)){
      enemy=new Enemy({
        stand:cache[ASSETS.enemy.stand],
        walk:ASSETS.enemy.walk.map(p=>cache[p]),
        atk:{ small:ASSETS.enemy.atk.small.map(p=>cache[p]), mid:ASSETS.enemy.atk.mid.map(p=>cache[p]) }
      });
      enemy.x=player.x+380; enemy.y=world.groundY;
    }

    // タイマー
    const el=Math.floor((performance.now()-start)/1000);
    tmEl.textContent=`${Math.floor(el/60)}:${(el%60).toString().padStart(2,'0')}`;
  }

  function draw(){
    ctx.clearRect(0,0,W(),H());
    const g=ctx.createLinearGradient(0,0,0,H()); g.addColorStop(0,'#0a1220'); g.addColorStop(1,'#04070d');
    ctx.fillStyle=g; ctx.fillRect(0,0,W(),H());

    ctx.save(); ctx.translate(-world.camX, -world.camY);

    // 地面（S1.png）— v2: キャンバス基準の床ラインに正しく配置
    const gy=world.groundY;
    if(tileImg){
      const scale=0.6;
      const dw=tileImg.width*scale, dh=tileImg.height*scale;
      const startX=Math.floor((world.camX - W())/dw)*dw - dw*2;
      const endX=world.camX + W() + dw*2;
      for(let x=startX; x<endX; x+=dw){
        ctx.drawImage(tileImg, x, gy - dh + 4, dw, dh);
      }
    }else{
      ctx.fillStyle='#1b2233'; ctx.fillRect(world.camX - W(), gy+4, world.w+W()*2, 40);
    }

    // 影
    function shadow(a){ ctx.fillStyle='rgba(0,0,0,.35)'; ctx.beginPath(); ctx.ellipse(a.x, gy+2, a.width*0.5, 10, 0, 0, Math.PI*2); ctx.fill(); }
    shadow(enemy); shadow(player);

    enemy.draw(); player.draw();

    ctx.restore();
  }

  // リサイズ：縦画面。キャンバスは「上段」だけの高さに設定
  function fit(){
    const dpr=Math.min(2, devicePixelRatio||1);
    const uiH=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--ui-h'));
    const vw=Math.min(innerWidth, 540);
    const vh=innerHeight - uiH - parseInt(getComputedStyle(document.documentElement).getPropertyValue('env(safe-area-inset-bottom)')||'0');
    canvas.style.width='100%'; canvas.style.height='100%';
    canvas.width=Math.floor(vw*dpr);
    canvas.height=Math.floor(vh*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize',fit,{passive:true});
  fit();

})();
</script>
</body>
</html>
