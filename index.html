<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>MOB Side-Action – Solo Test</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{
    --bg:#06080d; --hud:#0b0f18cc; --panel:#0d1322cc; --grid:#182133;
    --btn:#0f1728aa; --btn-edge:#1a2540; --btn-active:#142038;
    --txt:#e9eef7; --accent:#3ad; --accent2:#8cf; --warn:#ff6a6a;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--txt);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overscroll-behavior:none}
  body{touch-action:none}
  #root{position:fixed;inset:0;display:grid;grid-template-rows:1fr auto;gap:0}

  header.hud{
    position:fixed;left:0;right:0;top:0;z-index:10;
    padding:calc(env(safe-area-inset-top,0px) + 6px) 10px 6px;
    display:flex;gap:8px;align-items:center;justify-content:space-between
  }
  header.hud .card{background:var(--hud);backdrop-filter:blur(6px);border:1px solid #111824;border-radius:10px;padding:6px 8px;display:flex;gap:8px;align-items:center}
  .hud .bar{height:8px;width:140px;background:#0b1020;border-radius:6px;overflow:hidden;border:1px solid #1a2234}
  .hud .bar>i{display:block;height:100%;width:50%;background:linear-gradient(90deg,#59f,#4df,#59f)}
  .hud small{opacity:.85;font-size:12px}

  #gameWrap{position:relative;display:grid;grid-template-rows:1fr auto;height:100%}
  #gameArea{position:relative}
  canvas#game{position:absolute;inset:0;width:100%;height:100%}

  /* 下パネル（明確なグリッド分割） */
  #panel{
    position:relative;
    background:linear-gradient(0deg,var(--panel),var(--panel)), linear-gradient(180deg,transparent 0,transparent calc(100% - 2px),var(--grid) calc(100% - 2px));
    border-top:2px solid var(--grid);
    padding:10px calc(env(safe-area-inset-right,0px) + 10px) calc(env(safe-area-inset-bottom,0px) + 10px) calc(env(safe-area-inset-left,0px) + 10px);
    display:grid;grid-template-columns:1fr 1fr;gap:8px;align-items:center;
  }

  /* ジョイスティック（全体小さめ） */
  .stickZone{position:relative;height:112px}
  .stickOuter{
    position:absolute;left:8px;bottom:6px;width:112px;height:112px;border-radius:50%;
    background:radial-gradient(transparent 50%, #0f1728 50% 100%);
    border:1px solid var(--btn-edge);
  }
  .stickInner{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    width:56px;height:56px;border-radius:50%;
    background:radial-gradient(#182544,#0f192a);
    border:1px solid var(--btn-edge);
    box-shadow:0 3px 8px rgba(0,0,0,.35);
  }

  /* ボタン群（小さめ） */
  .btnZone{position:relative;height:112px}
  .btn{
    position:absolute;display:grid;place-items:center;
    width:56px;height:56px;border-radius:15px;background:var(--btn);border:1px solid var(--btn-edge);
    box-shadow:inset 0 -3px 8px rgba(0,0,0,.25), 0 3px 10px rgba(0,0,0,.22);
    font-weight:800;font-size:20px;user-select:none
  }
  .btn:active{background:var(--btn-active)}
  .btn span{pointer-events:none}
  /* 配置：×右下、■左上、▲右上、●中上 */
  #btnJump{right:8px;bottom:6px}
  #btnA{right:78px;bottom:46px}
  #btnB{right:8px;bottom:88px}
  #btnSkill{right:60px;bottom:92px}

  .ring{position:absolute;inset:-3px;border-radius:18px;border:3px solid transparent;opacity:.8;pointer-events:none}
  .ring.on{border-color:var(--accent)}
  .ring.skill{border-color:#7cf}

  .label{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    background:#0f172aaa;border:1px solid #1b2436;border-radius:10px;padding:6px 10px;font-weight:700;font-size:13px
  }
</style>
</head>
<body>
<div id="root">
  <header class="hud">
    <div class="card" id="hudHP"><strong style="font-size:12px">HP</strong>
      <div class="bar" style="width:160px"><i id="hpFill" style="width:100%"></i></div>
      <small id="hpTxt">1000 / 1000</small>
    </div>
    <div class="card"><small id="hudMsg">READY</small></div>
    <div class="card"><small>FPS:<span id="fps">60</span></small></div>
    <div class="card"><small>Time:<span id="time">00:00</span></small></div>
  </header>

  <div id="gameWrap">
    <div id="gameArea">
      <canvas id="game"></canvas>
      <div class="label" id="centerMsg" style="display:none"></div>
    </div>

    <div id="panel">
      <div class="stickZone">
        <div class="stickOuter" id="stickOuter">
          <div class="stickInner" id="stickInner"></div>
        </div>
      </div>
      <div class="btnZone">
        <div class="btn" id="btnA" aria-label="Attack 1"><span>■</span><div class="ring" id="ringA"></div></div>
        <div class="btn" id="btnB" aria-label="Attack 2"><span>▲</span><div class="ring on" id="ringB" style="opacity:.0"></div></div>
        <div class="btn" id="btnSkill" aria-label="Skill"><span>●</span><div class="ring skill" id="ringSkill" style="opacity:.0"></div></div>
        <div class="btn" id="btnJump" aria-label="Jump"><span>×</span></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  /* =================== 基本設定（コンパクト化） =================== */
  const cfg = {
    targetFPS: 60,
    physicsSteps: 2,
    gravity: 2300,
    moveSpeed: 170,         // 小さめ画面用に速度も微調整
    airControl: 0.6,
    jumpVel: 720,
    coyoteMs: 120,
    jumpBufMs: 120,
    tile: 32,               // タイル小さめ
    stageWidth: 4000,       // テスト用
    floorY: 0,
    camSmooth: 0.12,
    hitStopMs: 70,
    iFramesMs: 300,
    knockBack: {vx: 230, vy: 190},
    flashMs: 230,
    deathFadeMs: 650,
    playerMaxHP: 1000,

    // 攻撃定義（小画面向けに前進量も控えめ）
    atk: {
      A1: {prep:0.25, dur:0.28, dmg:5,  imgPrep:"K1-3.png", img:"K1-1.png", forward:0},
      A2: {prep:0.25, dur:0.28, dmg:8,  imgPrep:"K1-3.png", img:"K1-2.png", forward:26},
      A3: {prep:0.25, dur:0.28, dmg:10, imgPrep:"K1-3.png", img:"K1-4.png", forward:26},
      B:  {prep:0.45, dur:0.30, dmg:15, imgPrep:"K1-3.png", img:"K1-5.png", forward:34, chargeMin:0.5, chargePrep:0.95, dmgCharged:18},
    },
    skill: {
      frames:["h1.png","h2.png","h3.png","h4.png"],
      cyclesTap:2, cyclesHold:4,
      holdMax:1.0,
      dmgTap:25, dmgHold:40,
      frameHz:16
    }
  };

  /* =================== Canvas / レイアウト =================== */
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d', { alpha: true, desynchronized:true });
  let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  function resize(){
    const area = document.getElementById('gameArea');
    const w = area.clientWidth;
    const h = area.clientHeight;
    cvs.width = Math.round(w * dpr);
    cvs.height = Math.round(h * dpr);
    cvs.style.width = w + 'px';
    cvs.style.height = h + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    cfg.floorY = Math.round(h - 128); // 下部UIと被らない高さに
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  /* =================== アセット（自動トリム＆基準化） =================== */
  const assetNames = [
    "M1-1.png","M1-2.png","M1-3.png","M1-4.png",
    "K1-1.png","K1-2.png","K1-3.png","K1-4.png","K1-5.png",
    "h1.png","h2.png","h3.png","h4.png",
    "S1.png"
  ];
  const Assets = new Map();

  function loadImage(src){
    return new Promise((resolve)=>{
      const img = new Image();
      img.onload=()=>resolve({img,ok:true});
      img.onerror=()=>resolve({img:null,ok:false});
      img.src=src;
    });
  }

  function makePlaceholderCanvas(w=72,h=72,label="MISSING"){
    const c = document.createElement('canvas');
    c.width = Math.max(40,w); c.height = Math.max(40,h);
    const x = c.getContext('2d');
    x.fillStyle = "#223"; x.fillRect(0,0,c.width,c.height);
    x.fillStyle = "#556";
    for(let i=0;i<c.width;i+=6){x.fillRect(i,0,1,c.height)}
    x.fillStyle = "#9cf"; x.font="bold 10px system-ui";
    x.textAlign="center"; x.textBaseline="middle";
    x.fillText(label, c.width/2, c.height/2);
    c.__trim = {sx:0,sy:0,tw:c.width,th:c.height};
    return c;
  }

  function trimImageToCanvas(img){
    const w=img.width, h=img.height;
    const oc=document.createElement('canvas'); oc.width=w; oc.height=h;
    const ox=oc.getContext('2d'); ox.drawImage(img,0,0);
    let sx=w, sy=h, ex=0, ey=0;
    try{
      const d=ox.getImageData(0,0,w,h).data;
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const a = d[(y*w+x)*4+3];
          if(a>10){ if(x<sx)sx=x; if(y<sy)sy=y; if(x>ex)ex=x; if(y>ey)ey=y; }
        }
      }
      if(ex<sx || ey<sy) return makePlaceholderCanvas(w,h);
      const tw=ex-sx+1, th=ey-sy+1;
      const tc=document.createElement('canvas'); tc.width=tw; tc.height=th;
      tc.getContext('2d').drawImage(oc,sx,sy,tw,th,0,0,tw,th);
      tc.__trim={sx,sy,tw,th};
      return tc;
    }catch(e){ return makePlaceholderCanvas(w,h); }
  }

  function tintDraw(imageCanvas, dx, dy, dw, dh, flipped=false, tintOn=false){
    if(!tintOn){
      if(flipped){
        ctx.save(); ctx.translate(dx+dw, dy); ctx.scale(-1,1);
        ctx.drawImage(imageCanvas,0,0,imageCanvas.width,imageCanvas.height,0,0,dw,dh);
        ctx.restore();
      }else{
        ctx.drawImage(imageCanvas,0,0,imageCanvas.width,imageCanvas.height,dx,dy,dw,dh);
      }
      return;
    }
    const oc=document.createElement('canvas');
    oc.width=Math.max(1,dw|0); oc.height=Math.max(1,dh|0);
    const ox=oc.getContext('2d');
    ox.drawImage(imageCanvas,0,0,imageCanvas.width,imageCanvas.height,0,0,oc.width,oc.height);
    ox.globalCompositeOperation='source-atop';
    ox.fillStyle='rgba(255,60,60,0.7)';
    ox.fillRect(0,0,oc.width,oc.height);
    if(flipped){ ctx.save(); ctx.translate(dx+dw,dy); ctx.scale(-1,1); ctx.drawImage(oc,0,0); ctx.restore(); }
    else{ ctx.drawImage(oc,dx,dy); }
  }

  async function loadAll(){
    const list = await Promise.all(assetNames.map(n=>loadImage(n)));
    for(let i=0;i<assetNames.length;i++){
      const key=assetNames[i];
      if(list[i].ok) Assets.set(key, trimImageToCanvas(list[i].img));
      else Assets.set(key, makePlaceholderCanvas(72,72,key));
    }
    // 基準：M1-1高さに合わせて歩き3枚を正規化
    const base = Assets.get("M1-1.png");
    const baseH = base? base.height : 72;
    ["M1-2.png","M1-3.png","M1-4.png"].forEach(k=>{
      const src=Assets.get(k); if(!src) return;
      if(src.height===baseH) return;
      const s=baseH/src.height;
      const c=document.createElement('canvas');
      c.width=Math.round(src.width*s); c.height=Math.round(src.height*s);
      c.getContext('2d').drawImage(src,0,0,src.width,src.height,0,0,c.width,c.height);
      c.__trim={sx:0,sy:0,tw:c.width,th:c.height};
      Assets.set(k,c);
    });
  }

  /* =================== 入力（キー + タッチ） =================== */
  const keys = {left:false,right:false,up:false};
  addEventListener('keydown', e=>{
    if(e.repeat) return;
    switch(e.code){
      case 'ArrowLeft':case 'KeyA': keys.left=true; break;
      case 'ArrowRight':case 'KeyD': keys.right=true; break;
      case 'ArrowUp':case 'KeyW':case 'Space': keys.up=true; jumpPress(); break;
      case 'KeyJ': pressA(); break;
      case 'KeyK': pressB(); break;
      case 'KeyL': pressSkill(); break;
    }
  });
  addEventListener('keyup', e=>{
    switch(e.code){
      case 'ArrowLeft':case 'KeyA': keys.left=false; break;
      case 'ArrowRight':case 'KeyD': keys.right=false; break;
      case 'ArrowUp':case 'KeyW':case 'Space': keys.up=false; break;
      case 'KeyK': releaseB(); break;
      case 'KeyL': releaseSkill(); break;
    }
  });

  // 仮想スティック
  const stickOuter = document.getElementById('stickOuter');
  const stickInner = document.getElementById('stickInner');
  let stickId=null, stickVec={x:0,y:0};
  function updateStickVisual(){
    const r=42;
    stickInner.style.left=`calc(50% + ${stickVec.x*r}px)`;
    stickInner.style.top =`calc(50% + ${stickVec.y*r}px)`;
  }
  function setStickFromTouch(e){
    const t=[...e.changedTouches].find(t=>t.identifier===stickId) || e.changedTouches[0];
    const rect=stickOuter.getBoundingClientRect();
    const cx=rect.left+rect.width/2, cy=rect.top+rect.height/2;
    const dx=(t.clientX-cx)/(rect.width/2), dy=(t.clientY-cy)/(rect.height/2);
    const len=Math.hypot(dx,dy);
    let x=dx,y=dy; if(len>1){x/=len; y/=len;}
    stickVec.x=Math.max(-1,Math.min(1,x));
    stickVec.y=Math.max(-1,Math.min(1,y));
    keys.left = stickVec.x < -0.25;
    keys.right= stickVec.x >  0.25;
    updateStickVisual();
  }
  stickOuter.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.changedTouches[0]; stickId=t.identifier; setStickFromTouch(e); }, {passive:false});
  stickOuter.addEventListener('touchmove',  e=>{ e.preventDefault(); if(stickId!=null) setStickFromTouch(e); }, {passive:false});
  const resetStick=()=>{ stickId=null; stickVec.x=stickVec.y=0; keys.left=keys.right=false; updateStickVisual(); };
  stickOuter.addEventListener('touchend',   e=>{ if([...e.changedTouches].some(t=>t.identifier===stickId)) resetStick(); }, {passive:true});
  stickOuter.addEventListener('touchcancel',e=> resetStick(), {passive:true});

  // ボタン（反応不良対策：広い当たりとpointercancel対応）
  const btnJump=document.getElementById('btnJump');
  const btnA=document.getElementById('btnA');
  const btnB=document.getElementById('btnB');
  const btnSkill=document.getElementById('btnSkill');
  const ringB=document.getElementById('ringB');
  const ringSkill=document.getElementById('ringSkill');

  function bindPressHold(btn, onPress, onRelease){
    let id=null, pressing=false;
    btn.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.changedTouches[0]; id=t.identifier; pressing=true; onPress&&onPress(); }, {passive:false});
    btn.addEventListener('touchend',   e=>{ if([...e.changedTouches].some(t=>t.identifier===id)){ pressing=false; onRelease&&onRelease(); }}, {passive:true});
    btn.addEventListener('touchcancel',e=>{ pressing=false; onRelease&&onRelease(); }, {passive:true});
    btn.addEventListener('mousedown', e=>{ e.preventDefault(); pressing=true; onPress&&onPress(); });
    btn.addEventListener('mouseup',   e=>{ pressing=false; onRelease&&onRelease(); });
    btn.addEventListener('mouseleave',e=>{ if(pressing){ pressing=false; onRelease&&onRelease(); }});
  }
  bindPressHold(btnJump, ()=>jumpPress(), null);
  bindPressHold(btnA, ()=>pressA(), null);
  bindPressHold(btnB, ()=>pressB(), ()=>releaseB());
  bindPressHold(btnSkill, ()=>pressSkill(), ()=>releaseSkill());

  /* =================== エンティティ（プレイヤーのみ） =================== */
  const hudHP=document.getElementById('hpTxt');
  const hpFill=document.getElementById('hpFill');
  const hudMsg=document.getElementById('hudMsg');
  const fpsTxt=document.getElementById('fps');
  const timeTxt=document.getElementById('time');
  const centerMsg=document.getElementById('centerMsg');

  let now=performance.now(), acc=0, lastFps=now, frames=0, elapsedSec=0;

  function clamp(v,min,max){ return v<min?min:v>max?max:v; }
  function lerp(a,b,t){ return a+(b-a)*t; }

  class Entity{
    constructor(){
      this.x=160; this.y=cfg.floorY; this.vx=0; this.vy=0;
      this.w=44; this.h=64;           // 小さめ
      this.facing=1;
      this.onGround=false;
      this.dead=false;
      this.flashUntil=0;
      this.iframesUntil=0;
      this.spin=0; this.fade=1;
      this.hp=cfg.playerMaxHP;
      this.type='player';
      // プレイヤー状態
      this.state='idle';
      this.lockMove=false;
      this.lastGroundTime=0;
      this.jumpBufTime=-9999;
      this.animTimer=0;
      // コンボ
      this.comboQueue=[];
      this._chain=0;
    }
    rect(){ return {x:this.x-this.w/2, y:this.y-this.h, w:this.w, h:this.h}; }
  }

  const player=new Entity();

  /* =================== ダメージ表現（対ターゲットなしでも自己テスト可） =================== */
  function damageDummyFlash(){
    // テスト用（敵が居ないので、当たりは出すだけ／視覚効果は保持）
    const tNow=performance.now();
    player.flashUntil=tNow+cfg.flashMs;
  }

  /* =================== 操作 =================== */
  function refreshHUD(){
    const hp=clamp(player.hp,0,cfg.playerMaxHP);
    const r=Math.round(hp*100/cfg.playerMaxHP);
    hpFill.style.width = r+"%";
    hpFill.style.background = r<30 ? `linear-gradient(90deg,#f66,#f99)` : `linear-gradient(90deg,#59f,#4df,#59f)`;
    hudHP.textContent = `${hp} / ${cfg.playerMaxHP}`;
  }
  refreshHUD();

  function jumpPress(){
    const t=performance.now();
    player.jumpBufTime=t;
    if(player.onGround || (t-player.lastGroundTime)<cfg.coyoteMs){
      player.vy = -cfg.jumpVel; player.onGround=false;
    }
  }

  // 先行入力キュー（攻撃中も受け付け）
  function enqueue(type, charged=false){
    player.comboQueue.push({type, charged, time:performance.now()});
  }

  // 入力API
  let holdingB=false, bStart=0;
  let holdingSkill=false, sStart=0;
  function pressA(){ enqueue('A'); tryStartIfIdle(); }
  function pressB(){ holdingB=true; bStart=performance.now(); ringB.style.opacity=1; }
  function releaseB(){
    if(!holdingB) return;
    holdingB=false; ringB.style.opacity=0;
    const charged = (performance.now()-bStart) >= (cfg.atk.B.chargeMin*1000);
    enqueue('B', charged);
    tryStartIfIdle();
  }
  function pressSkill(){ holdingSkill=true; sStart=performance.now(); ringSkill.style.opacity=1; }
  function releaseSkill(){
    if(!holdingSkill) return;
    holdingSkill=false; ringSkill.style.opacity=0;
    const charged = Math.min(cfg.skill.holdMax,(performance.now()-sStart)/1000) >= cfg.skill.holdMax*0.99;
    startSkill(charged);
  }

  function tryStartIfIdle(){
    if(['idle','run','jump','fall'].includes(player.state) && player.comboQueue.length>0){
      startNextAction();
    }
  }

  function startNextAction(){
    // 連撃ロジック：Aは A1→A2→A3 の順。Bはいつでも次に出せる（キャンセル不可なので攻撃終了後に発動）
    if(player.comboQueue.length===0){ player.state='idle'; player.lockMove=false; return; }
    const peek = player.comboQueue[0];
    if(peek.type==='A'){ startAttackChain(); }
    else if(peek.type==='B'){ const item=player.comboQueue.shift(); startAttackB(item.charged); }
  }

  function startAttackChain(){
    // キュー先頭がAであることは保証済み
    player.comboQueue.shift();
    const step = Math.min(2, player._chain|0);
    const def = [cfg.atk.A1,cfg.atk.A2,cfg.atk.A3][step];
    player._chain = step+1;
    startAttack(def, ()=>{
      // 次がAなら継続（A1→A2→A3）／それ以外ならチェーン終了
      if(player.comboQueue.length>0 && player.comboQueue[0].type==='A'){
        startAttackChain();
      }else{
        player._chain=0;
        startNextAction();
      }
    });
  }

  function startAttackB(charged){
    const def = Object.assign({}, cfg.atk.B);
    if(charged){ def.prep=cfg.atk.B.chargePrep; def.dmg=cfg.atk.B.dmgCharged; }
    startAttack(def, ()=>{ startNextAction(); });
  }

  function spawnHitbox(owner, dmg){
    // 現状は演出のみ（敵なし）。ヒットストップと点滅でフィーリング確認。
    damageDummyFlash();
  }

  function startAttack(def, onEnd){
    player.lockMove=true;
    player.state='prep';
    // 準備→攻撃
    setTimeout(()=>{
      player.state='attack';
      // 前進（A2/A3/B）
      if(def.forward) player.vx = player.facing * def.forward;
      // ヒットを少なくとも2回に分ける（手応え向上）
      setTimeout(()=> spawnHitbox(player, def.dmg), 30);
      setTimeout(()=> spawnHitbox(player, Math.round(def.dmg*0.6)), Math.max(40, def.dur*1000*0.55|0));
      // 攻撃終了
      setTimeout(()=>{
        player.lockMove=false;
        onEnd && onEnd();
      }, def.dur*1000);
    }, def.prep*1000);
  }

  function startSkill(charged){
    if(player.state==='skill') return;
    player.lockMove=true; player.state='skill';
    const cycles = charged? cfg.skill.cyclesHold : cfg.skill.cyclesTap;
    const totalFrames = cycles * cfg.skill.frames.length;
    const durMs = totalFrames * (1000/cfg.skill.frameHz);
    const totalHits = charged? Math.max(6, cycles*3) : Math.max(4, cycles*2);
    const dmg = charged? Math.round(cfg.skill.dmgHold/(totalHits/2)) : Math.round(cfg.skill.dmgTap/(totalHits/2));
    let ticks=0;
    const iv=setInterval(()=>{ if(player.state!=='skill'){clearInterval(iv);return;}
      spawnHitbox(player, dmg);
      if(++ticks>=totalHits) clearInterval(iv);
    }, 120);
    setTimeout(()=>{ player.lockMove=false; player.state='idle'; }, durMs);
  }

  /* =================== 物理・ステージ =================== */
  function physicsStep(e){
    const dt=e.dt/cfg.physicsSteps;
    // 重力
    player.vy += cfg.gravity*dt;
    // 入力移動
    if(!player.lockMove){
      const accel = player.onGround? 1 : cfg.airControl;
      const dir = (keys.left?-1:0) + (keys.right?1:0);
      player.vx = lerp(player.vx, dir*cfg.moveSpeed, 0.35*accel);
      if(dir!==0) player.facing = dir>0?1:-1;
    }
    // 移動反映
    player.x += player.vx*dt;
    player.y += player.vy*dt;

    // 床
    if(player.y >= cfg.floorY){
      player.y = cfg.floorY; player.vy=0; player.onGround=true; player.lastGroundTime=performance.now();
    }else{ player.onGround=false; }

    // 落下死（ステージ外）
    const viewH = cvs.height/dpr;
    if(player.y > viewH+240){ respawn(); }
  }

  function respawn(){
    player.x=160; player.y=cfg.floorY; player.vx=player.vy=0; player.state='idle'; player.lockMove=false; player._chain=0; player.comboQueue.length=0;
  }

  function drawStage(camx){
    const tileImg = Assets.get("S1.png");
    const th = tileImg? tileImg.height : cfg.tile;
    const tw = tileImg? tileImg.width  : cfg.tile;
    const groundY = cfg.floorY;
    const startX = Math.floor((camx-80)/tw)*tw;
    for(let x=startX; x<camx + cvs.width/dpr + 80; x+=tw){
      const dx = Math.round(x - camx);
      ctx.drawImage(tileImg, dx, groundY, tw, th);
    }
  }

  /* =================== 描画 =================== */
  function drawPlayer(){
    const tNow=performance.now();
    const flashing = tNow < player.flashUntil;
    const flipped = player.facing<0;

    // 状態→画像
    let key=null;
    if(player.state==='attack' || player.state==='prep'){
      key = "K1-1.png"; // 攻撃中は攻撃絵（簡易）
    }else if(Math.abs(player.vx)>18 && player.onGround){
      const frames=["M1-2.png","M1-3.png","M1-4.png"];
      const idx=((Math.floor(player.animTimer*10))%frames.length)|0;
      key = frames[idx];
    }else{
      key="M1-1.png";
    }
    const img = Assets.get(key) || makePlaceholderCanvas(72,72,key);
    const w=player.w, h=player.h;
    const dx = Math.round(player.x - game.camera.x - w/2);
    const dy = Math.round(player.y - h - game.camera.y);
    ctx.save();
    tintDraw(img, dx, dy, w, h, flipped, flashing);
    ctx.restore();

    // スキル長押し中の小ゲージ（頭上）
    if(holdingSkill){
      const held = Math.min(cfg.skill.holdMax,(performance.now()-sStart)/1000);
      const gx = player.x - game.camera.x;
      const gy = player.y - player.h - 12 - game.camera.y;
      ctx.fillStyle="#0a0f18"; ctx.fillRect(gx-36, gy, 72, 5);
      ctx.strokeStyle="#1b2436"; ctx.strokeRect(gx-36, gy, 72, 5);
      ctx.fillStyle="#adf"; ctx.fillRect(gx-36, gy, 72*held/cfg.skill.holdMax, 5);
    }
  }

  const game={camera:{x:0,y:0}};
  function update(dt){
    elapsedSec += dt;

    // 状態更新
    if(!player.lockMove){
      if(!player.onGround){ player.state = (player.vy<0)?'jump':'fall'; }
      else if(Math.abs(player.vx)>16) player.state='run';
      else player.state='idle';
    }

    // 先行入力があれば開始（常時監視）
    if(['idle','run','jump','fall'].includes(player.state) && player.comboQueue.length>0){
      startNextAction();
    }

    // ジャンプ入力バッファ
    if((performance.now()-player.jumpBufTime)<cfg.jumpBufMs && (player.onGround || (performance.now()-player.lastGroundTime)<cfg.coyoteMs)){
      player.vy = -cfg.jumpVel; player.onGround=false; player.jumpBufTime=-9999;
    }

    // 物理（分割ステップ）
    for(let i=0;i<cfg.physicsSteps;i++){ physicsStep({dt}); }

    // カメラ（上下固定・横のみ追従）
    const targetX = clamp(player.x - (cvs.width/dpr)/2, 0, cfg.stageWidth);
    game.camera.x = lerp(game.camera.x, targetX, cfg.camSmooth);

    // HUD
    player.animTimer += dt;
  }

  function render(){
    ctx.clearRect(0,0,cvs.width/dpr, cvs.height/dpr);
    drawStage(game.camera.x);
    drawPlayer();
  }

  function loop(t){
    const dt=Math.min(0.034,(t-now)/1000); now=t; acc+=dt;
    if(acc >= 1/cfg.targetFPS){
      const step=acc; acc=0;
      update(step);
      render();
      frames++;
    }
    if(t - lastFps >= 500){ fpsTxt.textContent = Math.min(60, Math.round(frames*2)); frames=0; lastFps=t; }
    const m=Math.floor(elapsedSec/60), s=Math.floor(elapsedSec%60);
    timeTxt.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    requestAnimationFrame(loop);
  }

  function showCenterMsg(msg, ms=800){
    centerMsg.textContent=msg; centerMsg.style.display='block';
    setTimeout(()=> centerMsg.style.display='none', ms);
  }

  /* =================== 起動 =================== */
  (async function start(){
    hudMsg.textContent='LOADING...';
    await loadAll();

    // 基準画像の高さを元に、プレイヤー実寸をさらに小さく（画面比に最適化）
    const base=Assets.get("M1-1.png");
    const bh= base? base.height : 72;
    // 小さめ：頭身や余白の違いを吸収
    player.h = Math.round(bh * 0.9);
    player.w = Math.round(bh * 0.62);

    player.x=160; player.y=cfg.floorY;

    refreshHUD();
    hudMsg.textContent='READY';
    requestAnimationFrame(loop);
  })();

})();
</script>
</body>
</html>
