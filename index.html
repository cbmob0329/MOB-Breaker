<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, maximum-scale=1" />
<title>MOB Side Action – Rev26 (Teams + Latest Player Moves)</title>
<meta name="theme-color" content="#0b0c10" />
<style>
:root{ --stage-w:420px; --stage-h:720px; --hud-bg:#0b0f17cc; --fg:#e9eef7; --grid-gap:10px; }
html,body{height:100%;margin:0;background:#0a0d13;color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;overscroll-behavior:none}
html,body{-webkit-user-select:none;-webkit-touch-callout:none;user-select:none}
*{box-sizing:border-box}
#root{position:fixed;inset:env(safe-area-inset-top,0) env(safe-area-inset-right,0) env(safe-area-inset-bottom,0) env(safe-area-inset-left,0);display:grid;place-items:center;padding:10px}
#phone{width:var(--stage-w);height:var(--stage-h);position:relative;overflow:hidden;background:#060910;border:1px solid #0f1726;border-radius:20px;box-shadow:0 12px 48px rgba(0,0,0,.55);touch-action:none}
.grid{position:absolute;inset:0;display:grid;grid-template-rows: 1fr 220px;gap:var(--grid-gap);padding:var(--grid-gap);margin:0 auto}
.gamewrap{position:relative;border-radius:14px;overflow:hidden;background:#05070c;outline:1px solid #0e1522}
canvas#game{display:block;width:100%;height:100%;background:#05070c}
.controls{position:relative;border-radius:14px;background:var(--hud-bg);outline:1px solid #0e1522;backdrop-filter: blur(6px);padding:12px;display:grid;grid-template-columns: 1fr 1fr;gap:12px}
.stickArea{position:relative;border-radius:12px;background:#0a121f;outline:1px solid #152033;display:grid;place-items:center;touch-action:none}
.stick{width:120px;height:120px;border-radius:50%;background:#0d1828;outline:2px solid #22324d;position:relative}
.stickThumb{width:64px;height:64px;border-radius:50%;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#1a2a45;outline:2px solid #2e4a73;box-shadow:inset 0 0 0 4px #0c1422}
.buttons{display:grid;grid-template-columns: repeat(3,1fr);grid-template-rows: repeat(2,1fr);gap:12px;align-content:stretch;justify-items:stretch}
.btn{border:none;border-radius:14px;background:#0d1828;outline:2px solid #22324d;color:var(--fg);font-size:26px;display:grid;place-items:center;touch-action:none;box-shadow:inset 0 -4px 0 rgba(255,255,255,.04);transition:opacity .15s ease;min-height:64px}
.btn:active{transform:scale(.98)}
.btn[disabled]{opacity:.35;pointer-events:none}
.btn.attack1{background:#112033}
.btn.attack2{background:#1a2436}
.btn.skill1 {background:#132a22}
.btn.skill2 {background:#1f2433}
.btn.ult    {background:#2b2030}
.btn.spacer {opacity:0; pointer-events:none}
header.hud{position:absolute;left:0;right:0;top:0;padding:10px 14px;display:flex;gap:10px;align-items:center;z-index:10;pointer-events:none}
.chip{background:var(--hud-bg);outline:1px solid #0e1522;border-radius:12px;padding:6px 10px;font-weight:600;font-size:12px;display:flex;gap:8px;align-items:center}
.bar{--w:160px;--h:10px;width:var(--w);height:var(--h);border-radius:999px;outline:1px solid #1a263d;background:#0a1220;position:relative;overflow:hidden}
.bar>i{position:absolute;left:0;top:0;bottom:0;border-radius:999px;background:linear-gradient(90deg,#69d0ff,#a0ffe6)}
.timer{margin-left:auto}
.name{margin-left:6px;opacity:.85}
.overhead{position:absolute;left:50%;transform:translateX(-50%);display:none;gap:6px;align-items:center;pointer-events:none}
.gauge{width:100px;height:6px;border-radius:999px;outline:1px solid #1a263d;background:#0a1220;overflow:hidden}
.gauge>i{display:block;height:100%;width:0%;background:linear-gradient(90deg,#ffd36e,#ff9b42)}
.statusNote{position:absolute;right:8px;bottom:8px;background:var(--hud-bg);outline:1px solid #0e1522;border-radius:10px;padding:4px 8px;font-size:11px;opacity:.8}
/* 選択UI */
#selectModal{position:absolute;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;padding:16px;z-index:20;overflow:auto}
.selCard{background:#0b0f17;outline:1px solid #152033;border-radius:14px;width:min(92vw,420px);max-height:min(88vh,640px);display:flex;flex-direction:column;padding:16px;gap:10px}
.selCard h2{margin:0 0 4px;font-size:18px}
.selHint{font-size:12px;opacity:.8}
.selSection{margin-top:10px;font-weight:700;font-size:13px;opacity:.95}
.selList{display:grid;grid-template-columns:1fr 1fr;gap:8px;max-height:38vh;overflow:auto}
.selItem{display:flex;gap:8px;align-items:center;background:#0d1828;border:1px solid #22324d;border-radius:10px;padding:8px}
.selItem input{accent-color:#65d3ff}
.countNote{font-size:12px;opacity:.75}
.selFoot{position: sticky; bottom:0; z-index:1;background:linear-gradient(180deg, rgba(11,15,23,0), rgba(11,15,23,0.95) 40%, rgba(11,15,23,0.95));margin:0 -16px -16px; padding:12px 16px 16px; display:grid; grid-template-columns:1fr 1fr; gap:8px}
.selFoot .btn{min-height:44px;font-size:18px}
.scrollArea{overflow:auto;flex:1;min-height:0}
@media (max-height: 720px){ :root{ --stage-h: 650px; } }
@media (max-height: 640px){ .selList{ max-height:34vh; } }
</style>
</head>
<body>
<div id="root">
  <div id="phone">
    <div class="grid">
      <div class="gamewrap">
        <header class="hud">
          <div class="chip">残機 <strong id="lives">3</strong></div>
          <div class="chip">HP <span class="bar"><i id="hpfill" style="width:100%"></i></span> <strong id="hpnum">1000</strong></div>
          <div class="chip name">MOBYOKI</div>
          <div class="chip timer">Time <strong id="time">00:00</strong></div>
        </header>
        <canvas id="game" width="420" height="480" aria-label="Game Canvas"></canvas>
        <div class="statusNote" id="note">Ready</div>
      </div>
      <div class="controls">
        <div class="stickArea" id="stickArea" aria-label="Move Stick">
          <div class="stick"><div class="stickThumb" id="stickThumb"></div></div>
        </div>
        <div class="buttons">
          <button class="btn attack1" id="btnA1" aria-label="攻撃① ■">■</button>
          <button class="btn attack2" id="btnA2" aria-label="攻撃② ▲">▲</button>
          <button class="btn skill1"  id="btnSK" aria-label="スキル① ●">●</button>
          <button class="btn skill2"  id="btnSK2" aria-label="スキル② ◎">◎</button>
          <button class="btn ult"     id="btnULT" aria-label="ULT U">U</button>
          <div class="btn spacer" aria-hidden="true"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- 選択モーダル -->
<div id="selectModal">
  <div class="selCard">
    <h2>バトル設定</h2>
    <div class="selHint">プレイヤーは <b>MOBYOKI固定</b>。味方は最大3、敵は最大10まで選べます。</div>
    <div class="scrollArea">
      <div class="selSection">味方を選ぶ（最大3）</div>
      <div class="selList" id="allyList"></div>
      <div class="countNote" id="allyCount">0 / 3</div>
      <div class="selSection">敵を選ぶ（最大10）</div>
      <div class="selList" id="enemyList"></div>
      <div class="countNote" id="enemyCount">0 / 10</div>
    </div>
    <div class="selFoot">
      <button class="btn" id="btnClear">クリア</button>
      <button class="btn" id="btnStart">スタート</button>
    </div>
  </div>
</div>

<script>
(function(){
'use strict';

/* ===== Utils ===== */
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const now=()=>performance.now();
const rectsOverlap=(a,b)=> Math.abs(a.x-b.x)*2 < (a.w+b.w) && Math.abs(a.y-b.y)*2 < (a.h+b.h);

/* ===== Assets ===== */
class Assets{
  constructor(){ this.images=new Map(); this.missing=new Set(); }
  load(srcs){ return Promise.all(srcs.map(src=>new Promise((resolve)=>{ const img=new Image(); img.onload=()=>{ this.images.set(src,img); resolve(); }; img.onerror=()=>{ console.warn('Image load failed:',src); this.missing.add(src); resolve(); }; img.src=src; }))); }
  img(n){ return this.images.get(n); }
  has(n){ return this.images.has(n) && !this.missing.has(n); }
}

/* ===== Input ===== */
class Input{
  constructor(){
    this.left=0; this.right=0; this.jump=false;
    this.btn={a1:false,a2:false,skill:false,skill2:false,ult:false};
    this.prev={a1:false,a2:false,skill:false,skill2:false,ult:false};
    this.edge={a1:false,a2:false,skill:false,skill2:false,ult:false};
    this.hold={skill:false,ult:false};
    this._initKeyboard(); this._initTouch();
  }
  _initKeyboard(){
    addEventListener('keydown',(e)=>{
      const k=e.key;
      if(k==='ArrowLeft'||k==='a'||k==='A') this.left=1;
      if(k==='ArrowRight'||k==='d'||k==='D') this.right=1;
      if(k===' '||k==='w'||k==='W'||k==='ArrowUp') this.jump=true;
      if(k==='j'||k==='J'){ if(!this.btn.a1){ this.btn.a1=true; } }
      if(k==='k'||k==='K'){ if(!this.btn.a2){ this.btn.a2=true; } }
      if(k==='l'||k==='L'){ this.btn.skill=true; this.hold.skill=true; }
      if(k==='o'||k==='O'){ this.btn.skill2=true; }
      if(k==='u'||k==='U'){ this.btn.ult=true; this.hold.ult=true; }
    },{passive:false});
    addEventListener('keyup',(e)=>{
      const k=e.key;
      if(k==='ArrowLeft'||k==='a'||k==='A') this.left=(this.right?1:0);
      if(k==='ArrowRight'||k==='d'||k==='D') this.right=(this.left?1:0);
      if(k==='j'||k==='J') this.btn.a1=false;
      if(k==='k'||k==='K') this.btn.a2=false;
      if(k==='l'||k==='L'){ this.edge.skill=true; this.btn.skill=false; this.hold.skill=false; }
      if(k==='o'||k==='O'){ this.btn.skill2=false; }
      if(k==='u'||k==='U'){ this.edge.ult=true; this.btn.ult=false; this.hold.ult=false; }
    },{passive:false});
  }
  _initTouch(){
    const stickArea=document.getElementById('stickArea');
    const thumb=document.getElementById('stickThumb');
    let stickId=-1, origin=null;
    const updateStick=t=>{
      if(!origin) return;
      const dx=t.clientX-origin.x, dy=t.clientY-origin.y;
      const rMax=40, len=Math.hypot(dx,dy);
      const nx=(len>rMax? dx/len*rMax:dx);
      const ny=(len>rMax? dy/len*rMax:dy);
      thumb.style.left=`calc(50% + ${nx}px)`; thumb.style.top=`calc(50% + ${ny}px)`;
      this.left =(nx<-8)?1:0; this.right=(nx>8)?1:0;
    };
    const onStart=e=>{
      for(const t of e.changedTouches){
        const r=stickArea.getBoundingClientRect();
        if(t.clientX>=r.left&&t.clientX<=r.right&&t.clientY>=r.top&&t.clientY<=r.bottom){
          stickId=t.identifier; origin={x:r.left+r.width/2,y:r.top+r.height/2}; updateStick(t);
        }
      }
    };
    const onMove=e=>{ for(const t of e.changedTouches){ if(t.identifier===stickId) updateStick(t); } };
    const onEnd =e=>{
      for(const t of e.changedTouches){
        if(t.identifier===stickId){ stickId=-1; origin=null; thumb.style.left='50%'; thumb.style.top='50%'; this.left=0; this.right=0; }
      }
    };
    stickArea.addEventListener('touchstart',e=>{e.preventDefault();onStart(e);},{passive:false});
    stickArea.addEventListener('touchmove', e=>{e.preventDefault();onMove(e); },{passive:false});
    stickArea.addEventListener('touchend', e=>{e.preventDefault();onEnd(e); },{passive:false});
    stickArea.addEventListener('touchcancel',e=>{e.preventDefault();onEnd(e);},{passive:false});
    const bind=(id,onDown,onUp)=>{
      const el=document.getElementById(id);
      el.addEventListener('pointerdown',e=>{e.preventDefault(); onDown(); el.setPointerCapture?.(e.pointerId);});
      el.addEventListener('pointerup',  e=>{e.preventDefault(); onUp();   el.releasePointerCapture?.(e.pointerId);});
      el.addEventListener('pointercancel',()=>{ onUp(); });
      el.addEventListener('touchstart',e=>{e.preventDefault();onDown();},{passive:false});
      el.addEventListener('touchend',  e=>{e.preventDefault();onUp();},{passive:false});
    };
    bind('btnA1', ()=>{ this.btn.a1=true; }, ()=>{ this.btn.a1=false; });
    bind('btnA2', ()=>{ this.btn.a2=true; }, ()=>{ this.btn.a2=false; });
    bind('btnSK', ()=>{ this.btn.skill=true; this.hold.skill=true; }, ()=>{ this.edge.skill=true; this.btn.skill=false; this.hold.skill=false; });
    bind('btnSK2', ()=>{ this.btn.skill2=true; }, ()=>{ this.btn.skill2=false; });
    bind('btnULT', ()=>{ this.btn.ult=true; this.hold.ult=true; }, ()=>{ this.edge.ult=true; this.btn.ult=false; this.hold.ult=false; });
  }
  beginFrame(){
    this.edge.a1 = this.btn.a1 && !this.prev.a1;
    this.edge.a2 = this.btn.a2 && !this.prev.a2;
    this.prev.a1=this.btn.a1; this.prev.a2=this.btn.a2; this.prev.skill=this.btn.skill; this.prev.skill2=this.btn.skill2; this.prev.ult=this.btn.ult;
  }
  consumeJump(){ const j=this.jump; this.jump=false; return j; }
}

/* ===== World / Physics ===== */
const GRAV=2000, MOVE=260, JUMP_V=760, MAX_FALL=1200;
const GROUND_TOP_Y=360, FOOT_PAD=2;

/* ===== Effects ===== */
class Effects{
  constructor(){ this.sparks=[]; this.shakeT=0; this.shakeAmp=0; this.hitstop=0; }
  addSpark(x,y,strong=false){ this.sparks.push({x,y,t:0,life:0.18,strong}); if(strong){ this.shake(0.14,8); this.hitstop=Math.max(this.hitstop,0.08); } else { this.shake(0.08,4); this.hitstop=Math.max(this.hitstop,0.05); } if(navigator.vibrate) navigator.vibrate(strong?18:10); }
  shake(dur,amp){ this.shakeT=Math.max(this.shakeT,dur); this.shakeAmp=Math.max(this.shakeAmp,amp); }
  getCamOffset(){ if(this.shakeT>0){ const a=this.shakeAmp*this.shakeT; return {x:(Math.random()*2-1)*a,y:(Math.random()*2-1)*a*0.6}; } return {x:0,y:0}; }
  update(dt){ if(this.hitstop>0)this.hitstop=Math.max(0,this.hitstop-dt); if(this.shakeT>0)this.shakeT=Math.max(0,this.shakeT-dt); for(const s of this.sparks){ s.t+=dt; } this.sparks=this.sparks.filter(s=>s.t<s.life); }
  draw(ctx,world){
    for(const s of this.sparks){
      const p=s.t/s.life; const w=s.strong?2:1;
      ctx.save(); ctx.translate(s.x-world.camX, s.y-world.camY); ctx.globalAlpha=1-p; ctx.strokeStyle="#fff"; ctx.lineWidth=w;
      ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(0,6); ctx.stroke();
      ctx.restore();
    }
  }
}

/* ===== Base ===== */
class CharacterBase{
  constructor(w,h,team='enemy'){ this.w=w; this.h=h; this.team=team; this.x=0; this.y=0; this.vx=0; this.vy=0; this.face=1; this.onGround=false; this.state='idle'; this.animT=0; this.hp=100; this.maxhp=100; this.dead=false; this.deathT=0; this.invulnT=0; this.spinAngle=0; this.spinSpeed=0; this.fade=1; this.hurtT=0; this.maxHurt=0.22; this.superArmor=false; }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.6, h:this.h*0.8}; }
  hurt(amount, dir, opts={}, effects){
    if(this.invulnT>0||this.dead) return false;
    const activeSA = this.superArmor || false;
    const kbMul = activeSA ? (opts.ignoreSA?1:0.12) : (opts.kbMul??1);
    const kbuMul= activeSA ? (opts.ignoreSA?1:0.10) : (opts.kbuMul??1);
    this.hp=Math.max(0,this.hp-amount);
    const baseKb = 140 + amount*12;
    const baseKbu = (opts.lift? 360 : (amount>=15? 300 : 210));
    this.vx = clamp(dir * baseKb * kbMul, -360, 360);
    this.vy = - clamp(baseKbu * kbuMul, 0, 520);
    this.x += dir * 3; this.face = -dir;
    this.state='hurt'; this.hurtT=0; this.animT=0; this.invulnT=0.25;
    effects?.addSpark(this.x, this.y-10, amount>=40);
    if(this.hp<=0){ this.dead=true; this.vx = dir * 520; this.vy = -520; this.spinSpeed = 18; this.deathT = 0; this.fade = 1; }
    return true;
  }
  updatePhysics(dt, world){
    this.vy = Math.min(this.vy + GRAV*dt, MAX_FALL);
    this.x += this.vx*dt; this.y += this.vy*dt;
    // 壁
    const leftWall = 20, rightWall = world.levelW - 20;
    if(this.x - this.w/2 < leftWall){ this.x = leftWall + this.w/2; this.vx = Math.max(0,this.vx); }
    if(this.x + this.w/2 > rightWall){ this.x = rightWall - this.w/2; this.vx = Math.min(0,this.vx); }
    // 地面
    const top=Math.floor(GROUND_TOP_Y);
    if(this.y + this.h/2 >= top + FOOT_PAD){ this.y = top - this.h/2 + FOOT_PAD; this.vy=0; this.onGround=true; }
    else this.onGround=false;
    if(this.invulnT>0) this.invulnT=Math.max(0,this.invulnT-dt);
    if(this.state==='hurt'){ this.hurtT+=dt; if(this.onGround || this.hurtT>=this.maxHurt){ this.state='idle'; } }
    if(this.dead){ this.deathT += dt; this.spinAngle += this.spinSpeed*dt; this.fade = clamp(1 - this.deathT/1.2, 0, 1); }
  }
  drawHPBar(ctx,world){
    const w=36, h=4, x=this.x-world.camX, y=this.y-world.camY - this.h/2 - 10;
    const ratio=Math.max(0,this.hp/this.maxhp);
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle='rgba(10,18,32,.7)'; ctx.fillRect(-w/2,-h/2,w,h);
    ctx.strokeStyle='#1a263d'; ctx.lineWidth=1; ctx.strokeRect(-w/2,-h/2,w,h);
    ctx.fillStyle=this.team==='ally'?'#a7f3d0':(this.team==='player'?'#7dd3fc':'#fda4af');
    ctx.fillRect(-w/2+1,-h/2+1,(w-2)*ratio,h-2);
    ctx.restore();
  }
}

/* ===== Projectiles ===== */
class Projectile{
  constructor(world,x,y,dir,img,power=10, owner=null){ this.world=world; this.x=x; this.y=y; this.dir=dir; this.vx=160*dir; this.vy=0; this.img=img; this.power=power; this.life=3.2; this.dead=false; this.w=40; this.h=28; this.owner=owner; this.ignoreSA=false; }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.9, h:this.h*0.9}; }
  update(dt){ if(this.dead) return; this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt; if(this.life<=0) this.dead=true; }
  draw(ctx){ if(this.dead||!this.img) return; const img=this.img; const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.save(); ctx.translate(this.x-this.world.camX,this.y-this.world.camY); if(this.dir<0) ctx.scale(-1,1); ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h)); ctx.restore(); }
}
class EnergyBall extends Projectile{
  constructor(world,x,y,dir,img,basePower=20,chargeSec=0, incrementPerTenth=3, owner=null){
    super(world,x,y,dir,img,basePower,owner);
    this.chargeSec = clamp(chargeSec,0,3.0);
    this.power = basePower + Math.floor(this.chargeSec / 0.1) * incrementPerTenth;
    const sizeMul = 0.6 + 0.8*(this.chargeSec/3);
    this.w = Math.round(56*sizeMul); this.h = Math.round(56*sizeMul);
    this.vx = (260 + 100*sizeMul) * dir;
    this.life = 2.0 + 0.6*sizeMul;
  }
}

/* ===== Player ===== */
class Player extends CharacterBase{
  constructor(assets, world, effects){
    super(56,64,'player');
    this.assets=assets; this.world=world; this.effects=effects;
    this.x=100; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD;
    this.hp=1000; this.maxhp=1000; this.lives=3;
    this.maxJumps=2; this.jumpsLeft=this.maxJumps;
    this.comboStep=0; this.comboGraceT=0; this.comboGraceMax=0.24;
    this.actionAir=false; this.actionAirVx=0;
    this.skillCDT=0; this.skill2CDT=0; this.ultCDT=0;
    this.saT=0;
    this.holdT={skill:0, ult:0};
    this.frames={
      idle:['M1-1.png'],
      walk:['M1-2.png','M1-3.png','M1-4.png'],
      k1prep:'K1-3.png', k1a:'K1-1.png', k1b:'K1-2.png', k1c:'K1-4.png',
      k2:'K1-5.png',
      spin:['h1.png','h2.png','h3.png','h4.png'],
      y1:'Y1.png', y2:'Y2.png', y3:'Y3.png', y4:'Y4.png',
      ul1:'UL1.PNG', ul2:'UL2.PNG', ul3:'UL3.png'
    };
    this.overhead=this._createOverheadGauge();
    document.querySelector('.gamewrap').appendChild(this.overhead.root);
  }
  _getFramePath(key,i=0){ const v=this.frames[key]; return Array.isArray(v)? v[Math.max(0,Math.min(v.length-1,i))] : v; }
  _imgByKey(key,i=0){ return this.world.assets.img(this._getFramePath(key,i)); }
  _createOverheadGauge(){ const root=document.createElement('div'); root.className='overhead'; const g=document.createElement('div'); g.className='gauge'; const i=document.createElement('i'); g.appendChild(i); const label=document.createElement('span'); label.style.fontSize='10px'; label.style.color='#b8c7e3'; root.appendChild(g); root.appendChild(label); return {root, gauge:g, fill:i, label}; }
  _posOverhead(){ const w=this.world, headY=this.y-this.h/2-10; this.overhead.root.style.left=((this.x-w.camX)*w.screenScaleX)+'px'; this.overhead.root.style.bottom=(w.gameH-(headY-w.camY))*w.screenScaleY+'px'; }
  _showGauge(show, text='', ratio=0){ this.overhead.root.style.display=show?'flex':'none'; this.overhead.label.textContent=text; this.overhead.fill.style.width=((ratio*100)|0)+'%'; }
  currentHitbox(){
    if(!(this.state==='atk'||this.state==='skill'||this.state==='skill2'||this.state==='ult') || !this._actionSeq) return null;
    const cur=this._actionSeq[this._actionIndex]; if(!cur) return null;
    const base = {power:cur.power||0, dir:this.face, lift:cur.lift||0, kbMul:cur.kbMul||1.8, kbuMul:cur.kbuMul||1.5, ignoreSA:cur.ignoreSA||false};
    if(this.state==='skill' || this.state==='skill2' || this.state==='ult'){
      const W=100,H=70; const x=this.x + this.face*(this.w*0.3); return {x,y:this.y,w:W,h:H,...base};
    }
    if(cur.kind==='hit' || cur.kind==='sp'){
      const w=56, h=44, x=this.x + this.face*(this.w*0.35 + w*0.5), y=this.y - 6; return {x,y,w,h, ...base};
    }
    return null;
  }
  update(dt,input,world,opponents){
    input.beginFrame(); this._posOverhead();
    if(this.saT>0) this.saT=Math.max(0,this.saT-dt);
    if(this.skillCDT>0) this.skillCDT=Math.max(0,this.skillCDT-dt);
    if(this.skill2CDT>0) this.skill2CDT=Math.max(0,this.skill2CDT-dt);
    if(this.ultCDT>0) this.ultCDT=Math.max(0,this.ultCDT-dt);
    const skBtn=document.getElementById('btnSK'); const sk2Btn=document.getElementById('btnSK2'); const ultBtn=document.getElementById('btnULT');
    this.skillCDT>0? skBtn.setAttribute('disabled','') : skBtn.removeAttribute('disabled');
    this.skill2CDT>0? sk2Btn.setAttribute('disabled','') : sk2Btn.removeAttribute('disabled');
    this.ultCDT>0? ultBtn.setAttribute('disabled','') : ultBtn.removeAttribute('disabled');
    if(this.dead){ this.updatePhysics(dt,world); world.updateTimer(dt); return; }
    // 溜め表示
    if(input.hold.skill && this.skillCDT<=0 && this.state!=='skill' && this.state!=='skill2' && this.state!=='ult'){ this.holdT.skill = clamp(this.holdT.skill + dt, 0, 1.0); this._showGauge(true,'● Charge', this.holdT.skill/1.0); }
    else if(input.hold.ult && this.ultCDT<=0 && this.state!=='ult'){ this.holdT.ult = clamp(this.holdT.ult + dt, 0, 3.0); this._showGauge(true,'U Charge', this.holdT.ult/3.0); }
    else this._showGauge(false);
    // リリース
    if(input.edge.skill && this.holdT.skill>0 && this.skillCDT<=0){ const charged = this.holdT.skill>=0.35; this.holdT.skill=0; this._startSpin(charged); return; }
    if(input.btn.skill2 && this.skill2CDT<=0 && this.state!=='skill2'){ this._startSkill2(); return; }
    if(input.edge.ult && this.holdT.ult>0 && this.ultCDT<=0){ const t=this.holdT.ult; this.holdT.ult=0; this._releaseULT(t); return; }
    // 実行中
    if(this.state==='atk'||this.state==='skill'||this.state==='skill2'||this.state==='ult'||this.state==='hurt'){
      const hb=this.currentHitbox();
      if(hb){
        for(const e of opponents){
          if(!e || e.dead || e.invulnT>0) continue;
          if(rectsOverlap({x:hb.x,y:hb.y,w:hb.w,h:hb.h}, e.aabb())){
            const hit = e.hurt(hb.power, hb.dir, {lift:hb.lift, kbMul:hb.kbMul, kbuMul:hb.kbuMul, ignoreSA:hb.ignoreSA||false}, this.effects);
            if(hit && rectsOverlap(this.aabb(), e.aabb())){ e.x = this.x + hb.dir * (this.w*0.55); }
          }
        }
      }
      this._updateAction(dt,world);
      world.updateTimer(dt);
      return;
    }
    // 通常移動
    let ax=0; if(input.left){ ax-=MOVE; this.face=-1; } if(input.right){ ax+=MOVE; this.face=1; }
    this.vx = ax!==0 ? (ax>0?MOVE:-MOVE) : 0;
    if(input.consumeJump() && this.jumpsLeft>0){ this.vy=-JUMP_V; this.onGround=false; this.jumpsLeft--; }
    // ULT溜め中は移動可
    this.updatePhysics(dt,world);
    if(this.onGround) this.jumpsLeft=this.maxJumps;
    if(!this.onGround) this.state='jump'; else this.state = Math.abs(this.vx)>1? 'run':'idle';
    this.animT += dt;
    // 攻撃
    if(input.edge.a1){ this._startA1(); return; }
    if(input.edge.a2){ this._startA2(); return; }
    world.updateTimer(dt);
  }
  _startA1(){
    this.state='atk'; this.animT=0; this.comboStep=(this.comboStep%3)+1;
    const seq=[ {kind:'prep',dur:0.06,frame:'k1prep',dx:0,power:0} ];
    let frame='k1a', power=10, dx=18;
    if(this.comboStep===2){ frame='k1b'; power=14; dx=22; }
    else if(this.comboStep===3){ frame='k1c'; power=20; dx=26; }
    seq.push({kind:'hit',dur:0.18,frame,dx,power, kbMul:1.05, kbuMul:1.05});
    this._actionSeq=seq; this._actionIndex=0; this._actionTime=0;
  }
  _startA2(){
    this.state='atk'; this.animT=0;
    this._actionSeq=[
      {kind:'hit',dur:0.18,frame:'k2',dx:22,power:16, kbMul:1.1, kbuMul:1.1},
      {kind:'hit',dur:0.22,frame:'k1c',dx:24,power:34, kbMul:1.2, kbuMul:1.2}
    ];
    this._actionIndex=0; this._actionTime=0;
  }
  _startSpin(charged){
    this.state='skill'; this.animT=0; const rounds=charged?4:2, power=charged?42:26;
    const kbm = charged?2.0:1.7, kbum = charged?1.6:1.4;
    const frames=this.frames.spin; const seq=[];
    for(let r=0;r<rounds;r++){ for(let i=0;i<frames.length;i++){ const p = power*(i===1?1:0.6); const lift=(i===1?1:0);
      seq.push({kind:'sp',dur:0.06,frame:frames[i],dx:0,power:p,lift, kbMul:kbm, kbuMul:kbum});
    }}
    this._actionSeq=seq; this._actionIndex=0; this._actionTime=0; this.skillCDT=5.0;
  }
  _startSkill2(){
    if(this.skill2CDT>0) return;
    this.state='skill2'; this.animT=0; this.skill2CDT=10.0;
    this._skill2T=0; this._shots=0; this._shotAcc=0; this.superArmor=true; // 常時SA
    this._kemList=[];
    this._actionSeq=[
      {kind:'pose',dur:0.20,frame:'y1'},
      {kind:'pose',dur:0.20,frame:'y2'},
      {kind:'pose',dur:0.20,frame:'y3'},
      {kind:'emit',dur:1.00,frame:'y4'}
    ];
    this._actionIndex=0; this._actionTime=0;
  }
  _skill2Emit(dt){
    const img=this.world.assets.img('UL3.png');
    this._shotAcc += dt;
    const interval=0.10;
    while(this._shots<10 && this._shotAcc>=interval){
      this._shotAcc-=interval;
      const dir = this.face;
      const angle = (Math.random()*0.6-0.3) + (dir>0? 0 : Math.PI);
      const spd = 240 + Math.random()*80;
      const px = this.x + Math.cos(angle)*20;
      const py = this.y - 10 + Math.sin(angle)*8;
      const p = new Projectile(this.world, px, py, Math.cos(angle)>=0? 1:-1, img, 80, this);
      p.vx = Math.cos(angle)*spd; p.vy = Math.sin(angle)*spd*0.25; p.w=28; p.h=20; p.life=0.6;
      (this.world._skillBullets||(this.world._skillBullets=[])).push(p);
      this._kemList.push(p);
      this._shots++;
      this.effects.shake(0.06,3);
    }
  }
  _releaseULT(chargeSec){
    if(this.ultCDT>0) return;
    this.state='ult'; this.animT=0; this.ultCDT=30.0;
    this._actionSeq=[ {kind:'pose',dur:0.10,frame:'ul2'}, {kind:'post',dur:0.20,frame:'ul2'} ];
    this._actionIndex=0; this._actionTime=0;
    const img=this.world.assets.img(this.frames.ul3);
    const ox=this.face*30, oy=-12;
    const big = new EnergyBall(this.world, this.x+ox, this.y+oy, this.face, img, 60, chargeSec, 6, this);
    big.w = Math.max(big.w, 88); big.h=Math.max(big.h, 88);
    big.vx *= 1.1; big.life += 0.3; big.power += 40; big.ignoreSA = true;
    (this.world._skillBullets||(this.world._skillBullets=[])).push(big);
    this.effects.addSpark(this.x+ox, this.y-14, true);
  }
  _updateAction(dt,world){
    if(this._actionSeq){ const cur=this._actionSeq[this._actionIndex]; if(cur && cur.dx){ this.x += this.face * cur.dx * dt * 12; } }
    if(this.state==='skill2'){ const cur=this._actionSeq[this._actionIndex]; if(cur && cur.kind==='emit'){ this._skill2Emit(dt); } }
    this.updatePhysics(dt,world);
    if(this._actionSeq){ this._actionTime+=dt; const cur=this._actionSeq[this._actionIndex]; if(cur && this._actionTime>=cur.dur){ this._actionIndex++; this._actionTime=0; if(this._actionIndex>=this._actionSeq.length){ if(this.state==='skill2'){ this.superArmor=false; } this.state='idle'; this._actionSeq=null; } } }
    this.animT+=dt;
  }
  hurt(amount,dir,opts,effects){
    if(this.state==='skill2'){ opts = {...(opts||{}), kbMul:0.08, kbuMul:0.08}; }
    const hit = CharacterBase.prototype.hurt.call(this,amount,dir,opts,effects);
    if(hit){
      const fill=document.getElementById('hpfill'); document.getElementById('hpnum').textContent=this.hp; fill.style.width=Math.max(0,Math.min(100,(this.hp/this.maxhp)*100))+'%';
      if(this.state==='hurt' && this._kemList && this._kemList.length){ for(const p of this._kemList){ p.dead=true; } this._kemList.length=0; }
      this._actionSeq = null; this._actionIndex = 0; this._actionTime = 0; this.comboStep = 0; this.comboGraceT = 0;
      this.jumpsLeft=this.maxJumps;
    }
    return hit;
  }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY);
    if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let img=null;
    if(this.state==='idle'){ img=this._imgByKey('idle',0); }
    else if(this.state==='run'){ const i=Math.floor(this.animT*10)%this.frames.walk.length; img=this._imgByKey('walk',i); }
    else if(this.state==='jump'){ img=this._imgByKey('walk',1); }
    else if((this.state==='atk'||this.state==='skill'||this.state==='skill2'||this.state==='ult') && this._actionSeq){
      const cur=this._actionSeq[this._actionIndex]; const key=cur.frame; img=this.world.assets.img(this.frames[key]?this._getFramePath(key,0):key);
    } else img=this._imgByKey('idle',0);
    if(img){ const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h)); }
    // ULT溜めプレビュー
    if(this.state!=='ult' && this.ultCDT<=0 && this.holdT.ult>0){
      const ul2=this.world.assets.img(this.frames.ul2) || this.world.assets.img(this.frames.ul1);
      const t=this.holdT.ult; const mul = 0.6 + 0.4*(t/3);
      const hh=64*mul, ww=64*mul; const oxh = this.face*28, oyh=-18;
      if(ul2){ ctx.save(); ctx.translate(oxh, oyh); if(this.face<0) ctx.scale(-1,1); ctx.globalAlpha=0.95; ctx.drawImage(ul2, Math.round(-ww/2), Math.round(-hh/2), Math.round(ww), Math.round(hh)); ctx.restore(); }
    }
    ctx.restore();
  }
}

/* ===== Enemies/Allies（team対応） ===== */
/* 既存の各クラス：コンストラクタにteamを追加。updateは「ターゲット1体」を受け取る */
class WaruMOB extends CharacterBase{
  constructor(world,effects,assets,x=520,team='enemy'){ super(52,60,team); this.world=world; this.effects=effects; this.assets=assets; this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1; this.maxhp=100; this.hp=100; this.cool=0; this._seq=null; this._idx=0; this._t=0; this.projectiles=[]; }
  imgByKey(key){ const a=this.assets; const map={ idle:'teki1.png', walk1:'teki1.png', walk2:'teki2.png', prep1:'teki1.png', prep2:'teki3.png' }; return a.img(map[key]||'teki1.png'); }
  addBullet(){ const img=this.assets.img('teki7.png'); const ox=this.face*28; const oy=-8; this.projectiles.push(new Projectile(this.world,this.x+ox,this.y+oy,this.face,img,10,this)); }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.6, h:this.h*0.85}; }
  update(dt,target){
    if(this.dead){ this.updatePhysics(dt,this.world); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    for(const p of this.projectiles) p.update(dt); this.projectiles=this.projectiles.filter(p=>!p.dead);
    if(this.state==='atk'){
      this.updatePhysics(dt,this.world); if(this._seq){ this._t+=dt; const cur=this._seq[this._idx];
        if(cur && this._t>=cur.dur){ this._idx++; this._t=0; if(this._idx===2){ this.addBullet(); }
          if(this._idx>=this._seq.length){ this._seq=null; this.state='idle'; } } }
      this.animT+=dt; return;
    }
    const dx=target.x - this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1;
    if(this.cool<=0 && adx<=220){
      this._seq=[ {kind:'pose',dur:0.18,key:'prep1'}, {kind:'pose',dur:0.22,key:'prep2'} ];
      this.cool=1.6; this.state='atk'; this._idx=0; this._t=0; this.vx=0; this.updatePhysics(dt,this.world); this.animT+=dt; return;
    }
    const walk=80;
    if(adx>160){ this.vx = (dx>0? walk : -walk); } else this.vx=0;
    this.updatePhysics(dt,this.world);
    this.state = !this.onGround ? 'jump' : (Math.abs(this.vx)>1?'run':'idle'); this.animT+=dt;
  }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY); if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let img=null;
    if(this.state==='atk' && this._seq){ const cur=this._seq[this._idx]; img=this.imgByKey(cur.key||'prep2'); }
    else if(this.state==='run'){ const f=Math.floor(this.animT*6)%2; img=this.imgByKey(f? 'walk1':'walk2'); }
    else { img=this.imgByKey('idle'); }
    const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h));
    ctx.restore(); this.drawHPBar(ctx,world);
    for(const p of this.projectiles) p.draw(ctx);
  }
}

class IceRobo extends CharacterBase{
  constructor(world,effects,assets,x=900,team='enemy'){ super(64,70,team); this.world=world; this.effects=effects; this.assets=assets; this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1; this.maxhp=1200; this.hp=1200; this.cool=0; this.recoverT=0; this.modeJump=false; this.modeSwapT=0; this._seq=null; this._idx=0; this._t=0; this.chargeT=0; this.energyOrbs=[]; }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.65, h:this.h*0.9}; }
  img(key){ const map={ idle:'I1.png', walk1:'I1.png', walk2:'I2.png', jump1:'I1.png', jump2:'I2.png', jump3:'I3.png', charge:'I4.png', release:'I5.png', dashPrep:'I6.png', dashAtk:'I7.png', orb:'I8.png' }; return this.assets.img(map[key]||'I1.png'); }
  addEnergyBall(chargeSec){ const img=this.img('orb'); const ox=this.face*30, oy=-10; this.energyOrbs.push(new EnergyBall(this.world,this.x+ox,this.y+oy,this.face,img,20,chargeSec,1,this)); }
  update(dt, target){
    if(this.dead){ this.updatePhysics(dt,this.world); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    if(this.recoverT>0){ this.recoverT=Math.max(0,this.recoverT-dt); }
    for(const p of this.energyOrbs) p.update(dt); this.energyOrbs=this.energyOrbs.filter(p=>!p.dead);

    if(this.state==='charge'){
      this.superArmor = true; this.vx = 0; this.updatePhysics(dt,this.world);
      this._t += dt; this.chargeT = Math.min(2.0, this.chargeT + dt); this.animT += dt;
      const adx = Math.abs(target.x - this.x);
      if(adx < 180 && this.chargeT > 0.25){ this.releaseEnergy(); }
      else if(this.chargeT >= 2.0){ this.releaseEnergy(); }
      return;
    }
    if(this.state==='dash'){
      this.updatePhysics(dt,this.world); this._t += dt;
      if(this._t>=0.35){ this.state='idle'; this.superArmor=false; this.vx=0; this.cool=2.2; }
      this.animT += dt; return;
    }
    if(this.state==='atk' || this.state==='recover'){ this.updatePhysics(dt,this.world); this.animT += dt; if(this.state==='recover' && this.recoverT<=0){ this.state='idle'; } return; }
    if(this.state==='hurt'){ this.updatePhysics(dt,this.world); if(this.onGround) this.state='idle'; this.animT += dt; return; }

    const dx = target.x - this.x; const adx = Math.abs(dx); this.face = dx>=0? 1 : -1;
    this.modeSwapT -= dt; if(this.modeSwapT<=0 && this.onGround){ this.modeSwapT = 2.5 + Math.random()*2.0; this.modeJump = !this.modeJump; }
    const desireCharge = (adx>=160 && adx<=520);
    if(this.cool<=0 && this.recoverT<=0 && desireCharge){ if(this.onGround || Math.random()<0.25){ this.state='charge'; this._t=0; this.chargeT=0; this.vx=0; this.superArmor=true; this.cool=3.2; return; } }
    if(this.cool<=0 && this.recoverT<=0 && adx<260){ this.state='atk'; this.superArmor=true; this.vx=0; this._seq=[{key:'dashPrep', dur:0.28},{key:'dashAtk', dur:0.35}]; this._idx=0; this._t=0; this.animT=0; this.cool=2.6; return; }
    const walk=80, run=MOVE; if(adx>140){ const sp = this.modeJump? run : walk; this.vx = (dx>0? sp : -sp); if(this.modeJump && this.onGround){ this.vy = -JUMP_V*0.8; } } else { this.vx = 0; }
    this.updatePhysics(dt,this.world);
    this.state = !this.onGround ? 'jump' : (Math.abs(this.vx)>1?'run':'idle'); this.animT += dt;
  }
  releaseEnergy(){ this.addEnergyBall(this.chargeT); this.state='recover'; this.recoverT=0.8; this.superArmor=false; }
  draw(ctx,world){
    if(this.state==='atk' && this._seq){ this._t+=1/60; const cur=this._seq[this._idx]; if(cur){ cur._t=(cur._t||0)+1/60; if(cur._t>=cur.dur){ this._idx++; if(this._idx>=this._seq.length){ this.state='dash'; this._t=0; this.vx = (this.face>0? 520 : -520); this._seq=null; } } } }
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY); if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let img=null;
    if(this.state==='charge'){ img=this.img('charge'); }
    else if(this.state==='dash'){ img=this.img('dashAtk'); }
    else if(this.state==='atk' && this._seq){ const cur=this._seq[this._idx]; img=this.img(cur.key||'dashPrep'); }
    else if(this.state==='recover'){ img=this.img('release'); }
    else if(this.state==='run'){ const f=Math.floor(this.animT*6)%2; img=this.img(f? 'walk1':'walk2'); }
    else if(this.state==='jump'){ const f=Math.floor(this.animT*8)%3; img=this.img(['jump1','jump2','jump3'][f]); }
    else { img=this.img('idle'); }
    const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h));
    ctx.restore(); this.drawHPBar(ctx,world);
    for(const p of this.energyOrbs) p.draw(ctx);
  }
}

class IceRoboMini extends CharacterBase{
  constructor(world,effects,assets,x=1200,team='enemy'){ super(40,44,team); this.world=world; this.effects=effects; this.assets=assets; this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1; this.maxhp=50; this.hp=50; this.cool=0; this.state='idle'; this.animT=0; this.hopT=0; this.superArmor=false; }
  img(key){ const map={ idle:'IC.png', move:'IC2.png', atk1:'IC3.png', sp:'IC4.png' }; return this.assets.img(map[key]||'IC.png'); }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.65, h:this.h*0.9}; }
  update(dt, target){
    if(this.dead){ this.updatePhysics(dt,this.world); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    if(this.state==='sp'){
      this.superArmor=true; this.hopT+=dt; const period=0.24, bounces=5;
      const bi=Math.floor(this.hopT/period); const dir = (bi%2===0)? this.face : -this.face;
      this.vx = dir * 240; if(this.onGround) this.vy = -JUMP_V*0.45;
      this.updatePhysics(dt,this.world);
      if(this.hopT>=period*bounces){ this.state='idle'; this.vx=0; this.superArmor=false; this.hopT=0; this.cool=1.6; }
      this.animT+=dt; return;
    }
    if(this.state==='atk'){
      this.hopT+=dt; const dur=0.32; this.vx = this.face * 140; this.updatePhysics(dt,this.world);
      if(this.hopT>=dur){ this.state='idle'; this.hopT=0; this.vx=0; this.cool=0.9; }
      this.animT+=dt; return;
    }
    const dx=target.x-this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1;
    this.vx = (dx>0? 70 : -70); this.hopT+=dt;
    if(this.onGround && this.hopT>0.35){ this.vy=-JUMP_V*0.35; this.hopT=0; }
    if(this.cool<=0){
      if(adx<120 && Math.random()<0.7){ this.state='atk'; this.hopT=0; this.animT=0; }
      else if(adx<220 && Math.random()<0.35){ this.state='sp'; this.hopT=0; this.animT=0; }
    }
    this.updatePhysics(dt,this.world);
    this.state = (this.state==='idle'||this.state==='run') ? (this.onGround? 'run':'jump') : this.state; this.animT+=dt;
  }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY); if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let img=null; if(this.state==='sp') img=this.img('sp'); else if(this.state==='atk'){ img=this.hopT<0.16? this.img('idle'): this.img('atk1'); } else if(!this.onGround) img=this.img('move'); else img=this.img('move');
    const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h));
    ctx.restore(); this.drawHPBar(ctx,world);
  }
}

class Kozou extends CharacterBase{
  constructor(world,effects,assets,x=1400,team='enemy'){ super(50,58,team); this.world=world; this.effects=effects; this.assets=assets; this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1; this.maxhp=100; this.hp=100; this.cool=0; this.state='idle'; this.animT=0; this.projectiles=[]; this.guard=false; this.guardHits=0; this._thrown=false; }
  img(key){ const map={ idle:'SL.png', w1:'SL2.png', w2:'SL3.png', prep:'SL4.png', throw:'SL5.png', guard:'SL6.png', counter:'SL7.png', stone:'SL8.png'}; return this.assets.img(map[key]||'SL.png'); }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.65, h:this.h*0.9}; }
  update(dt,target){
    if(this.dead){ this.updatePhysics(dt,this.world); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    for(const p of this.projectiles) p.update(dt); this.projectiles=this.projectiles.filter(p=>!p.dead);
    if(this.state==='counter'){ this.updatePhysics(dt,this.world); this.animT+=dt; if(this.animT>=0.28){ this.state='idle'; this.vx=0; this.cool=1.2; this.guard=false; this.guardHits=0; } return; }
    if(this.state==='throw'){ this.updatePhysics(dt,this.world); this.animT+=dt; if(this.animT>0.22 && !this._thrown){ this._thrown=true; const img=this.img('stone'); const ox=this.face*14, oy=-18; this.projectiles.push(new Projectile(this.world, this.x+ox, this.y+oy, this.face, img, 5, this)); } if(this.animT>0.4){ this.state='idle'; this.vx=0; this.cool=1.4; this._thrown=false; } return; }
    if(this.guard){ this.vx=0; this.updatePhysics(dt,this.world); this.animT+=dt; const dx=target.x-this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1; if(adx<120){ this.vx = (dx>0? -80 : 80); } return; }
    const dx=target.x-this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1;
    if(adx>140){ this.vx = (dx>0? 70 : -70); } else this.vx=0;
    if(this.cool<=0){
      if(adx>120 && Math.random()<0.5){ this.state='throw'; this.animT=0; this.vx=0; }
      else if(Math.random()<0.35){ this.guard=true; this.state='idle'; this.animT=0; this.vx=0; }
    }
    this.updatePhysics(dt,this.world);
    this.state = this.onGround ? (Math.abs(this.vx)>1?'run':'idle') : 'jump'; this.animT+=dt;
  }
  hurt(amount, dir, opts={}, effects){
    if(this.guard){ amount = Math.ceil(amount*0.5); this.guardHits = Math.min(3, this.guardHits+1); if(this.guardHits>=3 && this.state!=='counter'){ this.state='counter'; this.animT=0; this.vx=0; } }
    return super.hurt(amount, dir, opts, effects);
  }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY); if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let img=null; if(this.state==='throw'){ img=this.animT<0.2? this.img('prep'): this.img('throw'); } else if(this.state==='counter'){ img=this.img('counter'); } else if(this.guard){ img=this.img('guard'); } else if(this.state==='run'){ const f=Math.floor(this.animT*6)%2; img=this.img(f?'w1':'w2'); } else { img=this.img('idle'); }
    const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h));
    ctx.restore(); this.drawHPBar(ctx,world);
    for(const p of this.projectiles) p.draw(ctx);
  }
}

class MOBGiant extends CharacterBase{
  constructor(world,effects,assets,x=1650,team='enemy'){
    super(100,120,team);
    this.world=world; this.effects=effects; this.assets=assets;
    this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1;
    this.maxhp=2200; this.hp=2200; this.superArmor=false; this.cool=0; this.recoverT=0; this.modeJump=false; this.modeSwapT=0; this.chargeT=0; this.energyOrbs=[]; this.postLagT=0; this.lowFreqBias=0.0;
  }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.68, h:this.h*0.95}; }
  img(key){ const map={ idle:'P1.png', w1:'P1.png', w2:'P2.png', j1:'P1.png', j2:'P2.png', j3:'P3.png', dashPrep:'P4.png', dashAtk:'P5.png', charge:'P6.png', release:'P7.png', orb:'P10.png' }; return this.assets.img(map[key]||'P1.png'); }
  hurt(amount, dir, opts={}, effects){ const activeSA = this.superArmor || Math.random()<0.5; const o={...opts}; if(!o.ignoreSA && activeSA){ o.kbMul=0.12; o.kbuMul=0.1; } return super.hurt(amount, dir, o, effects); }
  addEnergyPair(chargeSec){ const img=this.img('orb'); const ox=this.face*34, oy=-16; this.energyOrbs.push(new EnergyBall(this.world,this.x+ox,this.y+oy, this.face,  img, 30, chargeSec, 2, this)); this.energyOrbs.push(new EnergyBall(this.world,this.x-ox,this.y+oy,-this.face, img, 30, chargeSec, 2, this)); }
  update(dt, target){
    if(this.dead){ this.updatePhysics(dt,this.world); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    if(this.recoverT>0){ this.recoverT=Math.max(0,this.recoverT-dt); }
    if(this.postLagT>0){ this.postLagT=Math.max(0,this.postLagT-dt); }
    for(const p of this.energyOrbs) p.update(dt); this.energyOrbs=this.energyOrbs.filter(p=>!p.dead);
    if(this.state==='charge'){
      this.superArmor = true; this.vx=0; this.updatePhysics(dt,this.world);
      this.chargeT=Math.min(2.0, this.chargeT + dt);
      const adx=Math.abs(target.x - this.x);
      if(adx<200 && this.chargeT>0.25){ this.releaseEnergy(); }
      else if(this.chargeT>=2.0){ this.releaseEnergy(); }
      this.animT+=dt; return;
    }
    if(this.state==='dash'){
      this.updatePhysics(dt,this.world); this.animT+=dt;
      if(this.animT>=0.38){ this.state='idle'; this.superArmor=false; this.vx=0; this.cool=2.4 + this.lowFreqBias; }
      return;
    }
    if(this.state==='post'){ this.updatePhysics(dt,this.world); this.animT+=dt; if(this.postLagT<=0){ this.state='idle'; } return; }
    if(this.state==='hurt'){ this.updatePhysics(dt,this.world); if(this.onGround) this.state='idle'; this.animT+=dt; return; }
    const dx = target.x - this.x; const adx = Math.abs(dx); this.face = dx>=0?1:-1;
    this.modeSwapT -= dt; if(this.modeSwapT<=0 && this.onGround){ this.modeSwapT = 2.2 + Math.random()*1.6; this.modeJump = !this.modeJump; }
    this.lowFreqBias = clamp(this.lowFreqBias + (Math.random()*0.2-0.1), 0.0, 1.4);
    const desireCharge = (adx>=220 && adx<=560);
    if(this.cool<=0 && this.recoverT<=0 && this.postLagT<=0 && desireCharge){ this.state='charge'; this.chargeT=0; this.superArmor=true; this.vx=0; this.cool = 3.2 + this.lowFreqBias; this.animT=0; return; }
    if(this.cool<=0 && this.recoverT<=0 && adx<240){ this.state='dash'; this.animT=0; this.superArmor=true; this.vx = (this.face>0? 540 : -540); this.cool = 2.8 + this.lowFreqBias; return; }
    const walk=70, run=MOVE;
    if(adx>140){ const sp = this.modeJump? run : walk; this.vx = (dx>0? sp : -sp); if(this.modeJump && this.onGround){ this.vy = -JUMP_V*0.95; } }
    else { this.vx=0; }
    this.updatePhysics(dt,this.world);
    this.state = !this.onGround ? 'jump' : (Math.abs(this.vx)>1? 'run':'idle'); this.animT+=dt;
  }
  releaseEnergy(){ this.addEnergyPair(this.chargeT); this.state='post'; this.postLagT=0.9; this.superArmor=false; this.animT=0; }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY); if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let img=null;
    if(this.state==='charge'){ img=this.img('charge'); }
    else if(this.state==='dash'){ img=this.img('dashAtk'); }
    else if(this.state==='post'){ img=this.img('release'); }
    else if(this.state==='run'){ const f=Math.floor(this.animT*6)%2; img=this.img(f?'w1':'w2'); }
    else if(this.state==='jump'){ const f=Math.floor(this.animT*8)%3; img=this.img(['j1','j2','j3'][f]); }
    else { img=this.img('idle'); }
    const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h));
    ctx.restore(); this.drawHPBar(ctx,world);
    for(const p of this.energyOrbs) p.draw(ctx);
  }
}

/* MOBスクリュー */
class MOBSCREW extends CharacterBase{
  constructor(world,effects,assets,x=520,team='enemy'){
    super(60,68,team); this.world=world; this.effects=effects; this.assets=assets; this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1; this.maxhp=1800; this.hp=1800; this.superArmor=false; this.cool=0; this._seq=null; this._idx=0; this._t=0;
  }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.66, h:this.h*0.9}; }
  img(key){ const map={ idle:'B1.png', w1:'B2.png', w2:'B3.png', j1:'B3.png', j2:'B4.png', a1:'B5.png', a1b:'B6.png', a2:'B7.png', sk1prep:'B8.png', sk1a:'B9.png', sk1b:'B10.png', sk1c:'B11.png', ult1:'B12.png', ult2:'B13.png', ult3:'B14.png' }; return this.assets.img(map[key]||'B1.png'); }
  update(dt, target){
    if(this.dead){ this.updatePhysics(dt,this.world); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    if(this.state==='atk' && this._seq){
      this._t+=dt; const cur=this._seq[this._idx]; if(this._t>=cur.dur){ this._idx++; this._t=0; if(this._idx>=this._seq.length){ this._seq=null; this.state='idle'; this.superArmor=false; } }
      this.x += this.face * (cur.fx||0) * dt;
      this.updatePhysics(dt,this.world); this.animT+=dt; return;
    }
    const dx=target.x - this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1;
    this.superArmor = Math.random()<0.3;
    if(this.cool<=0 && adx<160){
      this._seq=[
        {img:'a1', dur:0.16, dmg:30, kb:1.0, fx:120},
        {img:'a1b', dur:0.16, dmg:30, kb:1.0, fx:120},
        {img:'a2', dur:0.20, dmg:35, kb:1.2, fx:140}
      ]; this._idx=0; this._t=0; this.state='atk'; this.animT=0; this.cool=1.4; return;
    }
    if(this.cool<=0 && adx>=160 && adx<=360){
      this._seq=[
        {img:'sk1prep', dur:0.5, fx:0},
        {img:'sk1a', dur:0.18, dmg:50, kb:0.9, fx:460},
        {img:'sk1b', dur:0.18, dmg:20, kb:1.0, fx:360},
        {img:'sk1c', dur:0.22, dmg:50, kb:1.4, fx:260}
      ]; this.superArmor=true; this._idx=0; this._t=0; this.state='atk'; this.animT=0; this.cool=5.0; return;
    }
    if(this.cool<=0 && adx<=280 && Math.random()<0.25){
      this._seq=[
        {img:'ult1', dur:0.5, fx:0},
        {img:'ult2', dur:0.24, fx:560, dmg:0},
        {img:'ult3', dur:0.26, fx:0, dmg:120, kb:2.0}
      ]; this.superArmor=true; this._idx=0; this._t=0; this.state='atk'; this.animT=0; this.cool=20.0; return;
    }
    const sp = 70; if(adx>140){ this.vx = (dx>0? sp : -sp); } else this.vx = 0;
    if(adx>180 && this.onGround && Math.random()<0.1){ this.vy = -JUMP_V*0.8; }
    this.updatePhysics(dt,this.world);
    this.state = !this.onGround ? 'jump' : (Math.abs(this.vx)>1?'run':'idle'); this.animT+=dt;
  }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY); if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let img=null;
    if(this.state==='atk' && this._seq){ const cur=this._seq[this._idx]; img=this.img(cur.img); }
    else if(this.state==='run'){ const f=Math.floor(this.animT*6)%2; img=this.img(f?'w1':'w2'); }
    else if(this.state==='jump'){ const f=Math.floor(this.animT*8)%2; img=this.img(f? 'j2':'j1'); }
    else { img=this.img('idle'); }
    const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h));
    ctx.restore(); this.drawHPBar(ctx,world);
  }
}

/* ガブキング */
class GABKING extends CharacterBase{
  constructor(world,effects,assets,x=520,team='enemy'){ super(84,96,team); this.world=world; this.effects=effects; this.assets=assets; this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1; this.maxhp=2500; this.hp=2500; this.superArmor=false; this.cool=0; this._seq=null; this._idx=0; this._t=0; }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.7, h:this.h*0.95}; }
  img(key){ const map={ idle:'t1.png', w1:'t2.png', w2:'t3.png', a1:'t4.png', a2:'t5.png', prep:'t6.png', t7:'t7.png', t8:'t8.png', t9:'t9.png', t10:'t10.png', t11:'t11.png' }; return this.assets.img(map[key]||'t1.png'); }
  update(dt, target){
    if(this.dead){ this.updatePhysics(dt,this.world); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    if(this.state==='atk' && this._seq){
      this._t+=dt; const cur=this._seq[this._idx]; if(this._t>=cur.dur){ this._idx++; this._t=0; if(this._idx>=this._seq.length){ this._seq=null; this.state='idle'; this.superArmor=false; } }
      this.x += this.face * (cur.fx||0) * dt;
      this.updatePhysics(dt,this.world); this.animT+=dt; return;
    }
    const dx=target.x - this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1;
    this.superArmor = Math.random()<0.5;
    if(this.cool<=0 && adx<180){
      this._seq=[ {img:'a1', dur:0.12, dmg:30, kb:1.2, fx:240}, {img:'a2', dur:0.16, dmg:30, kb:1.2, fx:260} ];
      this._idx=0; this._t=0; this.state='atk'; this.animT=0; this.cool=1.6; return;
    }
    if(this.cool<=0 && adx<=360 && Math.random()<0.45){
      this._seq=[ {img:'prep', dur:0.5, fx:0}, {img:'prep', dur:0.26, dmg:70, kb:1.6, fx:620} ];
      this.superArmor=true; this._idx=0; this._t=0; this.state='atk'; this.animT=0; this.cool=6.0; return;
    }
    if(this.cool<=0 && adx<=420 && Math.random()<0.4){
      this._seq=[ {img:'prep', dur:0.5, fx:0}, {img:'prep', dur:0.26, dmg:0, fx:620}, {img:'t8', dur:0.18, dmg:100, kb:1.4, fx:160, lift:1} ];
      this.superArmor=true; this._idx=0; this._t=0; this.state='atk'; this.animT=0; this.cool=8.0; return;
    }
    if(this.cool<=0 && adx<=380 && Math.random()<0.35){
      this._seq=[ {img:'t10', dur:0.5, fx:0}, {img:'t7', dur:0.18, dmg:50, kb:1.0, fx:0}, {img:'t11', dur:0.22, dmg:130, kb:2.2, fx:0} ];
      this.superArmor=true; this._idx=0; this._t=0; this.state='atk'; this.animT=0; this.cool=18.0; return;
    }
    const sp=70; if(adx>160){ this.vx=(dx>0? sp:-sp); } else this.vx=0;
    this.updatePhysics(dt,this.world);
    this.state = !this.onGround? 'jump' : (Math.abs(this.vx)>1? 'run':'idle'); this.animT+=dt;
  }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY); if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let img=null;
    if(this.state==='atk' && this._seq){ const cur=this._seq[this._idx]; img=this.img(cur.img); }
    else if(this.state==='run'){ const f=Math.floor(this.animT*6)%2; img=this.img(f?'w1':'w2'); }
    else { img=this.img('idle'); }
    const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h));
    ctx.restore(); this.drawHPBar(ctx,world);
  }
}

/* ===== World ===== */
class World{
  constructor(assets, canvas, effects){
    this.assets=assets; this.effects=effects; this.canvas=canvas;
    this.ctx=canvas.getContext('2d',{alpha:false});
    this.ctx.imageSmoothingEnabled=false;
    this.gameW=canvas.width; this.gameH=canvas.height; this.camX=0; this.camY=0; this.time=0; this._timerAcc=0;
    const r=this.canvas.getBoundingClientRect(); this.screenScaleX=r.width/this.gameW; this.screenScaleY=r.height/this.gameH;
    this.bgImg = this.assets.has('MOBA.png') ? this.assets.img('MOBA.png') : (this.assets.has('back1.png')? this.assets.img('back1.png'):null);
    if(this.bgImg){ this.bgScale = this.gameH / this.bgImg.height; this.bgDW = this.bgImg.width*this.bgScale; this.bgDH = this.bgImg.height*this.bgScale; }
    this.bgSpeed=1.0;
    this.levelW = 2200;
  }
  resize(){ const r=this.canvas.getBoundingClientRect(); this.screenScaleX=r.width/this.gameW; this.screenScaleY=r.height/this.gameH; }
  updateCam(p){ const offs=this.effects.getCamOffset(); const target=p.x - this.gameW*0.35 + offs.x; this.camX=clamp(target, 0, Math.max(0,this.levelW-this.gameW)); this.camY=offs.y; }
  updateTimer(dt){
    this._timerAcc+=dt; if(this._timerAcc>=0.2){ this.time+=this._timerAcc; this._timerAcc=0;
      const t=Math.floor(this.time); const mm=String(Math.floor(t/60)).padStart(2,'0'); const ss=String(t%60).padStart(2,'0'); document.getElementById('time').textContent=`${mm}:${ss}`; }
  }
  draw(player, allies, enemies){
    const ctx=this.ctx; ctx.clearRect(0,0,this.gameW,this.gameH);
    if(this.bgImg){
      const w=Math.round(this.bgDW), h=Math.round(this.bgDH); const step=Math.max(1, w - 1);
      const startX = Math.floor((this.camX*this.bgSpeed - this.gameW*0.2)/step)*step;
      const endX = this.camX*this.bgSpeed + this.gameW*1.2 + w;
      for(let x=startX; x<=endX; x+=step){ ctx.drawImage(this.bgImg, 0,0,this.bgImg.width,this.bgImg.height, Math.round(x - this.camX*this.bgSpeed), 0, w, h); }
    } else { ctx.fillStyle='#0a0f18'; ctx.fillRect(0,0,this.gameW,this.gameH); }
    ctx.fillStyle='#0b0f17'; const yTop=Math.floor(GROUND_TOP_Y); ctx.fillRect(0,yTop-1,this.gameW,1);
    if(this._skillBullets){ for(const p of this._skillBullets) p.draw(ctx); }
    for(const a of allies) a.draw(ctx,this);
    for(const e of enemies) e.draw(ctx,this);
    player.draw(ctx,this);
    this.effects.draw(ctx,this);
  }
}

/* ===== Game Loop ===== */
class Game{
  constructor(){
    this.assets=new Assets(); this.canvas=document.getElementById('game'); this.input=new Input(); this.effects=new Effects();
    this.world=null; this.player=null; this.allies=[]; this.enemies=[]; this.lastT=0;
    addEventListener('resize',()=>this.world?.resize());
  }
  async start(roster){
    const imgs=[
      'MOBA.png','back1.png',
      'M1-1.png','M1-2.png','M1-3.png','M1-4.png',
      'K1-1.png','K1-2.png','K1-3.png','K1-4.png','K1-5.png',
      'h1.png','h2.png','h3.png','h4.png',
      'J.png',
      'teki1.png','teki2.png','teki3.png','teki7.png',
      'I1.png','I2.png','I3.png','I4.png','I5.png','I6.png','I7.png','I8.png',
      'IC.png','IC2.png','IC3.png','IC4.png',
      'SL.png','SL2.png','SL3.png','SL4.png','SL5.png','SL6.png','SL7.png','SL8.png',
      'P1.png','P2.png','P3.png','P4.png','P5.png','P6.png','P7.png','P10.png',
      'Y1.png','Y2.png','Y3.png','Y4.png',
      'UL1.PNG','UL2.PNG','UL3.png',
      'B1.png','B2.png','B3.png','B4.png','B5.png','B6.png','B7.png','B8.png','B9.png','B10.png','B11.png','B12.png','B13.png','B14.png',
      't1.png','t2.png','t3.png','t4.png','t5.png','t6.png','t7.png','t8.png','t9.png','t10.png','t11.png'
    ];
    await this.assets.load(imgs);
    this.world=new World(this.assets,this.canvas,this.effects);
    this.player=new Player(this.assets,this.world,this.effects);
    this.player.x=140; this.player.y=Math.floor(GROUND_TOP_Y)-this.player.h/2+FOOT_PAD;

    // Ally / Enemy spawn（team分け）
    this.allies = roster.allies.map((name,i)=> this._instantiate(name, 300 + i*80, 'ally'));
    this.enemies = roster.enemies.map((name,i)=> this._instantiate(name, 520 + (i*140), 'enemy'));

    this.lastT=now();
    requestAnimationFrame(()=>this.loop());
  }
  _instantiate(name, x, team){
    const w=this.world, e=this.effects, a=this.assets;
    switch(name){
      case 'WaruMOB': return new WaruMOB(w,e,a,x,team);
      case 'IceRobo': return new IceRobo(w,e,a,x,team);
      case 'IceRoboMini': return new IceRoboMini(w,e,a,x,team);
      case 'Kozou': return new Kozou(w,e,a,x,team);
      case 'MOBGiant': return new MOBGiant(w,e,a,x,team);
      case 'MOBSCREW': return new MOBSCREW(w,e,a,x,team);
      case 'GABKING': return new GABKING(w,e,a,x,team);
      default: return new IceRoboMini(w,e,a,x,team);
    }
  }
  _nearest(from, candidates){
    let best=null, bd=1e9;
    for(const c of candidates){ if(!c || c.dead) continue; const d=Math.abs(c.x - from.x); if(d<bd){ bd=d; best=c; } }
    return best;
  }
  _updateHPUI(){ const fill=document.getElementById('hpfill'); document.getElementById('hpnum').textContent=this.player.hp; fill.style.width=Math.max(0,Math.min(100,(this.player.hp/this.player.maxhp)*100))+'%'; }
  loop(){
    const t=now(); let dt=(t-this.lastT)/1000; if(dt>0.05) dt=0.05; this.lastT=t;
    if(this.effects.hitstop>0){ this.effects.update(dt); this.world.updateCam(this.player); this.world.draw(this.player,this.allies,this.enemies); requestAnimationFrame(()=>this.loop()); return; }

    // ターゲット決定
    const enemyTargetPool = [this.player, ...this.allies];
    const allyTargetPool = this.enemies;

    // Player更新（相手は敵のみ）
    this.player.update(dt,this.input,this.world,this.enemies);

    // Allies更新（最も近い敵を狙う。敵がいなければプレイヤーに追従）
    for(const a of this.allies){
      const tgt = this._nearest(a, allyTargetPool) || this.player;
      a.update(dt, tgt);
    }

    // Enemies更新（プレイヤー＋味方の中から最寄り）
    for(const e of this.enemies){
      const tgt = this._nearest(e, enemyTargetPool) || this.player;
      e.update(dt, tgt);
    }

    // 弾の衝突：すべての弾を集約
    const allChars=[this.player, ...this.allies, ...this.enemies];

    // 1) 敵側の弾 → プレイヤー/味方
    for(const ch of this.enemies){
      if(ch.projectiles){ for(const p of ch.projectiles){ if(p.dead) continue; for(const tgt of allChars){ if(!tgt || tgt.dead || tgt.team===ch.team) continue; if(rectsOverlap(p.aabb(), tgt.aabb())){ p.dead=true; const hit=tgt.hurt(p.power, p.dir, {lift:0.2,kbMul:0.8,kbuMul:0.8}, this.effects); if(hit && tgt===this.player) this._updateHPUI(); } } } }
      if(ch.energyOrbs){ for(const p of ch.energyOrbs){ if(p.dead) continue; for(const tgt of allChars){ if(!tgt || tgt.dead || tgt.team===ch.team) continue; if(rectsOverlap(p.aabb(), tgt.aabb())){ p.dead=true; const hit=tgt.hurt(p.power, p.dir, {lift:0.25,kbMul:0.85,kbuMul:0.85}, this.effects); if(hit && tgt===this.player) this._updateHPUI(); } } } }
    }

    // 2) 味方側の弾 → 敵
    for(const ch of this.allies){
      if(ch.projectiles){ for(const p of ch.projectiles){ if(p.dead) continue; for(const tgt of this.enemies){ if(!tgt || tgt.dead) continue; if(rectsOverlap(p.aabb(), tgt.aabb())){ p.dead=true; tgt.hurt(p.power, p.dir, {lift:0.2,kbMul:0.9,kbuMul:0.9}, this.effects); } } } }
      if(ch.energyOrbs){ for(const p of ch.energyOrbs){ if(p.dead) continue; for(const tgt of this.enemies){ if(!tgt || tgt.dead) continue; if(rectsOverlap(p.aabb(), tgt.aabb())){ p.dead=true; tgt.hurt(p.power, p.dir, {lift:0.25,kbMul:0.9,kbuMul:0.9}, this.effects); } } } }
    }

    // 3) プレイヤー（スキル弾） → 敵のみ
    if(this.world._skillBullets){
      for(const p of this.world._skillBullets){
        p.update(dt);
        for(const e of this.enemies){
          if(!p.dead && !e.dead && rectsOverlap(p.aabb(), e.aabb())){
            p.dead=true;
            const dir = (e.x>=p.x)? 1 : -1;
            const hit=e.hurt(p.power, dir, {lift:0.3,kbMul:1.2,kbuMul:1.2, ignoreSA:p.ignoreSA||false}, this.effects);
            if(hit) this.effects.addSpark(e.x, e.y-10, p.power>=60);
          }
        }
      }
      this.world._skillBullets = this.world._skillBullets.filter(p=>!p.dead && p.life>0);
    }

    // 体当たり押し出し（敵↔プレイヤーのみ軽く）
    for(const e of this.enemies){
      if(e.dead || this.player.dead) continue;
      const a=this.player.aabb(), b=e.aabb();
      if(!rectsOverlap(a,b)) continue;
      const dx = (this.player.x - e.x), dy=(this.player.y - e.y);
      const overlapX = (a.w + b.w)/2 - Math.abs(dx);
      const overlapY = (a.h + b.h)/2 - Math.abs(dy);
      if(overlapY < overlapX){ const dirY = dy>=0? 1 : -1; this.player.y += dirY * overlapY * 0.9; e.y -= dirY * overlapY * 0.1; if(dirY<0){ this.player.vy = Math.max(this.player.vy, 0); } else { this.player.vy = Math.min(this.player.vy, 0); } }
      else { const dirX = dx>=0? 1 : -1; this.player.x += dirX * overlapX * 0.6; e.x -= dirX * overlapX * 0.4; this.player.vx += dirX * 20; e.vx -= dirX * 20; }
    }

    // remove dead fades
    this.enemies=this.enemies.filter(e=>!(e.dead && e.fade<=0));
    this.allies=this.allies.filter(a=>!(a.dead && a.fade<=0));

    this.effects.update(dt); this.world.updateCam(this.player); this.world.updateTimer(dt); this.world.draw(this.player,this.allies,this.enemies);
    requestAnimationFrame(()=>this.loop());
  }
}

/* ===== Selection UI ===== */
const ALLY_CATALOG = [
  {id:'WaruMOB', label:'WaruMOB'},
  {id:'IceRobo', label:'IceRobo'},
  {id:'IceRoboMini', label:'IceRoboMini'},
  {id:'Kozou', label:'Kozou'},
  {id:'MOBGiant', label:'MOBGiant'},
  {id:'MOBSCREW', label:'MOBスクリュー'},
  {id:'GABKING', label:'MOBガブキング'}
];
const ENEMY_CATALOG = [
  {id:'WaruMOB', label:'WaruMOB'},
  {id:'IceRobo', label:'IceRobo'},
  {id:'IceRoboMini', label:'IceRoboMini'},
  {id:'Kozou', label:'Kozou'},
  {id:'MOBGiant', label:'MOBGiant'},
  {id:'MOBSCREW', label:'MOBスクリュー'},
  {id:'GABKING', label:'MOBガブキング'}
];

function buildSelectList(el, catalog, max, countEl){
  el.innerHTML='';
  for(const c of catalog){
    const div=document.createElement('label'); div.className='selItem';
    const input=document.createElement('input'); input.type='checkbox'; input.value=c.id;
    const span=document.createElement('span'); span.textContent=c.label;
    div.appendChild(input); div.appendChild(span); el.appendChild(div);
  }
  const update=()=>{
    const chosen=[...el.querySelectorAll('input:checked')];
    if(chosen.length>max){ chosen[chosen.length-1].checked=false; }
    const n=[...el.querySelectorAll('input:checked')].length;
    countEl.textContent=`${n} / ${max}`;
  };
  el.addEventListener('change',update);
  update();
}
function getSelections(allyEl, enemyEl){
  const allies=[...allyEl.querySelectorAll('input:checked')].map(i=>i.value).slice(0,3);
  const enemies=[...enemyEl.querySelectorAll('input:checked')].map(i=>i.value).slice(0,10);
  return {allies,enemies};
}
const allyList=document.getElementById('allyList');
const enemyList=document.getElementById('enemyList');
const allyCount=document.getElementById('allyCount');
const enemyCount=document.getElementById('enemyCount');
buildSelectList(allyList, ALLY_CATALOG, 3, allyCount);
buildSelectList(enemyList, ENEMY_CATALOG, 10, enemyCount);
document.getElementById('btnClear').addEventListener('click',()=>{
  allyList.querySelectorAll('input').forEach(i=>i.checked=false);
  enemyList.querySelectorAll('input').forEach(i=>i.checked=false);
  allyCount.textContent='0 / 3'; enemyCount.textContent='0 / 10';
});
document.getElementById('btnStart').addEventListener('click',async ()=>{
  const roster=getSelections(allyList, enemyList);
  document.getElementById('selectModal').style.display='none';
  const game=new Game();
  await game.start(roster);
});

})();
</script>
</body>
</html>
