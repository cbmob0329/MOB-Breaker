<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, maximum-scale=1" />
<title>MOB Side Action – Rev31 (Team Select 3 Allies / 10 Enemies)</title>
<meta name="theme-color" content="#0b0c10" />
<style>
:root{ --stage-w:420px; --stage-h:720px; --hud-bg:#0b0f17cc; --fg:#e9eef7; --grid-gap:10px; }
html,body{height:100%;margin:0;padding:0;overflow:hidden;background:#0a0d13;color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;overscroll-behavior:none;-webkit-user-select:none;-webkit-touch-callout:none;user-select:none}
*{box-sizing:border-box}
#root{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:10px}
#phone{width:var(--stage-w);height:var(--stage-h);position:relative;overflow:hidden;background:#060910;border:1px solid #0f1726;border-radius:20px;box-shadow:0 12px 48px rgba(0,0,0,.55);touch-action:none;margin:0 auto}
.grid{position:absolute;inset:0;display:grid;grid-template-rows: 1fr 220px;gap:var(--grid-gap);padding:var(--grid-gap)}
.gamewrap{position:relative;border-radius:14px;overflow:hidden;background:#05070c;outline:1px solid #0e1522}
canvas#game{display:block;width:100%;height:100%}
.controls{position:relative;border-radius:14px;background:var(--hud-bg);outline:1px solid #0e1522;backdrop-filter: blur(6px);padding:12px;display:grid;grid-template-columns: 1fr 1fr;gap:12px}
.stickArea{position:relative;border-radius:12px;background:#0a121f;outline:1px solid #152033;display:grid;place-items:center;touch-action:none}
.stick{width:120px;height:120px;border-radius:50%;background:#0d1828;outline:2px solid #22324d;position:relative}
.stickThumb{width:64px;height:64px;border-radius:50%;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#1a2a45;outline:2px solid #2e4a73;box-shadow:inset 0 0 0 4px #0c1422}

/* ボタン */
.buttons{display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(2,1fr);gap:12px;align-content:stretch;justify-items:stretch}
.btn{border:none;border-radius:14px;background:#0d1828;outline:2px solid #22324d;color:var(--fg);font-size:26px;display:grid;place-items:center;touch-action:none;box-shadow:inset 0 -4px 0 rgba(255,255,255,.04);transition:opacity .15s ease;min-height:64px}
.btn:active{transform:scale(.98)}
.btn[disabled]{opacity:.35;pointer-events:none}
.btn.attack1{background:#112033} /* ■ */
.btn.attack2{background:#1a2436} /* ▲ */
.btn.skill1 {background:#132a22} /* ● */
.btn.skill2 {background:#1f2433} /* ◎ */
.btn.ult    {background:#2b2030} /* U */
.btn.jump   {background:#25202b} /* × */

header.hud{position:absolute;left:0;right:0;top:0;padding:10px 14px;display:flex;gap:10px;align-items:center;z-index:10;pointer-events:none}
.chip{background:var(--hud-bg);outline:1px solid #0e1522;border-radius:12px;padding:6px 10px;font-weight:600;font-size:12px;display:flex;gap:8px;align-items:center}
.bar{--w:160px;--h:10px;width:var(--w);height:var(--h);border-radius:999px;outline:1px solid #1a263d;background:#0a1220;position:relative;overflow:hidden}
.bar>i{position:absolute;left:0;top:0;bottom:0;border-radius:999px;background:linear-gradient(90deg,#ff9a9e,#ff6b6b)}
.timer{margin-left:auto}
.name{margin-left:6px;opacity:.85}
.overhead{position:absolute;left:50%;transform:translateX(-50%);display:none;gap:6px;align-items:center;pointer-events:none}
.gauge{width:96px;height:6px;border-radius:999px;outline:1px solid #1a263d;background:#0a1220;overflow:hidden}
.gauge>i{display:block;height:100%;width:0%;background:linear-gradient(90deg,#69d0ff,#a0ffe6)}
@media (max-height: 720px){ :root{ --stage-h: 650px; } }

/* ===== 選択UI（複数選択） ===== */
#selectModal{position:absolute;inset:0;background:rgba(5,7,12,.85);backdrop-filter: blur(6px);display:flex;align-items:center;justify-content:center;z-index:50}
.selCard{width:92%;max-width:390px;background:#0b0f17;border:1px solid #162033;border-radius:14px;padding:16px;box-shadow:0 8px 32px rgba(0,0,0,.45)}
.selCard h2{margin:0 0 10px;font-size:18px}
.selHint{font-size:12px;opacity:.8;margin-bottom:10px}
.selSection{margin:12px 0 4px;font-weight:700}
.selList{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.selItem{display:flex;gap:6px;align-items:center;font-size:13px;background:#0f1624;border:1px solid #1b2942;border-radius:10px;padding:8px 10px}
.selFoot{display:flex;gap:8px;margin-top:12px}
.selStart{flex:1;border:none;border-radius:12px;padding:12px;background:#224a9a;color:#fff;font-weight:700;box-shadow:inset 0 -3px 0 rgba(0,0,0,.2)}
.selClear{flex:1;border:none;border-radius:12px;padding:12px;background:#394357;color:#fff;font-weight:700}
.countNote{font-size:12px;opacity:.8;margin-top:2px}
</style>
</head>
<body>
<div id="root">
  <div id="phone">
    <div class="grid">
      <div class="gamewrap">
        <header class="hud">
          <div class="chip">残機 <strong id="lives">3</strong></div>
          <div class="chip">HP <span class="bar"><i id="hpfill" style="width:100%"></i></span> <strong id="hpnum">1000</strong></div>
          <div class="chip name">MOBYOKI</div>
          <div class="chip timer">Time <strong id="time">00:00</strong></div>
        </header>
        <canvas id="game" width="420" height="480" aria-label="Game Canvas"></canvas>

        <!-- 選択モーダル -->
        <div id="selectModal">
          <div class="selCard">
            <h2>バトル設定</h2>
            <div class="selHint">プレイヤーは <strong>MOBYOKI</strong> 固定です。味方は最大 <strong>3体</strong>、敵は最大 <strong>10体</strong> まで選択できます。</div>

            <div class="selSection">味方を選ぶ（最大3）</div>
            <div class="selList" id="allyList"></div>
            <div class="countNote" id="allyCount">選択数: 0 / 3</div>

            <div class="selSection">敵を選ぶ（最大10）</div>
            <div class="selList" id="enemyList"></div>
            <div class="countNote" id="enemyCount">選択数: 0 / 10</div>

            <div class="selFoot">
              <button class="selClear" id="clearBtn">クリア</button>
              <button class="selStart" id="startBtn">ゲームスタート</button>
            </div>
          </div>
        </div>
      </div>

      <div class="controls">
        <div class="stickArea" id="stickArea" aria-label="Move Stick">
          <div class="stick"><div class="stickThumb" id="stickThumb"></div></div>
        </div>
        <div class="buttons">
          <button class="btn attack1" id="btnA1"  aria-label="攻撃① ■">■</button>
          <button class="btn attack2" id="btnA2"  aria-label="攻撃② ▲">▲</button>
          <button class="btn skill1"  id="btnSK"  aria-label="スキル① ●">●</button>
          <button class="btn skill2"  id="btnSK2" aria-label="スキル② ◎">◎</button>
          <button class="btn ult"     id="btnULT" aria-label="ULT U">U</button>
          <button class="btn jump"    id="btnJMP" aria-label="ジャンプ ×">×</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
'use strict';
/* ===== Helpers ===== */
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const now=()=>performance.now();

/* チーム */
const TEAM_PLAYER='player', TEAM_ALLY='ally', TEAM_ENEMY='enemy';

/* 近接当たり用：矩形重なり */
const rectsOverlap=(a,b)=> Math.abs(a.x-b.x)*2 < (a.w+b.w) && Math.abs(a.y-b.y)*2 < (a.h+b.h);

/* ターゲット代理：既存AIが player に依存していても、最寄り対象に委譲 */
function makeTargetProxy(getOpponents){
  return {
    get x(){ const t=getOpponents(); return t.x; },
    get y(){ const t=getOpponents(); return t.y; },
    get aabb(){ const t=getOpponents(); return t.aabb.bind(t); },
    aabb(){ const t=getOpponents(); return t.aabb(); },
    get invulnT(){ const t=getOpponents(); return t.invulnT; },
    hurt(amount,dir,opts,effects){ const t=getOpponents(); return t.hurt(amount,dir,opts,effects); }
  };
}

/* ===================== Effects / Assets / Input ===================== */
class Effects{
  constructor(){ this.sparks=[]; this.shakeT=0; this.shakeAmp=0; this.hitstop=0; }
  addSpark(x,y,strong=false){
    this.sparks.push({x,y,t:0,life:0.18,strong});
    if(strong){ this.shake(0.14,8); this.hitstop=Math.max(this.hitstop,0.08); }
    else{ this.shake(0.08,4); this.hitstop=Math.max(this.hitstop,0.05); }
    if(navigator.vibrate) navigator.vibrate(strong?18:10);
  }
  shake(dur,amp){ this.shakeT=Math.max(this.shakeT,dur); this.shakeAmp=Math.max(this.shakeAmp,amp); }
  getCamOffset(){ if(this.shakeT>0){ const a=this.shakeAmp*this.shakeT; return {x:(Math.random()*2-1)*a,y:(Math.random()*2-1)*a*0.6}; } return {x:0,y:0}; }
  update(dt){
    if(this.hitstop>0)this.hitstop=Math.max(0,this.hitstop-dt);
    if(this.shakeT>0)this.shakeT=Math.max(0,this.shakeT-dt);
    for(const s of this.sparks){ s.t+=dt; }
    this.sparks=this.sparks.filter(s=>s.t<s.life);
  }
  draw(ctx,world){
    for(const s of this.sparks){
      const p=s.t/s.life; const w=s.strong?2:1;
      ctx.save(); ctx.translate(s.x-world.camX, s.y-world.camY); ctx.globalAlpha=1-p; ctx.strokeStyle="#fff"; ctx.lineWidth=w;
      ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(0,6); ctx.stroke();
      ctx.restore();
    }
  }
}
class Assets{
  constructor(){ this.images=new Map(); this.missing=new Set(); }
  load(srcs){
    return Promise.all(srcs.map(src=>new Promise((resolve)=>{
      const img=new Image();
      img.onload=()=>{ this.images.set(src,img); resolve(); };
      img.onerror=()=>{ console.warn('Image load failed:',src); this.missing.add(src); resolve(); };
      img.src=src;
    })));
  }
  img(n){ return this.images.get(n); }
  has(n){ return this.images.has(n) && !this.missing.has(n); }
}
class Input{
  constructor(){
    this.left=0; this.right=0; this.jump=false;
    this.btn={a1:false,a2:false,skill:false,skill2:false,ult:false};
    this.prev={a1:false,a2:false,skill:false,skill2:false,ult:false};
    this.edge={a1:false,a2Press:false,skillPress:false,skillRelease:false,skill2:false,ultPress:false,ultRelease:false};
    this.skillCharging=false; this.skillChargeT=0;
    this.ultCharging=false; this.ultChargeT=0;
    this._initKeyboard(); this._initTouch();
  }
  _initKeyboard(){
    addEventListener('keydown',(e)=>{
      const k=e.key;
      if(k==='ArrowLeft'||k==='a'||k==='A') this.left=1;
      if(k==='ArrowRight'||k==='d'||k==='D') this.right=1;
      if(k===' '||k==='w'||k==='W'||k==='ArrowUp'){ this.jump=true; }
      if(k==='j'||k==='J') this.btn.a1=true;
      if(k==='k'||k==='K'){ if(!this.btn.a2){ this.btn.a2=true; this.edge.a2Press=true; } }
      if(k==='l'||k==='L'){ if(!this.btn.skill){ this.btn.skill=true; this.edge.skillPress=true; this.skillCharging=true; this.skillChargeT=0; } }
      if(k==='o'||k==='O'){ this.edge.skill2=true; this.btn.skill2=true; }
      if(k==='u'||k==='U'){ if(!this.btn.ult){ this.btn.ult=true; this.edge.ultPress=true; this.ultCharging=true; this.ultChargeT=0; } }
    },{passive:false});
    addEventListener('keyup',(e)=>{
      const k=e.key;
      if(k==='ArrowLeft'||k==='a'||k==='A') this.left=(this.right?1:0);
      if(k==='ArrowRight'||k==='d'||k==='D') this.right=(this.left?1:0);
      if(k==='j'||k==='J') this.btn.a1=false;
      if(k==='k'||k==='K') this.btn.a2=false;
      if(k==='l'||k==='L'){ if(this.btn.skill){ this.btn.skill=false; this.edge.skillRelease=true; this.skillCharging=false; } }
      if(k==='o'||k==='O') this.btn.skill2=false;
      if(k==='u'||k==='U'){ if(this.btn.ult){ this.btn.ult=false; this.ultCharging=false; this.edge.ultRelease=true; } }
    },{passive:false});
  }
  _initTouch(){
    const stickArea=document.getElementById('stickArea');
    const thumb=document.getElementById('stickThumb');
    let stickId=-1, origin=null;
    const updateStick=t=>{
      if(!origin) return;
      const dx=t.clientX-origin.x, dy=t.clientY-origin.y;
      const rMax=40, len=Math.hypot(dx,dy);
      const nx=(len>rMax? dx/len*rMax:dx);
      const ny=(len>rMax? dy/len*rMax:dy);
      thumb.style.left=`calc(50% + ${nx}px)`;
      thumb.style.top =`calc(50% + ${ny}px)`;
      this.left =(nx<-8)?1:0;
      this.right=(nx> 8)?1:0;
    };
    const onStart=e=>{
      for(const t of e.changedTouches){
        const r=stickArea.getBoundingClientRect();
        if(t.clientX>=r.left&&t.clientX<=r.right&&t.clientY>=r.top&&t.clientY<=r.bottom){
          stickId=t.identifier; origin={x:r.left+r.width/2,y:r.top+r.height/2}; updateStick(t);
        }
      }
    };
    const onMove=e=>{ for(const t of e.changedTouches){ if(t.identifier===stickId) updateStick(t); } };
    const onEnd =e=>{
      for(const t of e.changedTouches){
        if(t.identifier===stickId){
          stickId=-1; origin=null; thumb.style.left='50%'; thumb.style.top='50%'; this.left=0; this.right=0;
        }
      }
    };
    stickArea.addEventListener('touchstart',e=>{e.preventDefault();onStart(e);},{passive:false});
    stickArea.addEventListener('touchmove', e=>{e.preventDefault();onMove(e); },{passive:false});
    stickArea.addEventListener('touchend', e=>{e.preventDefault();onEnd(e); },{passive:false});
    stickArea.addEventListener('touchcancel',e=>{e.preventDefault();onEnd(e);},{passive:false});
    const bind=(id,onDown,onUp)=>{
      const el=document.getElementById(id);
      el.addEventListener('pointerdown',e=>{e.preventDefault(); onDown(); el.setPointerCapture?.(e.pointerId);});
      el.addEventListener('pointerup',  e=>{e.preventDefault(); onUp();   el.releasePointerCapture?.(e.pointerId);});
      el.addEventListener('pointercancel',()=>{ onUp(); });
      el.addEventListener('touchstart',e=>{e.preventDefault();onDown();},{passive:false});
      el.addEventListener('touchend',  e=>{e.preventDefault();onUp();},{passive:false});
    };
    bind('btnA1', ()=>{ this.btn.a1=true; }, ()=>{ this.btn.a1=false; });
    bind('btnA2', ()=>{ if(!this.btn.a2){ this.btn.a2=true; this.edge.a2Press=true; } }, ()=>{ this.btn.a2=false; });
    bind('btnSK', ()=>{ if(!this.btn.skill){ this.btn.skill=true; this.edge.skillPress=true; this.skillCharging=true; this.skillChargeT=0; } }, ()=>{ if(this.btn.skill){ this.btn.skill=false; this.edge.skillRelease=true; this.skillCharging=false; } });
    bind('btnSK2', ()=>{ this.edge.skill2=true; this.btn.skill2=true; }, ()=>{ this.btn.skill2=false; });
    bind('btnULT', ()=>{ if(!this.btn.ult){ this.btn.ult=true; this.edge.ultPress=true; this.ultCharging=true; this.ultChargeT=0; } },
                   ()=>{ if(this.btn.ult){ this.btn.ult=false; this.ultCharging=false; this.edge.ultRelease=true; } });
    bind('btnJMP', ()=>{ this.jump=true; }, ()=>{});
  }
  consumeJump(){ const j=this.jump; this.jump=false; return j; }
  beginFrame(){
    this.edge.a1 = this.btn.a1 && !this.prev.a1;
    this.prev.a1=this.btn.a1; this.prev.a2=this.btn.a2; this.prev.skill=this.btn.skill; this.prev.skill2=this.btn.skill2; this.prev.ult=this.btn.ult;
  }
}

/* ===================== Base / Physics ===================== */
const GRAV=2000, MOVE=260, JUMP_V=760, MAX_FALL=1200;
const GROUND_TOP_Y=360, FOOT_PAD=2;

class CharacterBase{
  constructor(w,h){
    this.w=w; this.h=h; this.x=0; this.y=0; this.vx=0; this.vy=0; this.face=1;
    this.onGround=false; this.state='idle'; this.animT=0;
    this.hp=100; this.maxhp=100; this.dead=false; this.deathT=0;
    this.invulnT=0; this.spinAngle=0; this.spinSpeed=0; this.fade=1; this.hurtT=0; this.maxHurt=0.22;
    this.team=TEAM_ENEMY;
  }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.6, h:this.h*0.8}; }
  hurt(amount, dir, opts={}, effects){
    if(this.invulnT>0||this.dead) return false;
    this.hp=Math.max(0,this.hp-amount);
    const kbMul = (opts.kbMul??1), kbuMul=(opts.kbuMul??1);
    const baseKb = 140 + amount*12;
    const baseKbu = opts.lift ? 360 : (amount>=15? 300 : 210);
    this.vx = clamp(dir * baseKb * kbMul, -320, 320);
    this.vy = - clamp(baseKbu * kbuMul, 0, 420);
    this.x += dir * 3; this.face = -dir;
    this.state='hurt'; this.hurtT=0; this.animT=0; this.invulnT=0.35;
    if(effects) effects.addSpark(this.x, this.y-10, amount>=15);
    if(this.hp<=0){
      this.dead=true; this.vx = dir * 520; this.vy = -520; this.spinSpeed = 18; this.deathT = 0; this.fade = 1;
    }
    return true;
  }
  updatePhysics(dt){
    this.vy = Math.min(this.vy + GRAV*dt, MAX_FALL);
    this.x += this.vx*dt; this.y += this.vy*dt;
    const top=Math.floor(GROUND_TOP_Y);
    if(this.y + this.h/2 >= top + FOOT_PAD){ this.y = top - this.h/2 + FOOT_PAD; this.vy=0; this.onGround=true; }
    else this.onGround=false;
    if(this.invulnT>0) this.invulnT=Math.max(0,this.invulnT-dt);
    if(this.state==='hurt'){
      this.hurtT+=dt; if(this.onGround || this.hurtT>=this.maxHurt){ this.state='idle'; }
    }
    if(this.dead){ this.deathT += dt; this.spinAngle += this.spinSpeed*dt; this.fade = clamp(1 - this.deathT/1.2, 0, 1); }
  }
  drawHPBar(ctx,world){
    const w=36, h=4, x=this.x-world.camX, y=this.y-world.camY - this.h/2 - 10;
    const ratio=Math.max(0,this.hp/this.maxhp);
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle='rgba(10,18,32,.7)'; ctx.fillRect(-w/2,-h/2,w,h);
    ctx.strokeStyle='#1a263d'; ctx.lineWidth=1; ctx.strokeRect(-w/2,-h/2,w,h);
    ctx.fillStyle='#7dd3fc'; ctx.fillRect(-w/2+1,-h/2+1,(w-2)*ratio,h-2);
    ctx.restore();
  }
}

/* ===================== Projectiles ===================== */
class Projectile{
  constructor(world,x,y,dir,img,power=10){
    this.world=world; this.x=x; this.y=y; this.dir=dir; this.vx=160*dir; this.vy=0; this.img=img; this.power=power; this.life=3.2; this.dead=false; this.w=40; this.h=28;
    this.kbMul=0.9; this.kbuMul=0.9; this.lift=0.3; this.isUlt=false; this.owner=TEAM_PLAYER;
  }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.9, h:this.h*0.9}; }
  update(dt){
    if(this.dead) return;
    this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt;
    const half=this.w/2;
    if(this.x-half<=0 || this.x+half>=this.world.stageW){ this.dead=true; }
    if(this.life<=0) this.dead=true;
  }
  draw(ctx){
    if(this.dead||!this.img) return; const img=this.img;
    const scale=this.h/img.height, w=img.width*scale, h=this.h;
    ctx.save(); ctx.translate(this.x-this.world.camX,this.y-this.world.camY); if(this.dir<0) ctx.scale(-1,1);
    ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h));
    ctx.restore();
  }
}
class EnergyBall extends Projectile{
  constructor(world,x,y,dir,img,basePower=20,chargeSec=0, incrementPerTenth=1){
    super(world,x,y,dir,img,basePower);
    this.chargeSec = clamp(chargeSec,0,2.0);
    this.power = basePower + Math.floor(this.chargeSec / 0.1) * incrementPerTenth;
    const sizeMul = 1 + 0.55*(this.chargeSec/2);
    this.w = Math.round(48*sizeMul); this.h = Math.round(36*sizeMul);
    this.vx = (210 + 70*(this.chargeSec/2)) * dir;
    this.life = 3.6;
  }
}
class UltBlast extends Projectile{
  constructor(world,x,y,dir,img,chargeSec){
    const t = clamp(chargeSec,0,3.0);
    const base = 80 + Math.floor(t/0.1)*4;
    super(world,x,y,dir,img,base);
    const sizeMul = lerp(0.9, 2.2, t/3);
    this.w = Math.round(68*sizeMul);
    this.h = Math.round(68*sizeMul);
    this.vx = (260 + 90*sizeMul) * dir;
    this.life = 2.0 + 0.45*sizeMul;
    this.kbMul  = 2.2 + 0.35*sizeMul;     /* 超ノックバック */
    this.kbuMul = 2.2 + 0.35*sizeMul;
    this.lift   = 1.25 + 0.45*sizeMul;
    this.isUlt = true;
    this.owner = TEAM_PLAYER;
  }
}
class ShortPulse extends Projectile{
  constructor(world,x,y,dir,img){
    super(world,x,y,dir,img,15);
    this.vx = 260*dir;
    this.life = 0.5;
    this.w = 20; this.h = 14;
    this.owner = TEAM_PLAYER;
  }
}
class GroundSpike extends Projectile{
  constructor(world,x,dir,img){
    super(world,x,Math.floor(GROUND_TOP_Y)-8,dir,img,80);
    this.vx = 0; this.h = 10; this.w = 42; this.life = 1.0; this.riseT=0; this.maxH=90;
    this.owner = TEAM_PLAYER;
  }
  aabb(){ return {x:this.x, y:this.y - this.h/2, w:this.w*0.9, h:this.h}; }
  update(dt){ this.riseT += dt; this.h = Math.min(this.maxH, 10 + this.riseT*160); this.life -= dt; if(this.life<=0) this.dead=true; }
  draw(ctx){
    const img=this.img; if(!img) return;
    const scaleW=this.w/img.width, scaleH=this.h/img.height;
    ctx.save(); ctx.translate(this.x-this.world.camX, Math.floor(GROUND_TOP_Y)-this.world.camY); ctx.scale(1,-1);
    ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-img.width*scaleW/2), 0, Math.round(img.width*scaleW), Math.round(img.height*scaleH));
    ctx.restore();
  }
}

/* ===================== Player ===================== */
class Player extends CharacterBase{
  constructor(assets, world, effects){
    super(56,64);
    this.team=TEAM_PLAYER;
    this.assets=assets; this.world=world; this.effects=effects;
    this.x=100; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD;
    this.hp=1000; this.maxhp=1000; this.lives=3;
    this.maxJumps=2; this.jumpsLeft=this.maxJumps;
    this.comboStep=0; this.comboGraceT=0; this.comboGraceMax=0.24;
    this.bufferA1=false; this.a2LockoutT=0;
    this.skillCDT=0; this.skill2CDT=0; this.ultCDT=0;
    this.saT=0;
    this.isUltCharging=false;
    this.frames={
      idle:['M1-1.png'],
      run:['M1-2.png','M1-3.png','M1-4.png','M1-3.png'],
      k1prep:'K1-3.png', k1a:'K1-1.png', k1b:'K1-2.png', k1c:'K1-4.png',
      k2prep:'K1-3.png', k2:'K1-5.png',
      spin:['h1.png','h2.png','h3.png','h4.png'],
      chaseJump:'J.png',
      y1:'Y1.png', y2:'Y2.png', y3:'Y3.png', y4:'Y4.png',
      ul1:'UL1.PNG', ul2:'UL2.PNG', ul3:'UL3.png'
    };
    this.overhead=this._createOverheadGauge();
    document.querySelector('.gamewrap').appendChild(this.overhead.root);
    this._activeSpikes=null;
  }
  _getFramePath(key, i=0){ const v=this.frames[key]; return Array.isArray(v)? v[Math.max(0,Math.min(v.length-1,i))] : v; }
  _imgByKey(key,i=0){ return this.world.assets.img(this._getFramePath(key,i)); }
  _createOverheadGauge(){ const root=document.createElement('div'); root.className='overhead'; const g=document.createElement('div'); g.className='gauge'; const i=document.createElement('i'); g.appendChild(i); const label=document.createElement('span'); label.style.fontSize='10px'; label.style.color='#b8c7e3'; root.appendChild(g); root.appendChild(label); return {root, gauge:g, fill:i, label}; }
  _posOverhead(){ const w=this.world, headY=this.y-this.h/2-10; this.overhead.root.style.left=((this.x-w.camX)*w.screenScaleX)+'px'; this.overhead.root.style.bottom=(w.gameH-(headY-w.camY))*w.screenScaleY+'px'; }
  _showGauge(show, text='', ratio=0){ this.overhead.root.style.display=show?'flex':'none'; this.overhead.label.textContent=text; this.overhead.fill.style.width=((ratio*100)|0)+'%'; }
  currentHitbox(){ if(!(this.state==='atk'||this.state==='skill'||this.state==='skill2'||this.state==='ult') || !this._actionSeq) return null; const cur=this._actionSeq[this._actionIndex]; if(!cur) return null; if(this.state==='skill' || this.state==='skill2' || this.state==='ult'){ const W=86,H=64; const x=this.x + this.face*(this.w*0.2); return {x, y:this.y, w:W, h:H, power:cur.power||0, dir:this.face, lift:cur.lift||0, kbMul:cur.kbMul||1.6, kbuMul:cur.kbuMul||1.3}; } if(cur.kind==='hit' || cur.kind==='sp'){ const w=52, h=42, x=this.x + this.face*(this.w*0.3 + w*0.5), y=this.y - 6; return {x,y,w,h, power:cur.power||0, dir:this.face, lift:cur.lift||1, kbMul:cur.kbMul||1, kbuMul:cur.kbuMul||1}; } return null; }
  update(dt,input,world,enemies){
    input.beginFrame(); this._posOverhead();
    if(this.saT>0) this.saT=Math.max(0,this.saT-dt);
    if(this.state!=='atk' && this.state!=='skill' && this.state!=='skill2' && this.state!=='ult' && this._actionSeq){ this._actionSeq=null; }
    if(this.a2LockoutT>0) this.a2LockoutT=Math.max(0,this.a2LockoutT-dt);
    const skBtn=document.getElementById('btnSK'); const sk2Btn=document.getElementById('btnSK2'); const ultBtn=document.getElementById('btnULT');
    if(this.skillCDT>0){ this.skillCDT=Math.max(0,this.skillCDT-dt); skBtn.setAttribute('disabled',''); } else skBtn.removeAttribute('disabled');
    if(this.skill2CDT>0){ this.skill2CDT=Math.max(0,this.skill2CDT-dt); sk2Btn.setAttribute('disabled',''); } else sk2Btn.removeAttribute('disabled');
    if(this.ultCDT>0){ this.ultCDT=Math.max(0,this.ultCDT-dt); ultBtn.setAttribute('disabled',''); } else ultBtn.removeAttribute('disabled');
    if(this.dead){ this.updatePhysics(dt); if(this.fade<=0){ this._respawn(world); } world.updateTimer(dt); return; }
    if(input.skillCharging && this.skillCDT<=0){ input.skillChargeT=Math.min(1.0, input.skillChargeT+dt); this._showGauge(true,'● Charge', input.skillChargeT/1.0); this.saT = 0.08; }
    this.isUltCharging = input.ultCharging && this.ultCDT<=0;
    if(this.isUltCharging){ input.ultChargeT = Math.min(3, input.ultChargeT + dt); this._showGauge(true,'U Charge', input.ultChargeT/3); this.saT = 0.12; }
    if(input.edge.skillRelease && input.skillChargeT>0 && this.skillCDT<=0){ this._startSkill1Release(input.skillChargeT); input.skillChargeT=0; input.edge.skillRelease=false; }
    if(input.edge.ultRelease && input.ultChargeT>0 && this.ultCDT<=0){ this._releaseULT(input.ultChargeT); input.ultChargeT=0; input.edge.ultRelease=false; }
    if(this.state==='atk'||this.state==='skill'||this.state==='skill2'||this.state==='ult'){
      const hb=this.currentHitbox();
      if(hb){ for(const e of enemies){ if(!e || e.dead || e.invulnT>0) continue; if(rectsOverlap({x:hb.x,y:hb.y,w:hb.w,h:hb.h}, e.aabb())){ const hit = e.hurt(hb.power, hb.dir, {lift:hb.lift, kbMul:hb.kbMul, kbuMul:hb.kbuMul}, this.effects); if(hit && rectsOverlap(this.aabb(), e.aabb())){ e.x = this.x + hb.dir * (this.w*0.55); } } } }
      this._updateAction(dt,world,input); world.updateTimer(dt); return;
    }
    if(input.edge.a1) this.bufferA1=true;
    if(input.edge.skill2 && this.skill2CDT<=0){ input.edge.skill2=false; this.bufferA1=false; this._startSkill2(); return; }
    if(input.edge.a2Press && this.a2LockoutT<=0){ input.edge.a2Press=false; this.bufferA1=false; this._startA2(); return; }
    if(this.bufferA1 && this.comboStep<3){ this.bufferA1=false; this._startA1(); return; }
    let ax=0; if(input.left){ ax-=MOVE; this.face=-1; } if(input.right){ ax+=MOVE; this.face=1; }
    this.vx = ax!==0 ? (ax>0?MOVE:-MOVE) : 0;
    if(input.consumeJump() && this.jumpsLeft>0){ this.vy=-JUMP_V; this.onGround=false; this.jumpsLeft--; }
    this.updatePhysics(dt);
    if(this.onGround) this.jumpsLeft=this.maxJumps;
    this.state = !this.onGround ? 'jump' : (Math.abs(this.vx)>1?'run':'idle');
    if(!(input.skillCharging||this.isUltCharging)) this._showGauge(false);
    world.updateTimer(dt);
  }
  _startA1(){ this.state='atk'; this.animT=0; this.comboStep=Math.min(this.comboStep+1,3); const seq=[ {kind:'prep',dur:0.08,frame:'k1prep',fx:80,power:0} ]; let frame='k1a', power=6, fx=140; if(this.comboStep===2){ frame='k1b'; power=9; fx=170; } else if(this.comboStep===3){ frame='k1c'; power=12; fx=200; } seq.push({kind:'hit',dur:0.20,frame,fx,power, kbMul:1.0, kbuMul:1.0}); this._actionSeq=seq; this._actionIndex=0; this._actionTime=0; }
  _startA2(){ this.state='atk'; this.animT=0; this._actionSeq=[ {kind:'prep',dur:0.10,frame:'k2prep',fx:90,power:0}, {kind:'hit', dur:0.22,frame:'k2',fx:220,power:18, lift:1.0, kbMul:1.15, kbuMul:1.2, after:'enableChase'} ]; this._actionIndex=0; this._actionTime=0; this.a2LockoutT = 0.35; this._chaseWindowT = 0; this._chaseEnabled=false; this._chaseConsumed=false; }
  _startA2Chase(){ this.state='atk'; this.animT=0; const seq=[ {kind:'pose',dur:0.12,frame:'chaseJump',fx:260,power:0}, {kind:'hit', dur:0.24,frame:'k1c',fx:280,power:50, lift:1.0, kbMul:1.2, kbuMul:1.2, tag:'chaseFinisher'} ]; this._actionSeq=seq; this._actionIndex=0; this._actionTime=0; this._chaseEnabled=false; this._chaseConsumed=true; this.a2LockoutT=0.6; }
  _startSkill1Release(chargeSec){ this.state='skill'; this.animT=0; this.skillCDT=5.0; const t=clamp(chargeSec,0,1.0); const rounds = 2 + Math.floor(t/0.33); const base= 26 + Math.floor(t/0.1)*2; const kbm= 1.6 + 0.1*(rounds-2); const kbum = 1.3 + 0.05*(rounds-2); const frames=this.frames.spin; const seq=[]; for(let r=0;r<rounds;r++){ for(let i=0;i<frames.length;i++){ const pow = base*(i===1?1:0.6); const lift=(i===1?1:0); seq.push({kind:'sp',dur:0.06,frame:frames[i],fx:80,power:pow,lift, kbMul:kbm, kbuMul:kbum}); } } this._actionSeq=seq; this._actionIndex=0; this._actionTime=0; this._showGauge(false); }
  _startSkill2(){ if(this.skill2CDT>0) return; this.state='skill2'; this.animT=0; this.skill2CDT=10.0; this._skill2SAT = 1.6; this._actionSeq=[ {kind:'hit', dur:0.12, frame:'y1', fx:30, power:5},{kind:'hit', dur:0.12, frame:'y2', fx:30, power:5},{kind:'hit', dur:0.12, frame:'y3', fx:30, power:5},{kind:'hit', dur:0.12, frame:'y4', fx:0, power:10},{kind:'emit',dur:1.00, frame:'y4', fx:0, power:0} ]; this._actionIndex=0; this._actionTime=0; const kem=this.world.assets.img('kem.png'); if(kem){ const off=68; const L=new GroundSpike(this.world, this.x - off, -1, kem); const R=new GroundSpike(this.world, this.x + off,  1, kem); (this.world._skillBullets||(this.world._skillBullets=[])).push(L,R); this._activeSpikes=[L,R]; this.effects.shake(0.12,6); } }
  _releaseULT(chargeSec){ if(this.ultCDT>0) return; this.state='ult'; this.animT=0; this._actionSeq=[ {kind:'pose',dur:0.10,frame:'ul2',fx:40},{kind:'post',dur:0.22,frame:'ul2',fx:20} ]; this._actionIndex=0; this._actionTime=0; this.ultCDT=30.0; const img=this.world.assets.img(this.frames.ul3); const ox=this.face*30, oy=-12; const blast=new UltBlast(this.world, this.x+ox, this.y+oy, this.face, img, chargeSec); (this.world._skillBullets||(this.world._skillBullets=[])).push(blast); this.saT=0; this._showGauge(false); this.effects.addSpark(this.x+ox, this.y-14, true); }
  _updateAction(dt,world,input){
    const cur=this._actionSeq?.[this._actionIndex];
    if(this.state==='skill2'){ this._skill2SAT = Math.max(0, this._skill2SAT - dt); this.saT = Math.max(this.saT, 0.08); }
    if(cur?.fx){ this.x += this.face * cur.fx * dt; }
    if(this._actionSeq && this.state==='atk' && cur?.after==='enableChase'){ this._chaseWindowT = (this._chaseWindowT||0) + dt; if(this._chaseWindowT>0.18 && !this._chaseEnabled){ this._chaseEnabled=true; } if(this._chaseEnabled && input.edge.a2Press && !this._chaseConsumed){ input.edge.a2Press=false; this._startA2Chase(); return; } }
    if((this.state==='skill2' && (cur.frame==='y4' || cur.kind==='emit')) || this.state==='ult'){ const ox=Math.sin(performance.now()/25)*2; this._shakeOX = ox; } else this._shakeOX=0;
    this.vx = 0; this.updatePhysics(dt);
    if(this._actionSeq){ this._actionTime+=dt; if(this._actionTime>=cur.dur){ this._actionIndex++; this._actionTime=0; if(this._actionIndex>=this._actionSeq.length){ if(this.state==='atk' && this.comboStep>0){ this.comboGraceT=this.comboGraceMax; if(this.comboStep>=3){ this.comboStep=0; this.bufferA1=false; } } if(this.state==='skill2'){ this._activeSpikes=null; } this.state='idle'; this._actionSeq=null; } } }
    this.animT+=dt;
  }
  _respawn(world){ this.dead=false; this.fade=1; this.spinAngle=0; this.spinSpeed=0; this.state='idle'; this.comboStep=0; this.comboGraceT=0; this.bufferA1=false; this.invulnT=0.6; this.hp=this.maxhp; document.getElementById('hpfill').style.width='100%'; document.getElementById('hpnum').textContent=this.hp; this.x=clamp(world.camX+80, this.w/2, world.stageW-this.w/2); this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.vx=0; this.vy=0; this.jumpsLeft=this.maxJumps; this.saT=0; this._activeSpikes=null; this.isUltCharging=false; }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY);
    if(this.dead){ ctx.globalAlpha=this.fade; ctx.rotate(this.spinAngle); }
    if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let img=null, ox=this._shakeOX||0;
    if(this.state==='idle'){ img=this._imgByKey('idle',0); }
    else if(this.state==='run'){ const speed=Math.abs(this.vx); const rate = lerp(6, 11, clamp(speed/MOVE, 0, 1)); const i=Math.floor(this.animT*rate)%this.frames.run.length; img=this._imgByKey('run',i); }
    else if(this.state==='jump'){ img=this._imgByKey('run',0); }
    else if((this.state==='atk'||this.state==='skill'||this.state==='skill2'||this.state==='ult') && this._actionSeq){ const cur=this._actionSeq[this._actionIndex]; const key=cur.frame; img=this.world.assets.img(this.frames[key]?this._getFramePath(key,0):key); } else img=this._imgByKey('idle',0);
    if(img){ const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2+ox), Math.round(-h/2), Math.round(w), Math.round(h)); }
    if(this.isUltCharging){
      const holder=this.world.assets.img(this.frames.ul1);
      if(holder){ const scale=this.h/holder.height, w=holder.width*scale, h=this.h; ctx.save(); if(this.face<0) ctx.scale(-1,1); ctx.globalAlpha=0.95; ctx.drawImage(holder, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h)); ctx.restore(); }
      const ul3=this.world.assets.img(this.frames.ul3);
      if(ul3){ const t=Math.min(3, (window._inputUltT||0)); const mul = lerp(0.35, 1.7, clamp(t/3.0,0,1)); const hh=62*mul, ww=62*mul; const oxh = this.face*26, oyh=-14; ctx.save(); ctx.translate(oxh, oyh); if(this.face<0) ctx.scale(-1,1); ctx.globalAlpha=0.95; ctx.drawImage(ul3, Math.round(-ww/2), Math.round(-hh/2), Math.round(ww), Math.round(hh)); ctx.restore(); }
    }
    ctx.restore();
  }
}

/* ===================== Enemies (GabKing / Screw + 以前の全員) ===================== */
/* 共通ヒット: 対象配列の誰かに当てる */
function hitAny(targets, hb, power, dir, opts, effects){
  for(const t of targets){
    if(!t || t.dead) continue;
    if(rectsOverlap(hb, t.aabb())){
      const ok=t.hurt(power, dir, opts, effects);
      if(ok) return t;
    }
  }
  return null;
}

/* ===== GabKing ===== */
class GabBlast extends Projectile{
  constructor(world,x,y,dir,img,ownerTeam){
    super(world,x,y,dir,img,130);
    this.w = 78; this.h = 78; this.vx = 300*dir; this.life = 2.0;
    this.kbMul = 1.5; this.kbuMul=1.55; this.lift  = 1.2;
    this.owner = ownerTeam||TEAM_ENEMY;
  }
}
class GabKing extends CharacterBase{
  constructor(world,effects,assets,x=600){
    super(88,96);
    this.world=world; this.effects=effects; this.assets=assets;
    this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1;
    this.maxhp=2500; this.hp=2500;
    this.cool=0; this.s1CD=0; this.s2CD=0; this.ultCD=0;
    this._seq=null; this._idx=0; this._t=0;
    this.team=TEAM_ENEMY;
    this._opponents=[/* set by game */];
  }
  img(key){
    const map={ idle:'t1.png', walk1:'t2.png', walk2:'t3.png', dash:'t6.png', a1:'t4.png', a2:'t5.png', pose7:'t7.png', pre10:'t10.png', uProj:'t11.png', up8:'t8.png', up9:'t9.png' };
    return this.assets.img(map[key]||'t1.png');
  }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.72, h:this.h*0.92}; }
  hurt(amount, dir, opts={}, effects){
    if(this.invulnT>0||this.dead) return false;
    const saChance = 0.50;
    const luckySA = Math.random() < saChance;
    const forceBreak = !!opts.forceBreakSA;
    const activeSA = forceBreak ? false : luckySA;

    this.hp=Math.max(0,this.hp-amount);
    const kbMul = activeSA ? 0.18 : (opts.kbMul||1);
    const kbuMul= activeSA ? 0.16 : (opts.kbuMul||1);
    const baseKb = 140 + amount*12;
    const baseKbu = (opts.lift?360:(amount>=15?300:210));

    const finalKbMul  = forceBreak ? Math.max(kbMul, 2.2) : kbMul;
    const finalKbuMul = forceBreak ? Math.max(kbuMul,2.2) : kbuMul;

    this.vx = clamp(dir * baseKb * finalKbMul, -320, 320);
    this.vy = - clamp(baseKbu * finalKbuMul, 0, 520);
    this.x += dir * 2.5; this.face = -dir;

    if(!activeSA){ this.state='hurt'; this.hurtT=0; this.invulnT=0.22; }
    if(effects) effects.addSpark(this.x, this.y-12, amount>=28);
    if(this.hp<=0){ this.dead=true; this.vx = dir*520; this.vy = -520; this.spinSpeed=16; this.deathT=0; this.fade=1; }
    return true;
  }
  _hitRect(power, kbMul=1, kbuMul=1, lift=0){
    const hb={ x:this.x + this.face*(this.w*0.36), y:this.y, w:70, h:56 };
    const t=hitAny(this._opponents, hb, power, this.face, {lift, kbMul, kbuMul}, this.effects);
    if(t){ this.effects.addSpark(t.x, t.y-10, power>=70); }
  }
  update(dt, opponents){
    this._opponents = opponents;
    if(this.dead){ this.updatePhysics(dt); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    if(this.s1CD>0) this.s1CD=Math.max(0,this.s1CD-dt);
    if(this.s2CD>0) this.s2CD=Math.max(0,this.s2CD-dt);
    if(this.ultCD>0) this.ultCD=Math.max(0,this.ultCD-dt);

    if(this.state==='atk' || this.state==='skill' || this.state==='ult'){
      this._t+=dt;
      const cur=this._seq?.[this._idx];
      if(cur){
        if(cur.fx) this.x += this.face * cur.fx * dt;
        this.updatePhysics(dt);
        if(cur.hit && !cur._doneHit){ this._hitRect(cur.power, cur.kbMul, cur.kbuMul, cur.lift||0); cur._doneHit=true; }
        if(cur.emit && !cur._emitted){
          const img=this.img('uProj'); const ox=this.face*36, oy=-18;
          const p=new GabBlast(this.world, this.x+ox, this.y+oy, this.face, img, this.team);
          (this.world._skillBullets||(this.world._skillBullets=[])).push(p);
          this.effects.addSpark(this.x+ox, this.y-20, true);
          cur._emitted=true;
        }
        if(this._t>=cur.dur){ this._idx++; this._t=0; if(this._idx>=this._seq.length){ this._seq=null; this.state='idle'; this.vx=0; } }
      }
      this.animT+=dt; return;
    }

    // ターゲット＝最寄り相手
    const tgt = nearestOf(this, opponents);
    const dx=tgt.x-this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1;
    if(this.ultCD<=0 && adx>=200 && Math.random()<0.015){ this._startULT(); return; }
    if(this.s2CD<=0 && adx<=320 && Math.random()<0.03){ this._startSkill2(); return; }
    if(this.s1CD<=0 && adx<=280 && Math.random()<0.05){ this._startSkill1(); return; }
    if(adx<140 && this.cool<=0){ this._startAttack1(); return; }

    const walk=70;
    if(adx>120){ this.vx = (dx>0? walk : -walk); } else { this.vx=0; }
    this.updatePhysics(dt);
    if(!this.onGround) this.state='jump';
    else this.state = Math.abs(this.vx)>1? 'run':'idle';
    this.animT+=dt;
  }
  _startAttack1(){
    this.state='atk'; this._t=0; this._idx=0; this.cool=1.1;
    this._seq=[
      {dur:0.10,key:'a1',fx:120,hit:false},
      {dur:0.18,key:'a2',fx:200,hit:true, power:30, kbMul:1.05, kbuMul:1.05, lift:0.5},
      {dur:0.10,key:'a1',fx:120,hit:false},
      {dur:0.18,key:'a2',fx:200,hit:true, power:30, kbMul:1.05, kbuMul:1.05, lift:0.5},
    ];
  }
  _startSkill1(){ this.state='skill'; this._t=0; this._idx=0; this.s1CD=5.0; this._seq=[ {dur:0.50,key:'dash',fx:0,hit:false,shake:true}, {dur:0.26,key:'dash',fx:420,hit:true,power:70,kbMul:1.2,kbuMul:1.2,lift:0.8} ]; }
  _startSkill2(){ this.state='skill'; this._t=0; this._idx=0; this.s2CD=7.0; this._seq=[ {dur:0.50,key:'dash',fx:0,hit:false,shake:true}, {dur:0.24,key:'dash',fx:480,hit:true,power:40,kbMul:1.0,kbuMul:1.0,lift:0.4}, {dur:0.18,key:'up8',fx:200,hit:true,power:60,kbMul:1.15,kbuMul:1.25,lift:1.2},{dur:0.20,key:'up9',fx:220,hit:true,power:40,kbMul:1.1,kbuMul:1.3,lift:1.4} ]; }
  _startULT(){ this.state='ult'; this._t=0; this._idx=0; this.ultCD=20.0; this._seq=[ {dur:0.50,key:'pre10',fx:0,hit:false,shake:true},{dur:0.22,key:'pose7',fx:0,hit:true, power:50, kbMul:1.05, kbuMul:1.1, lift:0.8},{dur:0.06,key:'pose7',fx:0,hit:false,emit:true} ]; }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY);
    if(this.dead){ ctx.globalAlpha=this.fade; ctx.rotate(this.spinAngle); }
    if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let key='idle';
    if(this.state==='run'){ key = (Math.floor(this.animT*6)%2? 'walk1':'walk2'); }
    else if(this.state==='jump'){ key = (Math.floor(this.animT*8)%2? 'walk1':'walk2'); }
    else if(this.state==='atk' || this.state==='skill' || this.state==='ult'){
      const cur=this._seq?.[this._idx];
      if(cur){
        if(cur.key==='a1') key='a1';
        else if(cur.key==='a2') key='a2';
        else if(cur.key==='dash') key='dash';
        else if(cur.key==='pre10') key='pre10';
        else if(cur.key==='pose7') key='pose7';
        else if(cur.key==='up8') key='up8';
        else if(cur.key==='up9') key='up9';
      }
    }
    const img=this.img(key);
    if(img){ const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h)); }
    ctx.restore();
    this.drawHPBar(ctx,world);
  }
}

/* ===== MOBスクリュー ===== */
class Screw extends CharacterBase{
  constructor(world,effects,assets,x=600){
    super(70,78);
    this.world=world; this.effects=effects; this.assets=assets;
    this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1;
    this.maxhp=1800; this.hp=1800;
    this.cool=0; this.s1CD=0; this.ultCD=0;
    this._seq=null; this._idx=0; this._t=0;
    this.team=TEAM_ENEMY;
    this._opponents=[];
  }
  img(key){
    const map={ idle:'B1.png', walk1:'B2.png', walk2:'B3.png', jump:'B4.png',
      a1_1:'B5.png', a1_2:'B6.png', chain:'B7.png',
      s1prep:'B8.png', s1a:'B9.png', s1b:'B10.png', s1c:'B11.png',
      uprep:'B12.png', udash:'B13.png', uhit:'B14.png'
    };
    return this.assets.img(map[key]||'B1.png');
  }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.70, h:this.h*0.92}; }
  hurt(amount, dir, opts={}, effects){
    if(this.invulnT>0||this.dead) return false;
    const saChance=0.30;
    const forceBreak = !!opts.forceBreakSA;
    const luckySA = Math.random()<saChance;
    const activeSA = forceBreak? false : luckySA;

    this.hp=Math.max(0,this.hp-amount);
    const kbMul = activeSA ? 0.16 : (opts.kbMul||1);
    const kbuMul= activeSA ? 0.14 : (opts.kbuMul||1);
    const baseKb = 140 + amount*12;
    const baseKbu = (opts.lift?360:(amount>=15?300:210));

    const finalKbMul  = forceBreak ? Math.max(kbMul, 2.2) : kbMul;
    const finalKbuMul = forceBreak ? Math.max(kbuMul,2.2) : kbuMul;

    this.vx = clamp(dir * baseKb * finalKbMul, -320, 320);
    this.vy = - clamp(baseKbu * finalKbuMul, 0, 520);
    this.x += dir * 2; this.face = -dir;

    if(!activeSA){ this.state='hurt'; this.hurtT=0; this.invulnT=0.22; }
    if(effects) effects.addSpark(this.x, this.y-12, amount>=28);
    if(this.hp<=0){ this.dead=true; this.vx = dir*520; this.vy = -520; this.spinSpeed=16; this.deathT=0; this.fade=1; }
    return true;
  }
  _hitRect(power, kbMul=1, kbuMul=1, lift=0){
    const hb={ x:this.x + this.face*(this.w*0.36), y:this.y, w:68, h:54 };
    const t=hitAny(this._opponents, hb, power, this.face, {lift, kbMul, kbuMul}, this.effects);
    if(t){ this.effects.addSpark(t.x, t.y-10, power>=60); }
  }
  update(dt, opponents){
    this._opponents=opponents;
    if(this.dead){ this.updatePhysics(dt); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    if(this.s1CD>0) this.s1CD=Math.max(0,this.s1CD-dt);
    if(this.ultCD>0) this.ultCD=Math.max(0,this.ultCD-dt);

    if(this.state==='atk' || this.state==='skill' || this.state==='ult'){
      this._t+=dt;
      const cur=this._seq?.[this._idx];
      if(cur){
        if(cur.fx) this.x += this.face * cur.fx * dt;
        this.updatePhysics(dt);
        if(cur.hit && !cur._hitDone){ this._hitRect(cur.power, cur.kbMul, cur.kbuMul, cur.lift||0); cur._hitDone=true; }
        if(this._t>=cur.dur){ this._idx++; this._t=0; if(this._idx>=this._seq.length){ this._seq=null; this.state='idle'; this.vx=0; } }
      }
      this.animT+=dt; return;
    }

    const tgt = nearestOf(this, opponents);
    const dx=tgt.x-this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1;

    if(this.ultCD<=0 && adx<=340 && Math.random()<0.012){ this._startULT(); return; }
    if(this.s1CD<=0 && adx<=300 && Math.random()<0.035){ this._startSkill1(); return; }
    if(adx<140 && this.cool<=0){ this._startAttack(); return; }

    const walk=60;
    if(adx>120){ this.vx = (dx>0? walk : -walk); }
    else this.vx=0;

    if(this.onGround && Math.random()<0.02){ this.vy = -JUMP_V*0.85; }
    this.updatePhysics(dt);
    if(!this.onGround) this.state='jump';
    else this.state = Math.abs(this.vx)>1? 'run':'idle';
    this.animT+=dt;
  }
  _startAttack(){ this.state='atk'; this._t=0; this._idx=0; this.cool=1.0; this._seq=[ {dur:0.10,key:'a1_1',fx:120,hit:false}, {dur:0.18,key:'a1_2',fx:180,hit:true, power:30, kbMul:1.0, kbuMul:1.0, lift:0.4}, {dur:0.12,key:'a1_1',fx:110,hit:false}, {dur:0.18,key:'chain',fx:200,hit:true, power:35, kbMul:1.1, kbuMul:1.1, lift:0.6}, ]; }
  _startSkill1(){ this.state='skill'; this._t=0; this._idx=0; this.s1CD=5.0; this._seq=[ {dur:0.50,key:'s1prep',fx:0,hit:false}, {dur:0.20,key:'s1a',fx:540,hit:true,power:50,kbMul:1.0,kbuMul:1.0,lift:0.4}, {dur:0.16,key:'s1b',fx:360,hit:true,power:20,kbMul:0.9,kbuMul:0.9,lift:0.2}, {dur:0.22,key:'s1c',fx:380,hit:true,power:50,kbMul:1.3,kbuMul:1.3,lift:0.9}, ]; }
  _startULT(){ this.state='ult'; this._t=0; this._idx=0; this.ultCD=20.0; this._seq=[ {dur:0.50,key:'uprep',fx:0,hit:false}, {dur:0.24,key:'udash',fx:600,hit:false}, {dur:0.20,key:'uhit',fx:0,hit:true,power:120,kbMul:1.6,kbuMul:1.8,lift:1.4}, ]; }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY);
    if(this.dead){ ctx.globalAlpha=this.fade; ctx.rotate(this.spinAngle); }
    if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let key='idle';
    if(this.state==='run'){ key=(Math.floor(this.animT*6)%2? 'walk1':'walk2'); }
    else if(this.state==='jump'){ key='jump'; }
    else if(this.state==='atk' || this.state==='skill' || this.state==='ult'){
      const cur=this._seq?.[this._idx];
      if(cur){ key = cur.key; }
    }
    const img=this.img(key);
    if(img){ const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h)); }
    ctx.restore();
    this.drawHPBar(ctx,world);
  }
}

/* ===== 以前の敵キャラ（AIは既存：ターゲット代理で最寄りを攻撃） ===== */
/* WaruMOB / IceRobo / IceRoboMini / Kozou / MOBGiant は、前版の実装を流用（短縮のため挙動は同等） */
class ProjectileSimple extends Projectile{} // 互換用

/* --- WaruMOB --- */
class WaruMOB extends CharacterBase{
  constructor(world,effects,assets,x=520){
    super(52,60);
    this.world=world; this.effects=effects; this.assets=assets;
    this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1; this.maxhp=100; this.hp=100;
    this.cool=0; this._seq=null; this._idx=0; this._t=0; this.projectiles=[];
    this.team=TEAM_ENEMY; this.targetProxy=null;
  }
  imgByKey(key){ const a=this.assets; const map={ idle:'teki1.png', walk1:'teki1.png', walk2:'teki2.png', prep1:'teki1.png', prep2:'teki3.png' }; return a.img(map[key]||'teki1.png'); }
  addBullet(){ const img=this.assets.img('teki7.png'); const ox=this.face*28; const oy=-8; const p=new Projectile(this.world,this.x+ox,this.y+oy,this.face,img,10); p.owner=this.team; this.projectiles.push(p); }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.6, h:this.h*0.85}; }
  update(dt, opponents){
    if(!this.targetProxy) this.targetProxy=makeTargetProxy(()=>nearestOf(this,opponents));
    const player=this.targetProxy; // 以降は既存フロー
    if(this.dead){ this.updatePhysics(dt); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    for(const p of this.projectiles) p.update(dt); this.projectiles=this.projectiles.filter(p=>!p.dead);
    if(this.state==='atk'){
      this.updatePhysics(dt); if(this._seq){ this._t+=dt; const cur=this._seq[this._idx];
        if(cur && this._t>=cur.dur){ this._idx++; this._t=0; if(this._idx===2){ this.addBullet(); }
          if(this._idx>=this._seq.length){ this._seq=null; this.state='idle'; } } }
      this.animT+=dt; return;
    }
    const dx=player.x - this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1;
    const near=110, mid=170, far=240, fire=220; const patrol=70, backSp=100;
    if(this.cool<=0 && adx<=fire){
      this._seq=[ {kind:'pose',dur:0.18,key:'prep1'}, {kind:'pose',dur:0.22,key:'prep2'} ];
      this.cool=1.6; this.state='atk'; this._idx=0; this._t=0; this.vx=0; this.updatePhysics(dt); this.animT+=dt; return;
    }
    if(this.cool>0){
      if(adx<near){ this.vx = (dx>0? -backSp : backSp); }
      else if(adx>far){ this.vx = (dx>0? patrol : -patrol); }
      else if(adx>mid){ this.vx = (dx>0? patrol : -patrol); }
      else { this.vx = 0; }
    } else {
      if(adx>fire){ this.vx = (dx>0? patrol : -patrol); } else { this.vx = 0; }
    }
    this.updatePhysics(dt);
    this.state = !this.onGround ? 'jump' : (Math.abs(this.vx)>1?'run':'idle');
    this.animT+=dt;
  }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY);
    if(this.dead){ ctx.globalAlpha=this.fade; ctx.rotate(this.spinAngle); }
    if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let img=null;
    if(this.dead){ img=this.imgByKey('idle'); }
    else if(this.state==='atk' && this._seq){ const cur=this._seq[this._idx]; img=this.imgByKey(cur.key||'prep2'); }
    else if(this.state==='run'){ const f=Math.floor(this.animT*6)%2; img=this.imgByKey(f? 'walk1':'walk2'); }
    else { img=this.imgByKey('idle'); }
    if(img){ const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h)); }
    ctx.restore(); this.drawHPBar(ctx,world);
    for(const p of this.projectiles) p.draw(ctx);
  }
}

/* --- IceRobo --- */
class IceRobo extends CharacterBase{
  constructor(world,effects,assets,x=900){
    super(64,70); this.world=world; this.effects=effects; this.assets=assets;
    this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1;
    this.maxhp=1200; this.hp=1200; this.superArmor=false; this.cool=0; this.recoverT=0;
    this.modeJump=false; this.modeSwapT=0; this._seq=null; this._idx=0; this._t=0; this.chargeT=0; this.energyOrbs=[];
    this.team=TEAM_ENEMY; this.targetProxy=null;
  }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.65, h:this.h*0.9}; }
  hurt(amount, dir, opts={}, effects){
    if(this.invulnT>0||this.dead) return false;
    this.hp=Math.max(0,this.hp-amount);
    const kbMul = this.superArmor ? 0.15 : (opts.kbMul||1);
    const kbuMul= this.superArmor ? 0.10 : (opts.kbuMul||1);
    const baseKb = 140 + amount*12;
    const baseKbu = opts.lift ? 360 : (amount>=15? 300 : 210);
    this.vx = clamp(dir * baseKb * kbMul, -220, 220);
    this.vy = - clamp(baseKbu * kbuMul, 0, 380);
    this.x += dir * 2; this.face = -dir;
    if(!this.superArmor){ this.state='hurt'; this.hurtT=0; this.invulnT=0.25; }
    if(effects) effects.addSpark(this.x, this.y-10, amount>=20);
    if(this.hp<=0){ this.dead=true; this.vx = dir * 540; this.vy = -560; this.spinSpeed = 18; this.deathT = 0; this.fade = 1; }
    return true;
  }
  img(key){ const map={ idle:'I1.png', walk1:'I1.png', walk2:'I2.png', jump1:'I1.png', jump2:'I2.png', jump3:'I3.png', charge:'I4.png', release:'I5.png', dashPrep:'I6.png', dashAtk:'I7.png', orb:'I8.png' }; return this.assets.img(map[key]||'I1.png'); }
  addEnergyBall(chargeSec){ const img=this.img('orb'); const ox=this.face*30, oy=-10; const p=new EnergyBall(this.world,this.x+ox,this.y+oy,this.face,img,20,chargeSec,1); p.owner=this.team; this.energyOrbs.push(p); }
  update(dt, opponents){
    if(!this.targetProxy) this.targetProxy=makeTargetProxy(()=>nearestOf(this,opponents));
    const player=this.targetProxy;
    if(this.dead){ this.updatePhysics(dt); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    if(this.recoverT>0){ this.recoverT=Math.max(0,this.recoverT-dt); }
    for(const p of this.energyOrbs) p.update(dt); this.energyOrbs=this.energyOrbs.filter(p=>!p.dead);

    if(this.state==='charge'){
      this.superArmor = true; this.vx = 0; this.updatePhysics(dt);
      this._t += dt; this.chargeT = Math.min(2.0, this.chargeT + dt); this.animT += dt;
      const adx = Math.abs(player.x - this.x);
      if(adx < 180 && this.chargeT > 0.25){ this.releaseEnergy(); }
      else if(this.chargeT >= 2.0){ this.releaseEnergy(); }
      return;
    }
    if(this.state==='dash'){
      this.updatePhysics(dt); this._t += dt;
      if(this._t>=0.35){ this.state='idle'; this.superArmor=false; this.vx=0; this.cool=2.2; }
      this.animT += dt; return;
    }
    if(this.state==='atk' || this.state==='recover'){ this.updatePhysics(dt); this.animT += dt; if(this.state==='recover' && this.recoverT<=0){ this.state='idle'; } return; }
    if(this.state==='hurt'){ this.updatePhysics(dt); if(this.onGround) this.state='idle'; this.animT += dt; return; }

    const dx = player.x - this.x; const adx = Math.abs(dx); this.face = dx>=0? 1 : -1;
    this.modeSwapT -= dt; if(this.modeSwapT<=0 && this.onGround){ this.modeSwapT = 2.5 + Math.random()*2.0; this.modeJump = !this.modeJump; }
    const desireCharge = (adx>=160 && adx<=520);
    if(this.cool<=0 && this.recoverT<=0 && desireCharge){
      if(this.onGround || Math.random()<0.25){ this.state='charge'; this._t=0; this.chargeT=0; this.vx=0; this.superArmor=true; this.cool=3.2; return; }
    }
    if(this.cool<=0 && this.recoverT<=0 && adx<260){
      this.state='atk'; this.superArmor=true; this.vx=0;
      this._seq=[{key:'dashPrep', dur:0.28, vibrate:true},{key:'dashAtk', dur:0.35}];
      this._idx=0; this._t=0; this.animT=0; this.cool=2.6; return;
    }
    const walk=80, run=260;
    if(adx>140){ const sp = this.modeJump? run : walk; this.vx = (dx>0? sp : -sp); if(this.modeJump && this.onGround){ this.vy = -JUMP_V*0.8; } }
    else { this.vx = 0; }
    this.updatePhysics(dt);
    this.state = !this.onGround ? 'jump' : (Math.abs(this.vx)>1?'run':'idle');
    this.animT += dt;
  }
  releaseEnergy(){ this.addEnergyBall(this.chargeT); this.state='recover'; this.recoverT=0.8; this.superArmor=false; }
  draw(ctx,world){
    if(this.state==='atk' && this._seq){
      this._t+=1/60; const cur=this._seq[this._idx];
      if(cur){ cur._t=(cur._t||0)+1/60; if(cur._t>=cur.dur){ this._idx++; if(this._idx>=this._seq.length){ this.state='dash'; this._t=0; this.vx = (this.face>0? 520 : -520); this._seq=null; } } }
    }
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY);
    if(this.dead){ ctx.globalAlpha=this.fade; ctx.rotate(this.spinAngle); }
    if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let img=null, ox=0;
    if(this.state==='charge'){ img=this.img('charge'); ox=Math.sin(performance.now()/25)*1.5; }
    else if(this.state==='dash' || (this.state==='atk' && this._seq && this._seq[this._idx] && this._seq[this._idx].key==='dashAtk')){ img=this.img('dashAtk'); }
    else if(this.state==='atk' && this._seq){ const cur=this._seq[this._idx]; img=this.img(cur.key||'dashPrep'); ox=Math.sin(performance.now()/25)*2; }
    else if(this.state==='recover'){ img=this.img('release'); }
    else if(this.state==='run'){ const f=Math.floor(this.animT*6)%2; img=this.img(f? 'walk1':'walk2'); }
    else if(this.state==='jump'){ const f=Math.floor(this.animT*8)%3; img=this.img(['jump1','jump2','jump3'][f]); }
    else { img=this.img('idle'); }
    if(img){ const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2+ox), Math.round(-h/2), Math.round(w), Math.round(h)); }
    if(this.state==='charge'){
      const orb=this.img('orb'); const t=this.chargeT;
      const mul = 0.6 + 0.8*(t/2); const hh=32*mul, ww=44*mul; const oxh = this.face*26, oyh=-14;
      if(orb){ ctx.save(); ctx.translate(oxh, oyh); if(this.face<0) ctx.scale(-1,1); ctx.globalAlpha=0.9; ctx.drawImage(orb, Math.round(-ww/2), Math.round(-hh/2), Math.round(ww), Math.round(hh)); ctx.restore(); }
    }
    ctx.restore();
    this.drawHPBar(ctx,world);
    for(const p of this.energyOrbs) p.draw(ctx);
  }
}

/* --- IceRoboMini --- */
class IceRoboMini extends CharacterBase{
  constructor(world, effects, assets, x=1200){
    super(40,44); this.world=world; this.effects=effects; this.assets=assets;
    this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1;
    this.maxhp=50; this.hp=50; this.cool=0; this.state='idle'; this.animT=0; this.hopT=0; this.superArmor=false;
    this.team=TEAM_ENEMY; this.targetProxy=null;
  }
  img(key){ const map={ idle:'IC.png', move:'IC2.png', atk1:'IC3.png', sp:'IC4.png' }; return this.assets.img(map[key]||'IC.png'); }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.65, h:this.h*0.9}; }
  update(dt, opponents){
    if(!this.targetProxy) this.targetProxy=makeTargetProxy(()=>nearestOf(this,opponents));
    const player=this.targetProxy;
    if(this.dead){ this.updatePhysics(dt); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    if(this.state==='sp'){
      this.superArmor=true; this.hopT+=dt; const period=0.24, bounces=5;
      const bi=Math.floor(this.hopT/period); const dir = (bi%2===0)? this.face : -this.face;
      this.vx = dir * 240; if(this.onGround) this.vy = -JUMP_V*0.45;
      this.updatePhysics(dt);
      if(this.hopT>=period*bounces){ this.state='idle'; this.vx=0; this.superArmor=false; this.hopT=0; this.cool=1.6; }
      const hb={x:this.x + this.face*18, y:this.y, w:36, h:28};
      if(rectsOverlap(hb, player.aabb()) && player.invulnT<=0){ const hit=player.hurt(7, this.face, {lift:0.3,kbMul:0.9,kbuMul:0.9}, this.effects); if(hit){} }
      this.animT+=dt; return;
    }
    if(this.state==='atk'){
      this.hopT+=dt; const dur=0.32; this.vx = this.face * 140; this.updatePhysics(dt);
      if(this.hopT>dur*0.5 && this.hopT<=dur*0.75){
        const hb={x:this.x + this.face*18, y:this.y, w:36, h:28};
        if(player.invulnT<=0 && rectsOverlap(hb, player.aabb())){ player.hurt(5, this.face, {lift:0.2,kbMul:0.8,kbuMul:0.8}, this.effects); }
      }
      if(this.hopT>=dur){ this.state='idle'; this.hopT=0; this.vx=0; this.cool=0.9; }
      this.animT+=dt; return;
    }
    const dx=player.x-this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1;
    this.vx = (dx>0? 70 : -70); this.hopT+=dt;
    if(this.onGround && this.hopT>0.35){ this.vy=-JUMP_V*0.35; this.hopT=0; }
    if(this.cool<=0){
      if(adx<120 && Math.random()<0.7){ this.state='atk'; this.hopT=0; this.animT=0; }
      else if(adx<220 && Math.random()<0.35){ this.state='sp'; this.hopT=0; this.animT=0; }
    }
    this.updatePhysics(dt);
    this.state = (this.state==='idle'||this.state==='run') ? (this.onGround? 'run':'jump') : this.state;
    this.animT+=dt;
  }
  hurt(amount, dir, opts={}, effects){ if(this.state==='sp'){ opts={...(opts||{}), kbMul:0.2, kbuMul:0.2}; }
    return super.hurt(amount, dir, opts, effects);
  }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY); if(this.face<0) ctx.scale(-1,1);
    let img=null; if(this.state==='sp') img=this.img('sp');
    else if(this.state==='atk'){ img=this.hopT<0.16? this.img('idle'): this.img('atk1'); }
    else if(!this.onGround) img=this.img('move'); else img=this.img('move');
    if(img){ const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h)); }
    ctx.restore(); this.drawHPBar(ctx,world);
  }
}

/* --- Kozou --- */
class KozouStone extends Projectile{
  constructor(world,x,y,dir,img,ownerTeam){ super(world,x,y,dir,img,5); this.vx = 120*dir; this.vy = -360; this.w = 24; this.h = 24; this.gravity = 900; this.owner=ownerTeam||TEAM_ENEMY; }
  update(dt){ if(this.dead) return; this.vy += this.gravity*dt; this.x += this.vx*dt; this.y += this.vy*dt;
    const ground = Math.floor(GROUND_TOP_Y); if(this.y + this.h/2 >= ground+FOOT_PAD){ this.dead=true; } }
}
class Kozou extends CharacterBase{
  constructor(world,effects,assets,x=1400){
    super(50,58); this.world=world; this.effects=effects; this.assets=assets;
    this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1;
    this.maxhp=100; this.hp=100; this.cool=0; this.state='idle'; this.animT=0; this.projectiles=[];
    this.guard=false; this.guardHits=0; this._thrown=false; this.team=TEAM_ENEMY; this.targetProxy=null;
  }
  img(key){ const map={ idle:'SL.png', w1:'SL2.png', w2:'SL3.png', prep:'SL4.png', throw:'SL5.png', guard:'SL6.png', counter:'SL7.png', stone:'SL8.png'}; return this.assets.img(map[key]||'SL.png'); }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.65, h:this.h*0.9}; }
  update(dt, opponents){
    if(!this.targetProxy) this.targetProxy=makeTargetProxy(()=>nearestOf(this,opponents));
    const player=this.targetProxy;
    if(this.dead){ this.updatePhysics(dt); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    for(const p of this.projectiles) p.update(dt); this.projectiles=this.projectiles.filter(p=>!p.dead);

    if(this.state==='counter'){
      this.updatePhysics(dt); this.animT+=dt; const dur=0.28; const mid=0.14;
      if(this.animT<dur){ this.vx=this.face*120; }
      if(this.animT>mid){
        const hb={x:this.x + this.face*18, y:this.y, w:36, h:30};
        if(player.invulnT<=0 && rectsOverlap(hb, player.aabb())){ player.hurt(8, this.face, {lift:0.3,kbMul:0.9,kbuMul:0.9}, this.effects); }
      }
      if(this.animT>=dur){ this.state='idle'; this.vx=0; this.cool=1.2; this.guard=false; this.guardHits=0; }
      return;
    }
    if(this.state==='throw'){
      this.updatePhysics(dt); this.animT+=dt;
      if(this.animT>0.22 && !this._thrown){ this._thrown=true; const img=this.img('stone'); const ox=this.face*14, oy=-18;
        const p=new KozouStone(this.world, this.x+ox, this.y+oy, this.face, img, this.team); this.projectiles.push(p); }
      if(this.animT>0.4){ this.state='idle'; this.vx=0; this.cool=1.4; this._thrown=false; }
      return;
    }
    if(this.guard){ this.vx=0; this.updatePhysics(dt); this.animT+=dt;
      const dx=player.x-this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1; if(adx<120){ this.vx = (dx>0? -80 : 80); } return; }

    const dx=player.x-this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1;
    if(adx>140){ this.vx = (dx>0? 70 : -70); } else this.vx=0;
    if(this.cool<=0){
      if(adx>120 && Math.random()<0.5){ this.state='throw'; this.animT=0; this.vx=0; }
      else if(Math.random()<0.35){ this.guard=true; this.state='idle'; this.animT=0; this.vx=0; }
    }
    this.updatePhysics(dt);
    this.state = this.onGround ? (Math.abs(this.vx)>1?'run':'idle') : 'jump';
    this.animT+=dt;
  }
  hurt(amount, dir, opts={}, effects){
    if(this.guard){ amount = Math.ceil(amount*0.5); this.guardHits = Math.min(3, this.guardHits+1); if(this.guardHits>=3 && this.state!=='counter'){ this.state='counter'; this.animT=0; this.vx=0; } }
    return super.hurt(amount, dir, opts, effects);
  }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY); if(this.face<0) ctx.scale(-1,1);
    let img=null;
    if(this.state==='throw'){ img=this.animT<0.2? this.img('prep'): this.img('throw'); }
    else if(this.state==='counter'){ img=this.img('counter'); }
    else if(this.guard){ img=this.img('guard'); }
    else if(this.state==='run'){ const f=Math.floor(this.animT*6)%2; img=this.img(f?'w1':'w2'); }
    else { img=this.img('idle'); }
    if(img){ const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h)); }
    ctx.restore(); this.drawHPBar(ctx,world);
    for(const p of this.projectiles) p.draw(ctx);
  }
}

/* --- MOBGiant --- */
class MOBGiant extends CharacterBase{
  constructor(world,effects,assets,x=1650){
    super(76,90);
    this.world=world; this.effects=effects; this.assets=assets;
    this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1;
    this.maxhp=2000; this.hp=2000;
    this.superArmor=false;
    this.cool=0; this.recoverT=0; this.modeJump=false; this.modeSwapT=0;
    this.chargeT=0; this.energyOrbs=[]; this.postLagT=0;
    this.lowFreqBias=0.0; this.team=TEAM_ENEMY; this.targetProxy=null;
  }
  aabb(){ return {x:this.x, y:this.y, w:this.w*0.68, h:this.h*0.95}; }
  img(key){
    const map={ idle:'P1.png', w1:'P1.png', w2:'P2.png', j1:'P1.png', j2:'P2.png', j3:'P3.png',
      dashPrep:'P4.png', dashAtk:'P5.png', charge:'P6.png', release:'P7.png', orb:'P10.png' };
    return this.assets.img(map[key]||'P1.png');
  }
  hurt(amount, dir, opts={}, effects){
    if(this.invulnT>0||this.dead) return false;
    const stateSA = this.superArmor;
    const halfSA = Math.random()<0.70;
    const activeSA = stateSA || halfSA;
    this.hp=Math.max(0,this.hp-amount);
    const kbMul = activeSA ? 0.12 : (opts.kbMul||1);
    const kbuMul= activeSA ? 0.10 : (opts.kbuMul||1);
    const baseKb = 140 + amount*12;
    const baseKbu = opts.lift ? 360 : (amount>=15? 300 : 210);
    this.vx = clamp(dir * baseKb * kbMul, -200, 200);
    this.vy = - clamp(baseKbu * kbuMul, 0, 320);
    this.x += dir * 1.5; this.face = -dir;
    if(!activeSA){ this.state='hurt'; this.hurtT=0; this.invulnT=0.20; }
    if(effects) effects.addSpark(this.x, this.y-12, amount>=25);
    if(this.hp<=0){ this.dead=true; this.vx = dir * 520; this.vy = -520; this.spinSpeed = 16; this.deathT = 0; this.fade = 1; }
    return true;
  }
  addEnergyPair(chargeSec){
    const img=this.img('orb');
    const ox=this.face*34, oy=-16;
    const p1=new EnergyBall(this.world,this.x+ox,this.y+oy, this.face,  img, 30, chargeSec, 2);
    const p2=new EnergyBall(this.world,this.x-ox,this.y+oy,-this.face, img, 30, chargeSec, 2);
    p1.owner=this.team; p2.owner=this.team; this.energyOrbs.push(p1,p2);
  }
  update(dt, opponents){
    if(!this.targetProxy) this.targetProxy=makeTargetProxy(()=>nearestOf(this,opponents));
    const player=this.targetProxy;
    if(this.dead){ this.updatePhysics(dt); return; }
    if(this.cool>0) this.cool=Math.max(0,this.cool-dt);
    if(this.recoverT>0){ this.recoverT=Math.max(0,this.recoverT-dt); }
    if(this.postLagT>0){ this.postLagT=Math.max(0,this.postLagT-dt); }
    for(const p of this.energyOrbs) p.update(dt); this.energyOrbs=this.energyOrbs.filter(p=>!p.dead);

    if(this.state==='charge'){
      this.superArmor = true; this.vx=0; this.updatePhysics(dt);
      this.chargeT=Math.min(2.0, this.chargeT + dt);
      const adx=Math.abs(player.x - this.x);
      if(adx<180 && this.chargeT>0.25){ this.releaseEnergy(); }
      else if(this.chargeT>=2.0){ this.releaseEnergy(); }
      this.animT+=dt; return;
    }
    if(this.state==='dash'){
      this.updatePhysics(dt); this.animT+=dt;
      if(this.animT>=0.38){ this.state='idle'; this.superArmor=false; this.vx=0; this.cool=2.8 + this.lowFreqBias; }
      return;
    }
    if(this.state==='post'){
      this.updatePhysics(dt); this.animT+=dt;
      if(this.postLagT<=0){ this.state='idle'; }
      return;
    }
    if(this.state==='hurt'){ this.updatePhysics(dt); if(this.onGround) this.state='idle'; this.animT+=dt; return; }

    const dx = player.x - this.x; const adx = Math.abs(dx); this.face = dx>=0?1:-1;
    this.modeSwapT -= dt;
    if(this.modeSwapT<=0 && this.onGround){
      this.modeSwapT = 2.8 + Math.random()*2.4;
      this.modeJump = !this.modeJump;
    }
    this.lowFreqBias = clamp(this.lowFreqBias + (Math.random()*0.2-0.1), 0.0, 1.8);

    const desireCharge = (adx>=200 && adx<=560);
    if(this.cool<=0 && this.recoverT<=0 && this.postLagT<=0 && desireCharge){
      if(this.onGround || Math.random()<0.35){
        this.state='charge'; this.chargeT=0; this.superArmor=true; this.vx=0;
        this.cool = 3.6 + this.lowFreqBias; this.animT=0; return;
      }
    }
    if(this.cool<=0 && this.recoverT<=0 && adx<220){
      this.state='dash'; this.animT=0; this.superArmor=true;
      this.vx = (this.face>0? 520 : -520);
      this.cool = 3.2 + this.lowFreqBias; return;
    }

    const walk=70, run=260;
    if(adx>140){
      const sp = this.modeJump? run : walk;
      this.vx = (dx>0? sp : -sp);
      if(this.modeJump && this.onGround){ this.vy = -JUMP_V*0.9; }
    } else { this.vx=0; }

    this.updatePhysics(dt);
    if(!this.onGround) this.state='jump';
    else this.state = Math.abs(this.vx)>1? 'run':'idle';
    this.animT+=dt;
  }
  releaseEnergy(){ this.addEnergyPair(this.chargeT); this.state='post'; this.postLagT=1.0; this.superArmor=false; this.animT=0; }
  draw(ctx,world){
    ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY);
    if(this.dead){ ctx.globalAlpha=this.fade; ctx.rotate(this.spinAngle); }
    if(this.face<0 && !this.dead) ctx.scale(-1,1);
    let img=null, ox=0;
    if(this.state==='charge'){ img=this.img('charge'); ox=Math.sin(performance.now()/25)*1.5; }
    else if(this.state==='dash'){ img=this.img('dashAtk'); }
    else if(this.state==='post'){ img=this.img('release'); }
    else if(this.state==='run'){ const f=Math.floor(this.animT*6)%2; img=this.img(f?'w1':'w2'); }
    else if(this.state==='jump'){
      const f=Math.floor(this.animT*8)%3; img=this.img(['j1','j2','j3'][f]);
    } else { img=this.img('idle'); }
    if(img){ const scale=this.h/img.height, w=img.width*scale, h=this.h; ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2+ox), Math.round(-h/2), Math.round(w), Math.round(h)); }
    if(this.state==='charge'){
      const orb=this.img('orb'); const t=this.chargeT;
      const mul = 0.5 + 1.0*(t/2);
      const hh=34*mul, ww=48*mul; const oxh = this.face*30, oyh=-18;
      if(orb){ ctx.save(); ctx.translate(oxh, oyh); if(this.face<0) ctx.scale(-1,1); ctx.globalAlpha=0.95; ctx.drawImage(orb, Math.round(-ww/2), Math.round(-hh/2), Math.round(ww), Math.round(hh)); ctx.restore(); }
    }
    ctx.restore();
    this.drawHPBar(ctx,world);
    for(const p of this.energyOrbs) p.draw(ctx);
  }
}

/* ===================== World / Stage ===================== */
class World{
  constructor(assets, canvas, effects){
    this.assets=assets; this.effects=effects; this.canvas=canvas;
    this.ctx=canvas.getContext('2d',{alpha:true}); this.ctx.imageSmoothingEnabled=false;
    this.gameW=canvas.width; this.gameH=canvas.height; this.camX=0; this.camY=0; this.time=0; this._timerAcc=0;
    const r=this.canvas.getBoundingClientRect(); this.screenScaleX=r.width/this.gameW; this.screenScaleY=r.height/this.gameH;

    this.bgImg = this.assets.has('MOBA.png') ? this.assets.img('MOBA.png') : (this.assets.has('back1.png') ? this.assets.img('back1.png') : null);
    if(this.bgImg){
      this.bgScale = this.gameH / this.bgImg.height;
      this.stageW  = Math.max(this.gameW, Math.round(this.bgImg.width * this.bgScale));
      this.bgDW = this.stageW; this.bgDH = Math.round(this.bgImg.height * this.bgScale);
    } else { this.stageW = 2400; }
    this.bgSpeed=1.0;
  }
  resize(){ const r=this.canvas.getBoundingClientRect(); this.screenScaleX=r.width/this.gameW; this.screenScaleY=r.height/this.gameH; }
  updateCam(p){
    const offs=this.effects.getCamOffset();
    const target=p.x - this.gameW*0.35 + offs.x;
    this.camX = clamp(lerp(this.camX,target,0.12), 0, Math.max(0, (this.stageW - this.gameW)));
    this.camY=offs.y;
  }
  updateTimer(dt){
    this._timerAcc+=dt; if(this._timerAcc>=0.2){ this.time+=this._timerAcc; this._timerAcc=0;
      const t=Math.floor(this.time); const mm=String(Math.floor(t/60)).padStart(2,'0'); const ss=String(t%60).padStart(2,'0'); document.getElementById('time').textContent=`${mm}:${ss}`; }
  }
  draw(player, allies, enemies){
    const ctx=this.ctx; ctx.clearRect(0,0,this.gameW,this.gameH);
    if(this.bgImg){
      ctx.drawImage(this.bgImg, 0,0,this.bgImg.width,this.bgImg.height,
        Math.round(-this.camX*this.bgSpeed), 0, this.bgDW, this.bgDH);
    } else {
      const g=ctx.createLinearGradient(0,0,0,this.gameH); g.addColorStop(0,'#0a1230'); g.addColorStop(1,'#0a0f18'); ctx.fillStyle=g; ctx.fillRect(0,0,this.gameH,this.gameH);
    }
    ctx.fillStyle='#0b0f17'; const yTop=Math.floor(GROUND_TOP_Y); ctx.fillRect(0,yTop-1,this.gameW,1);

    if(this._skillBullets){ for(const p of this._skillBullets) p.draw(ctx); }
    for(const a of allies) a.draw(ctx,this);
    for(const e of enemies) e.draw(ctx,this);
    player.draw(ctx,this); this.effects.draw(ctx,this);
  }
}

/* ===================== UI / HP ===================== */
const updateHPUI=(hp,maxhp)=>{ const fill=document.getElementById('hpfill'); document.getElementById('hpnum').textContent=hp; fill.style.width=Math.max(0,Math.min(100,(hp/maxhp)*100))+'%'; };

/* ===================== Utility ===================== */
function nearestOf(self, arr){
  let best=arr[0], bd=Infinity;
  for(const t of arr){ if(!t||t.dead) continue; const d=Math.abs((t.x||0)-(self.x||0)); if(d<bd){ bd=d; best=t; } }
  return best||arr[0];
}

/* ===================== Game ===================== */
class Game{
  constructor(){
    this.assets=new Assets();
    this.canvas=document.getElementById('game');
    this.input=new Input();
    this.effects=new Effects();
    this.player=null; this.allies=[]; this.enemies=[]; this.world=null; this.lastT=0;

    this.ROSTER = [
      {key:'gabking', name:'ガブキング', ctor:(w,e,a,x)=>new GabKing(w,e,a,x)},
      {key:'screw',   name:'MOBスクリュー', ctor:(w,e,a,x)=>new Screw(w,e,a,x)},
      {key:'waru',    name:'WaruMOB', ctor:(w,e,a,x)=>new WaruMOB(w,e,a,x)},
      {key:'icerobo', name:'IceRobo', ctor:(w,e,a,x)=>new IceRobo(w,e,a,x)},
      {key:'icmini',  name:'IceRoboMini', ctor:(w,e,a,x)=>new IceRoboMini(w,e,a,x)},
      {key:'kozou',   name:'Kozou', ctor:(w,e,a,x)=>new Kozou(w,e,a,x)},
      {key:'giant',   name:'MOBGiant', ctor:(w,e,a,x)=>new MOBGiant(w,e,a,x)},
    ];

    addEventListener('resize',()=>this.world?.resize());
  }
  async start(){
    const imgs=[
      'MOBA.png','back1.png',
      /* Player */
      'M1-1.png','M1-2.png','M1-3.png','M1-4.png','K1-1.png','K1-2.png','K1-3.png','K1-4.png','K1-5.png',
      'h1.png','h2.png','h3.png','h4.png','J.png',
      'UL1.PNG','UL2.PNG','UL3.png','Y1.png','Y2.png','Y3.png','Y4.png','kem.png',
      /* WaruMOB */
      'teki1.png','teki2.png','teki3.png','teki7.png',
      /* IceRobo */
      'I1.png','I2.png','I3.png','I4.png','I5.png','I6.png','I7.png','I8.png',
      /* IceRoboMini */
      'IC.png','IC2.png','IC3.png','IC4.png',
      /* Kozou */
      'SL.png','SL2.png','SL3.png','SL4.png','SL5.png','SL6.png','SL7.png','SL8.png',
      /* MOBGiant */
      'P1.png','P2.png','P3.png','P4.png','P5.png','P6.png','P7.png','P10.png',
      /* GabKing */
      't1.png','t2.png','t3.png','t4.png','t5.png','t6.png','t7.png','t8.png','t9.png','t10.png','t11.png',
      /* Screw */
      'B1.png','B2.png','B3.png','B4.png','B5.png','B6.png','B7.png','B8.png','B9.png','B10.png','B11.png','B12.png','B13.png','B14.png'
    ];
    await this.assets.load(imgs);
    this.world=new World(this.assets,this.canvas,this.effects);
    this.player=new Player(this.assets,this.world,this.effects);

    this._buildSelectUI();
  }

  _buildSelectUI(){
    const modal=document.getElementById('selectModal');
    const allyList=document.getElementById('allyList');
    const enemyList=document.getElementById('enemyList');
    const allyCount=document.getElementById('allyCount');
    const enemyCount=document.getElementById('enemyCount');
    const startBtn=document.getElementById('startBtn');
    const clearBtn=document.getElementById('clearBtn');

    const makeItem=(id,label,container)=>{
      const wrap=document.createElement('label'); wrap.className='selItem';
      const cb=document.createElement('input'); cb.type='checkbox'; cb.id=id; cb.value=id;
      const span=document.createElement('span'); span.textContent=label;
      wrap.appendChild(cb); wrap.appendChild(span); container.appendChild(wrap);
      return cb;
    };

    const allyCBs=[], enemyCBs=[];
    for(const r of this.ROSTER){
      allyCBs.push(makeItem('a_'+r.key, r.name, allyList));
      enemyCBs.push(makeItem('e_'+r.key, r.name, enemyList));
    }

    const updateCounts=()=>{
      const ac=allyCBs.filter(c=>c.checked).length;
      const ec=enemyCBs.filter(c=>c.checked).length;
      allyCount.textContent=`選択数: ${ac} / 3`;
      enemyCount.textContent=`選択数: ${ec} / 10`;
    };
    allyList.addEventListener('change',e=>{
      const chosen=allyCBs.filter(c=>c.checked);
      if(chosen.length>3){ e.target.checked=false; } updateCounts();
    });
    enemyList.addEventListener('change',e=>{
      const chosen=enemyCBs.filter(c=>c.checked);
      if(chosen.length>10){ e.target.checked=false; } updateCounts();
    });
    clearBtn.addEventListener('click',()=>{
      [...allyCBs, ...enemyCBs].forEach(c=>c.checked=false); updateCounts();
    });

    startBtn.addEventListener('click',()=>{
      const alliesSel = allyCBs.filter(c=>c.checked).map(c=>c.id.replace('a_',''));
      const enemiesSel= enemyCBs.filter(c=>c.checked).map(c=>c.id.replace('e_',''));
      // 少なくとも敵が1体は必要
      if(enemiesSel.length===0){ alert('敵を1体以上選んでください'); return; }

      // 生成
      const startX = clamp(560, 0, this.world.stageW-200);
      const spacing = 120;

      // Allies（左側・プレイヤー近く）
      this.allies = alliesSel.slice(0,3).map((k,i)=>{
        const r=this.ROSTER.find(x=>x.key===k);
        const a=r.ctor(this.world,this.effects,this.assets, this.player.x + 60 + i*spacing);
        a.team=TEAM_ALLY;
        return a;
      });

      // Enemies（右側）
      this.enemies = enemiesSel.slice(0,10).map((k,i)=>{
        const r=this.ROSTER.find(x=>x.key===k);
        const e=r.ctor(this.world,this.effects,this.assets, startX + i*spacing);
        e.team=TEAM_ENEMY;
        return e;
      });

      modal.style.display='none';
      updateHPUI(this.player.hp,this.player.maxhp);
      this._run();
    },{once:true});
  }

  _run(){
    this.lastT=now();
    const clampActorToWalls = (a)=>{
      const half=a.w/2;
      if(a.x < half){ a.x = half; if(a.vx<0) a.vx=0; }
      if(a.x > this.world.stageW - half){ a.x = this.world.stageW - half; if(a.vx>0) a.vx=0; }
    };

    const loop=()=>{
      const t=now(); let dt=(t-this.lastT)/1000; if(dt>0.05) dt=0.05; this.lastT=t;
      if(this.effects.hitstop>0){ this.effects.update(dt); this.world.updateCam(this.player); this.world.draw(this.player,this.allies,this.enemies); requestAnimationFrame(loop); return; }

      const input=this.input;
      window._inputUltT = input.ultChargeT || 0;

      /* Update */
      this.player.update(dt,this.input,this.world,this.enemies);
      clampActorToWalls(this.player);

      // Allies AI：最寄りの敵をターゲットに渡す
      for(const a of this.allies){ a.update(dt, this.enemies); clampActorToWalls(a); }

      // Enemies AI：プレイヤー＋味方の中で最寄りを狙う
      const defenders=[this.player, ...this.allies];
      for(const e of this.enemies){ e.update(dt, defenders); clampActorToWalls(e); }

      /* 弾丸・設置 */
      if(this.world._skillBullets){
        for(const p of this.world._skillBullets){
          p.update(dt);
          const isPlayerSide = (p.owner===TEAM_PLAYER||p.owner===TEAM_ALLY);
          const targets = isPlayerSide ? this.enemies : defenders;
          for(const tgt of targets){
            if(!p.dead && !tgt.dead && rectsOverlap(p.aabb(), tgt.aabb())){
              p.dead=true;
              const dir = (tgt.x>=p.x)? 1 : -1;
              const opts = p.isUlt
                ? { lift:(p.lift??1.0), kbMul: (p.kbMul??2.2), kbuMul:(p.kbuMul??2.2), forceBreakSA:true }
                : { lift:(p.lift??0.3), kbMul:(p.kbMul??0.9), kbuMul:(p.kbuMul??0.9) };
              const hit = tgt.hurt(p.power, dir, opts, this.effects);
              if(hit) this.effects.addSpark(tgt.x, tgt.y-10, p.power>=40);
            }
          }
        }
        this.world._skillBullets = this.world._skillBullets.filter(p=>!p.dead && p.life>0);
      }

      /* のめり込み解消（プレイヤー vs 敵/味方、味方 vs 敵） */
      const resolvePair=(A,B)=>{
        if(A.dead||B.dead) return;
        const a=A.aabb(), b=B.aabb();
        if(!rectsOverlap(a,b)) return;
        const dx = (A.x - B.x), dy = (A.y - B.y);
        const overlapX = (a.w + b.w)/2 - Math.abs(dx);
        const overlapY = (a.h + b.h)/2 - Math.abs(dy);
        if(overlapY < overlapX){
          const dirY = dy>=0? 1 : -1;
          A.y += dirY * overlapY * 0.9; B.y -= dirY * overlapY * 0.1;
          if(dirY<0){ A.vy = Math.max(A.vy, 0); } else { A.vy = Math.min(A.vy, 0); }
        } else {
          const dirX = dx>=0? 1 : -1;
          A.x += dirX * overlapX * 0.6; B.x -= dirX * overlapX * 0.4;
          A.vx += dirX * 20; B.vx -= dirX * 20;
        }
        clampActorToWalls(A); clampActorToWalls(B);
      };
      for(const e of this.enemies){ resolvePair(this.player,e); for(const a of this.allies) resolvePair(a,e); }

      /* 死亡掃除 */
      this.enemies=this.enemies.filter(e=>!(e.dead && e.fade<=0));
      this.allies =this.allies .filter(a=>!(a.dead && a.fade<=0));

      this.effects.update(dt); this.world.updateCam(this.player); this.world.updateTimer(dt);
      this.world.draw(this.player, this.allies, this.enemies);
      requestAnimationFrame(loop);
    };
    requestAnimationFrame(loop);
  }
}

/* ===== プレイヤー被弾（ノックバック強め＋SA時軽減） ===== */
Player.prototype.hurt = function(amount,dir,opts,effects){
  if(this.state==='skill2'){ opts = {...(opts||{}), kbMul:0.1, kbuMul:0.1}; }
  else if(this.saT>0){ opts = {...(opts||{}), kbMul:0.1, kbuMul:0.1}; }
  else{
    const km = (opts?.kbMul ?? 1)*1.3;
    const kum= (opts?.kbuMul?? 1)*1.25;
    opts = {...(opts||{}), kbMul:km, kbuMul:kum};
  }
  const hit = CharacterBase.prototype.hurt.call(this,amount,dir,opts,effects);
  if(hit){
    const fill=document.getElementById('hpfill'); document.getElementById('hpnum').textContent=this.hp; fill.style.width=Math.max(0,Math.min(100,(this.hp/this.maxhp)*100))+'%';
    if(this.state!=='skill2'){
      this._actionSeq = null; this._actionIndex = 0; this._actionTime = 0;
      this.bufferA1 = false; this.comboStep = 0; this.comboGraceT = 0; this.a2LockoutT = 0;
      this.overhead?.root && (this.overhead.root.style.display='none');
      this.jumpsLeft=this.maxJumps;
      this.isUltCharging=false;
    }
  }
  return hit;
};

/* ===== Boot ===== */
const game = new Game();
game.start();
})();
</script>
</body>
</html>
