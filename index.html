<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>MOB Side Action ‚Äì Prototype v2 (fix)</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{
    --bg:#06070a; --panel:#0f1220cc; --panel-border:#1a2140; --hud:#0f1220e6; --fg:#e8ebff;
    --grid-gap:10px; --phone-w:420px; --phone-h:800px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Meiryo",sans-serif;touch-action:none;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none;overscroll-behavior:none}
  #root{position:fixed;inset:0;display:grid;place-items:center;padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)}
  #phone{
    width:min(100vw,var(--phone-w)); height:min(100vh,var(--phone-h)); max-height:100vh;
    display:grid; grid-template-rows: 1fr auto; gap:var(--grid-gap);
    background:linear-gradient(#070a12,#0a0f1b); border:1px solid #0b132b; border-radius:18px; box-shadow:0 20px 60px rgba(0,0,0,.45); padding:12px; position:relative;
  }
  #gameWrap{ position:relative; background:#000; border:1px solid var(--panel-border); border-radius:12px; overflow:hidden; box-shadow: inset 0 0 0 1px #0008; }
  canvas#game{ display:block; width:100%; height:100%; background:#000 }
  .hud{ position:absolute; left:0; right:0; top:0; display:flex; gap:8px; align-items:center; justify-content:space-between; padding:8px 10px; color:var(--fg); font-weight:600; text-shadow:0 1px 0 #000; pointer-events:none; }
  .hud .chip{ background:var(--hud); border:1px solid var(--panel-border); border-radius:10px; padding:6px 10px; display:flex; gap:10px; align-items:center }
  .bar{ position:relative; width:140px; height:8px; background:#223; border:1px solid #334; border-radius:999px; overflow:hidden }
  .bar>.fill{ position:absolute; left:0; top:0; bottom:0; width:100%; background:linear-gradient(#59f,#38a); box-shadow:0 0 10px #59f8 inset }
  #controls{ display:grid; grid-template-columns: 1fr 1fr; gap:var(--grid-gap); background:var(--panel); border:1px solid var(--panel-border); border-radius:12px; padding:12px; }
  .zone{ background:#0b1022aa; border:1px dashed #243056; border-radius:10px; position:relative; min-height:180px; }
  .zone::after{ content:""; position:absolute; inset:0; background:
      linear-gradient(#ffffff08 0 1px, transparent 1px 100%) 0 0/100% 20%,
      linear-gradient(90deg,#ffffff08 0 1px, transparent 1px 100%) 0 0/20% 100%; pointer-events:none; border-radius:10px; }
  .stick-base{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:140px; height:140px; border-radius:999px; background:#1118; border:1px solid #234; box-shadow:0 0 0 1px #000 inset; }
  .stick-nub{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:72px; height:72px; border-radius:999px; background:#89a; opacity:.9; border:2px solid #abc; box-shadow:0 6px 14px #0008 }
  .btn{ position:absolute; display:grid; place-items:center; width:68px; height:68px; border-radius:999px; border:2px solid #234; background:#1a2240de; box-shadow:0 6px 14px #0008; color:#cfe; font-weight:800; font-size:20px }
  .btn:active{ transform:translateY(1px); filter:brightness(1.1) }
  .btn.x{ right:24px; bottom:24px } .btn.skill{ right:108px; bottom:62px } .btn.a2{ right:24px; bottom:108px } .btn.a1{ right:108px; bottom:146px }
  .btn .hint{ position:absolute; bottom:-18px; font-size:12px; color:#9ac }
  #debug{ position:absolute; right:6px; top:6px; font:12px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#adf; background:#0008; padding:6px 8px; border-radius:8px; border:1px solid #234 }
</style>
</head>
<body>
  <div id="root">
    <div id="phone">
      <div id="gameWrap" aria-label="„Ç≤„Éº„É†ÁîªÈù¢">
        <canvas id="game"></canvas>
        <div class="hud">
          <div class="chip">‚è± <span id="timer">00:00</span></div>
          <div class="chip">‚ô• HP <div class="bar" aria-label="HP„Éê„Éº"><div class="fill" id="hpFill"></div></div></div>
          <div class="chip">üßç√ó<span id="lives">3</span></div>
        </div>
        <div id="debug" aria-hidden="true"></div>
      </div>
      <div id="controls" aria-label="„Éó„É¨„Ç§Áî®„Ç≥„É≥„Éà„É≠„Éº„É´Ôºà„Ç∞„É™„ÉÉ„ÉâÂàÜÂâ≤Ôºâ">
        <div class="zone" id="zoneLeft" aria-label="ÁßªÂãï„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ">
          <div class="stick-base" id="stickBase"></div>
          <div class="stick-nub" id="stickNub"></div>
        </div>
        <div class="zone" id="zoneRight" aria-label="„Ç¢„ÇØ„Ç∑„Éß„É≥„Éú„Çø„É≥">
          <button class="btn a1" id="btnA1" aria-label="ÊîªÊíÉ‚ë† ‚ñ†">‚ñ† <span class="hint">ÊîªÊíÉ1</span></button>
          <button class="btn a2" id="btnA2" aria-label="ÊîªÊíÉ‚ë° ‚ñ≤">‚ñ≤ <span class="hint">ÊîªÊíÉ2</span></button>
          <button class="btn skill" id="btnSkill" aria-label="„Çπ„Ç≠„É´ ‚óè">‚óè <span class="hint">„Çπ„Ç≠„É´</span></button>
          <button class="btn x" id="btnJump" aria-label="„Ç∏„É£„É≥„Éó √ó">√ó <span class="hint">„Ç∏„É£„É≥„Éó</span></button>
        </div>
      </div>
    </div>
  </div>

<script>
/* ================= Prototype v2: „É¨„Ç§„Ç¢„Ç¶„Éà/ÊèèÁîª/ÂÖ•Âäõ ‰øÆÊ≠£ ================= */

const ASSETS = {
  player: {
    idle: ['M1-1.png'],
    move: ['M1-2.png','M1-3.png','M1-4.png'],
    k1_upper: ['K1-1.png'],
    k1_combo1: ['K1-3.png','K1-2.png'],
    k1_combo2: ['K1-3.png','K1-4.png'],
    k2_prep: ['K1-3.png'],
    k2_kick: ['K1-5.png'],
    spin: ['h1.png','h2.png','h3.png','h4.png'],
    hurt: ['K1-3.png'],
    fall: ['M1-2.png'],
    dead: ['M1-1.png']
  },
  enemy: {
    idle: ['EN1-1.png'],
    move: ['EN1-2.png','EN1-3.png'],
    atkS: ['EN1-4.png','EN1-5.png'],
    atkM: ['EN1-4.png','EN1-6.png'],
    hurt: ['EN1-5.png'],
    dead: ['EN1-6.png']
  },
  tile: 'S1.png'
};

// ===== ÁîªÂÉè„Ç≠„É£„ÉÉ„Ç∑„É•
class ImageCache{ constructor(){this.map=new Map()} load(src){return new Promise((res,rej)=>{ if(this.map.has(src)) return res(this.map.get(src)); const img=new Image(); img.src=src; img.onload=()=>{this.map.set(src,img);res(img)}; img.onerror=rej; });}}
const IC=new ImageCache();

// ====== „Ç≠„É£„É≥„Éê„Çπ„ÉªDPRÂØæÂøú
const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d');
const gameWrap=document.getElementById('gameWrap');
let DPR=window.devicePixelRatio||1;
function resizeCanvas(){
  DPR=window.devicePixelRatio||1;
  const w = Math.floor(gameWrap.clientWidth);
  const h = Math.floor(gameWrap.clientHeight);
  canvas.width = Math.max(1, Math.floor(w*DPR));
  canvas.height= Math.max(1, Math.floor(h*DPR));
  ctx.setTransform(DPR,0,0,DPR,0,0); // ‰ª•Âæå„ÅØCSS„Éî„ÇØ„Çª„É´„ÅßÊèè„Åè
  WORLD.viewW=w; WORLD.viewH=h;
  // Âú∞Èù¢‰ΩçÁΩÆ„ÅØÁîªÈù¢‰∏ã„Åã„Çâ„Çø„Ç§„É´È´ò„Åï„Å∂„Çì‰∏ä
  if(_tileH>0){ WORLD.groundY = h - _tileH; } else { WORLD.groundY = Math.floor(h*0.78); }
}
window.addEventListener('resize', resizeCanvas);

// ====== ÂÖ•ÂäõÔºà„Ç®„ÉÉ„Ç∏Ê§úÁü•„Çí‰øùË®ºÔºâ
const Input={ left:false,right:false,up:false,down:false, jumpPressed:false, atk1Pressed:false, atk2Released:false, skillReleased:false, atk2Hold:0, skillHold:0, };
let _atk2Holding=false, _skillHolding=false;

// „Ç≠„Éº
window.addEventListener('keydown',e=>{
  if(e.repeat) return;
  switch(e.key){
    case 'ArrowLeft':case 'a': Input.left=true; break;
    case 'ArrowRight':case 'd': Input.right=true; break;
    case 'ArrowUp':case 'w': Input.up=true; break;
    case 'ArrowDown':case 's': Input.down=true; break;
    case ' ':case 'Enter': Input.jumpPressed=true; break;
    case 'j': Input.atk1Pressed=true; break;
    case 'k': _atk2Holding=true; break;
    case 'l': _skillHolding=true; break;
  }
});
window.addEventListener('keyup',e=>{
  switch(e.key){
    case 'ArrowLeft':case 'a': Input.left=false; break;
    case 'ArrowRight':case 'd': Input.right=false; break;
    case 'ArrowUp':case 'w': Input.up=false; break;
    case 'ArrowDown':case 's': Input.down=false; break;
    case 'k': Input.atk2Released=true; _atk2Holding=false; break;
    case 'l': Input.skillReleased=true; _skillHolding=false; break;
  }
});

// „Çø„ÉÉ„ÉÅÔºö„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ
const stickBase=document.getElementById('stickBase');
const stickNub=document.getElementById('stickNub');
let stickTouchId=null, stickCx=0, stickCy=0;
function stickStart(x,y,id){ stickTouchId=id; const r=stickBase.getBoundingClientRect(); stickCx=r.left+r.width/2; stickCy=r.top+r.height/2; moveStick(x,y); }
function moveStick(x,y){
  const dx=x-stickCx, dy=y-stickCy;
  const max=50, len=Math.hypot(dx,dy), cl=len>max?max/len:1;
  const px=dx*cl, py=dy*cl;
  stickNub.style.transform=`translate(calc(-50% + ${px}px), calc(-50% + ${py}px))`;
  const dead=8;
  Input.left = (dx<-dead);
  Input.right= (dx> dead);
  Input.up   = (dy<-max*0.6);
}
function stickEnd(){ stickTouchId=null; stickNub.style.transform=`translate(-50%,-50%)`; Input.left=Input.right=false; Input.up=false; }
const zoneLeft=document.getElementById('zoneLeft');
zoneLeft.addEventListener('pointerdown',e=>{zoneLeft.setPointerCapture(e.pointerId); stickStart(e.clientX,e.clientY,e.pointerId);});
zoneLeft.addEventListener('pointermove',e=>{if(stickTouchId===e.pointerId) moveStick(e.clientX,e.clientY);});
zoneLeft.addEventListener('pointerup',e=>{if(stickTouchId===e.pointerId) stickEnd();});
zoneLeft.addEventListener('pointercancel',e=>{if(stickTouchId===e.pointerId) stickEnd();});

// „Çø„ÉÉ„ÉÅÔºö„Éú„Çø„É≥ÔºàÊäº„Åó„ÅüÁû¨Èñì/Èõ¢„Åó„ÅüÁû¨ÈñìÔºâ
function bindHold(el, onDown, onUp){ el.addEventListener('pointerdown',e=>{el.setPointerCapture(e.pointerId); onDown();}); el.addEventListener('pointerup',()=>onUp()); el.addEventListener('pointercancel',()=>onUp()); }
bindHold(document.getElementById('btnA1'), ()=>{Input.atk1Pressed=true;}, ()=>{});
bindHold(document.getElementById('btnA2'), ()=>{_atk2Holding=true;}, ()=>{Input.atk2Released=true; _atk2Holding=false;});
bindHold(document.getElementById('btnSkill'), ()=>{_skillHolding=true;}, ()=>{Input.skillReleased=true; _skillHolding=false;});
bindHold(document.getElementById('btnJump'), ()=>{Input.jumpPressed=true;}, ()=>{});

// ====== Â∞è„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;

// ====== „Ç¢„Éã„É°/„Çπ„Éó„É©„Ç§„ÉàÔºà„Çπ„Ç±„Éº„É™„É≥„Ç∞ÂØæÂøúÔºâ
class Anim{ constructor(frames,fps=8,loop=true){this.frames=frames;this.fps=fps;this.loop=loop;this.t=0;this.idx=0;} reset(){this.t=0;this.idx=0;} update(dt){this.t+=dt;const sp=1/this.fps;while(this.t>=sp){this.t-=sp;this.idx++;if(this.loop)this.idx%=this.frames.length;else this.idx=Math.min(this.idx,this.frames.length-1);}} frame(){return this.frames[this.idx|0];}}
class Sprite{
  constructor(seq,fps=8,loop=true){this.anim=new Anim(seq,fps,loop);}
  set(seq,fps=8,loop=true){this.anim=new Anim(seq,fps,loop);}
  update(dt){this.anim.update(dt);}
  async drawScaled(x,y,w,h,flip=false,alpha=1,tint=null,anchor='bottom'){
    const src=this.anim.frame(); const img=await IC.load(src);
    const sx = flip ? -w : w;
    const ox = flip ? x+w : x;
    const oy = (anchor==='bottom') ? y+(h-img.height*(h/img.height)) : y;
    ctx.save(); ctx.globalAlpha=alpha; ctx.translate(ox, oy);
    if(flip) ctx.scale(-1,1);
    ctx.drawImage(img, 0, h-img.height*(h/img.height), w, h);
    if(tint){ ctx.globalCompositeOperation='multiply'; ctx.fillStyle=tint; ctx.fillRect(0, h-img.height*(h/img.height), w, h); ctx.globalCompositeOperation='source-over'; }
    ctx.restore();
  }
}

// ====== ‰∏ñÁïå„Éª„Ç´„É°„É©„ÉªÊèèÁîª„Çµ„Ç§„Ç∫
const WORLD={ gravity:2000, groundY:380, tileW:64, tileH:64, viewW:800, viewH:480 };
const Camera={ x:0, y:0, lerp:0.14 };
const DISP={ playerW:64, playerH:64, enemyW:64, enemyH:64 }; // ‚òÖ Ë°®Á§∫„Çµ„Ç§„Ç∫Ôºà„Åì„Åì„ÇíÂ§â„Åà„Çå„Å∞Â§ß„Åç„Åï„ÇíÁµ±‰∏Ä„Åß„Åç„Åæ„ÅôÔºâ

let _tileH=0, _tileW=0;

// ====== „Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£
class HurtFlash{ constructor(){this.t=0;} trigger(){this.t=0.2;} update(dt){this.t=Math.max(0,this.t-dt);} color(){return this.t>0?'rgb(255,80,80)':null;}}

class Entity{
  constructor(x,y,w,h){ this.pos={x,y}; this.vel={x:0,y:0}; this.onGround=false; this.dir=1; this.hp=10; this.maxhp=10; this.dead=false; this.alpha=1; this.spinDead=0; this.state='idle'; this.timer=0; this.sprite=null; this.w=w; this.h=h; this.flash=new HurtFlash(); this.damageWindow=null; this.team='neutral'; }
  aabb(){ return {x:this.pos.x, y:this.pos.y, w:this.w, h:this.h}; }
  overlap(a,b){ return !(a.x+a.w<=b.x || b.x+b.w<=a.x || a.y+a.h<=b.y || b.y+b.h<=a.y); }
  knockback(fromDir,str=200,lift=240){ this.vel.x = fromDir>0 ? -str : str; this.vel.y = -lift; }
  applyDamage(dmg,fromDir){ if(this.dead) return; this.hp -= dmg; this.flash.trigger(); this.knockback(fromDir,250,240); if(this.hp<=0) this.die(); }
  die(){ this.dead=true; this.state='dead'; this.spinDead=12; }
  updatePhysics(dt){
    this.vel.y += WORLD.gravity*dt;
    this.pos.x += this.vel.x*dt; this.pos.y += this.vel.y*dt;
    const gy=WORLD.groundY;
    if(this.pos.y + this.h >= gy){ this.pos.y = gy - this.h; this.vel.y=0; this.onGround=true; } else { this.onGround=false; }
  }
  async draw(scaleW,scaleH){
    const tint=this.flash.color();
    if(this.sprite) await this.sprite.drawScaled(this.pos.x, this.pos.y, scaleW, scaleH, this.dir<0, this.alpha, tint, 'bottom');
  }
  frameUpdate(dt){ this.flash.update(dt); if(this.sprite) this.sprite.update(dt); }
}

class Player extends Entity{
  constructor(x,y){ super(x,y,DISP.playerW,DISP.playerH);
    this.team='player'; this.maxhp=1000; this.hp=this.maxhp; this.lives=3;
    this.moveSpeed=260; this.jumpPower=720; this.controlLock=0; this.sprite=new Sprite(ASSETS.player.idle,4,true);
    this.comboStep=0;
  }
  logic(dt){
    // Èï∑Êäº„ÅóÁ©çÁÆó
    if(_atk2Holding) Input.atk2Hold+=dt; else Input.atk2Hold=0;
    if(_skillHolding) Input.skillHold+=dt; else Input.skillHold=0;

    const canMove = this.controlLock<=0 && this.state!=='skill' && this.state!=='atk1' && this.state!=='atk2';

    if(canMove){
      const mx=(Input.right?1:0)-(Input.left?1:0);
      this.vel.x=mx*this.moveSpeed;
      if(mx!==0) this.dir=mx;
    } else { this.vel.x=0; }

    if(Input.jumpPressed && this.onGround && canMove){ this.vel.y=-this.jumpPower; this.onGround=false; }
    Input.jumpPressed=false;

    if(canMove){ Math.abs(this.vel.x)>1 ? this.setAnim('move') : this.setAnim('idle'); }

    // ÊîªÊíÉÔºà„Ç®„ÉÉ„Ç∏Ê§úÁü•„ÅßÁ¢∫ÂÆüÁô∫ÁÅ´Ôºâ
    if(Input.atk1Pressed && this.state!=='atk1' && this.state!=='atk2' && this.state!=='skill'){
      if(this.comboStep===0) this.doAtk1Upper();
      else if(this.comboStep===1) this.doAtk1Combo1();
      else if(this.comboStep===2) this.doAtk1Combo2();
    }
    Input.atk1Pressed=false;

    if(Input.atk2Released && this.state!=='atk1' && this.state!=='atk2' && this.state!=='skill'){
      const charged = Input.atk2Hold>=0.5;
      this.doAtk2(charged);
    }
    Input.atk2Released=false;

    if(Input.skillReleased && this.state!=='atk1' && this.state!=='atk2' && this.state!=='skill'){
      const long = Input.skillHold>=0.5;
      this.doSkillSpin(long);
    }
    Input.skillReleased=false;

    if(this.pos.y>WORLD.viewH+200 && !this.dead) this.respawn();

    if(this.controlLock>0) this.controlLock=Math.max(0,this.controlLock-dt);
  }
  setAnim(kind){
    switch(kind){
      case 'idle': this.sprite.set(ASSETS.player.idle, 4, true); break;
      case 'move': this.sprite.set(ASSETS.player.move, 10, true); break;
      case 'hurt': this.sprite.set(ASSETS.player.hurt, 8, false); break;
      case 'fall': this.sprite.set(ASSETS.player.fall, 6, true); break;
      case 'dead': this.sprite.set(ASSETS.player.dead, 2, false); break;
    }
  }
  makeHitbox(w=46,h=46,ox=0,oy=0){ return {x:this.pos.x+ox,y:this.pos.y+oy,w,h}; }

  doAtk1Upper(){ // ÂçòÊäº„Åó„Ç¢„ÉÉ„Éë„Éº dmg5
    this.state='atk1'; this.controlLock=0.22; this.comboStep=1; this.sprite.set(ASSETS.player.k1_upper,12,false);
    this.vel.x=this.dir*120;
    this.damageWindow={...this.makeHitbox(40,this.h, this.dir>0?this.w*0.5:-this.w*0.35, 0), dmg:5, team:'player', t:0.16};
    setTimeout(()=>{this.damageWindow=null;},160);
    setTimeout(()=>{this.state='idle';},220);
  }
  doAtk1Combo1(){ // Êßã„Åà0.2‚ÜíÁ™ÅÈÄ≤0.2 dmg8
    this.state='atk1'; this.controlLock=0.42; this.comboStep=2; this.sprite.set(ASSETS.player.k1_combo1,8,false);
    setTimeout(()=>{ this.vel.x=this.dir*260; this.damageWindow={...this.makeHitbox(44,this.h, this.dir>0?this.w*0.55:-this.w*0.4, 0), dmg:8, team:'player', t:0.2}; setTimeout(()=>{this.damageWindow=null;},200); },200);
    setTimeout(()=>{this.state='idle';},400);
  }
  doAtk1Combo2(){ // Êßã„Åà0.2‚ÜíÂøÖÊÆ∫„Ç≠„ÉÉ„ÇØ0.2 dmg10
    this.state='atk1'; this.controlLock=0.42; this.comboStep=0; this.sprite.set(ASSETS.player.k1_combo2,8,false);
    setTimeout(()=>{ this.vel.x=this.dir*280; this.damageWindow={...this.makeHitbox(46,this.h, this.dir>0?this.w*0.56:-this.w*0.42, 0), dmg:10, team:'player', t:0.2}; setTimeout(()=>{this.damageWindow=null;},200); },200);
    setTimeout(()=>{this.state='idle';},400);
  }
  doAtk2(charged){ // Êßã„Åà‚ÜíËπ¥„Çä‰∏ä„Åí
    this.state='atk2'; this.controlLock=(charged?1.0:0.5)+0.3; this.sprite.set(ASSETS.player.k2_prep,12,true);
    const prepMs = charged?1000:500;
    setTimeout(()=>{ this.sprite.set(ASSETS.player.k2_kick,18,false); this.vel.x=this.dir*160;
      const dmg=charged?26:15; this.damageWindow={...this.makeHitbox(42,this.h+8, this.dir>0?this.w*0.5:-this.w*0.36, -8), dmg, team:'player', t:0.3};
      setTimeout(()=>{this.damageWindow=null; this.state='idle';},300);
    }, prepMs);
  }
  async doSkillSpin(long){
    this.state='skill'; const rounds=long?4:2; const dmg=long?40:25; this.controlLock=rounds*(4/18); this.vel.x=0; this.sprite.set(ASSETS.player.spin,18,true);
    const hitEvery=80; const totalMs=Math.round((4*rounds/18)*1000);
    const timer=setInterval(()=>{ this.damageWindow={...this.makeHitbox(this.w+8,this.h+8, this.dir>0?16:-16, -4), dmg, team:'player', t:hitEvery/1000}; setTimeout(()=>{this.damageWindow=null;}, hitEvery-10); }, hitEvery);
    setTimeout(()=>{ clearInterval(timer); this.state='idle'; }, totalMs);
  }
  respawn(){ this.lives=Math.max(0,this.lives-1); this.hp=this.maxhp; this.dead=false; this.alpha=1; this.spinDead=0; this.pos.x=80; this.pos.y=WORLD.groundY-this.h; this.vel.x=this.vel.y=0; this.state='idle'; this.comboStep=0; updateHUD(); }
}

class Enemy extends Entity{
  constructor(x,y){ super(x,y,DISP.enemyW,DISP.enemyH); this.team='enemy'; this.maxhp=500; this.hp=this.maxhp; this.moveSpeed=200; this.sprite=new Sprite(ASSETS.enemy.idle,4,true); this.aiCooldown=0; }
  logic(dt,player){
    if(this.dead) return;
    this.aiCooldown=Math.max(0,this.aiCooldown-dt);
    const dx=player.pos.x-this.pos.x; this.dir=dx>0?1:-1; const distance=Math.abs(dx);
    if(distance>90){ this.vel.x=this.dir*this.moveSpeed*0.6; this.sprite.set(ASSETS.enemy.move,8,true); }
    else{ this.vel.x=0; this.sprite.set(ASSETS.enemy.idle,6,true);
      if(this.aiCooldown<=0){ this.doAtkSmall(); setTimeout(()=>this.doAtkMid(player),260); this.aiCooldown=1.3; }
    }
    if(this.onGround && Math.random()<0.002) this.vel.y=-680;
  }
  doAtkSmall(){ this.state='atkS'; this.sprite.set(ASSETS.enemy.atkS,10,false); this.vel.x=this.dir*160;
    this.damageWindow={...this.aabb(), x:this.pos.x+(this.dir>0?this.w*0.44:-this.w*0.44), w:46, h:this.h, dmg:4, team:'enemy', t:0.18};
    setTimeout(()=>{this.damageWindow=null; this.state='idle';},180);
  }
  doAtkMid(){ this.state='atkM'; this.sprite.set(ASSETS.enemy.atkM,10,false);
    this.damageWindow={...this.aabb(), x:this.pos.x+(this.dir>0?this.w*0.44:-this.w*0.44), w:46, h:this.h, dmg:9, team:'enemy', t:0.22, lift:true};
    setTimeout(()=>{this.damageWindow=null; this.state='idle';},220);
  }
}

// ====== „ÉØ„Éº„É´„Éâ/„Ç´„É°„É©
const player=new Player(80, 0);
const enemy =new Enemy(460, 0);
const ents=[player,enemy];

function applyHit(attacker,target){
  if(!attacker.damageWindow||target.dead) return;
  const w=attacker.damageWindow, box={x:w.x,y:w.y,w:w.w,h:w.h};
  if(target.overlap(box,target.aabb())){
    target.applyDamage(w.dmg, attacker.dir);
    if(w.lift) target.vel.y=-520;
    attacker.damageWindow=null;
  }
}
function updateCombat(){ applyHit(player,enemy); applyHit(enemy,player); }
function updateCamera(){ const tx=player.pos.x - WORLD.viewW*0.35; Camera.x=lerp(Camera.x, Math.max(0,tx), Camera.lerp); }

// ====== Âú∞Èù¢„Å®ËÉåÊôØ
async function drawGround(){
  const img=await IC.load(ASSETS.tile);
  if(!_tileW){ _tileW=img.width; _tileH=img.height; resizeCanvas(); } // ÂàùÂõûÂèñÂæó„ÅßÂú∞Èù¢Ë™øÊï¥
  const tileW=_tileW, tileH=_tileH;
  const y=WORLD.groundY - tileH;
  const start=Math.floor(Camera.x/tileW)-1, end=Math.ceil((Camera.x+WORLD.viewW)/tileW)+1;
  for(let i=start;i<=end;i++){ const sx=i*tileW - Camera.x; ctx.drawImage(img, sx, y, tileW, tileH); }
  const g=ctx.createLinearGradient(0,0,0,canvas.height/DPR); g.addColorStop(0,'#08111f'); g.addColorStop(1,'#0a0f1a');
  ctx.globalCompositeOperation='destination-over'; ctx.fillStyle=g; ctx.fillRect(0,0,WORLD.viewW,WORLD.viewH); ctx.globalCompositeOperation='source-over';
}

// ====== HUD
const hpFill=document.getElementById('hpFill'); const livesEl=document.getElementById('lives'); const timerEl=document.getElementById('timer'); let timeAcc=0;
function updateHUD(){ const r=clamp(player.hp/player.maxhp,0,1)*100; hpFill.style.width=r.toFixed(1)+'%'; livesEl.textContent=player.lives; }
function fmt(t){ const s=String(Math.floor(t%60)).padStart(2,'0'); const m=String(Math.floor(t/60)).padStart(2,'0'); return `${m}:${s}`; }

// ====== „É´„Éº„Éó
let prev=performance.now();
function step(t){
  const dt=Math.min(0.033, (t-prev)/1000); prev=t;
  if(_atk2Holding) Input.atk2Hold+=dt;
  if(_skillHolding) Input.skillHold+=dt;

  player.logic(dt); enemy.logic(dt,player);
  ents.forEach(e=>{ e.updatePhysics(dt); e.frameUpdate(dt); });

  updateCombat(); updateCamera();
  timeAcc+=dt; timerEl.textContent=fmt(timeAcc); updateHUD();

  ctx.clearRect(0,0,WORLD.viewW,WORLD.viewH);
  ctx.save(); ctx.translate(-Camera.x,0);
  drawGround();
  if(!player.onGround && player.state==='idle') player.setAnim('fall');
  for(const e of ents){
    if(e.dead){
      e.spinDead=Math.max(0, e.spinDead-dt*12); e.alpha=Math.max(0, e.alpha-dt*0.8);
      e.vel.x += (e.dir*60)*dt; e.vel.y += WORLD.gravity*0.8*dt;
      ctx.save(); ctx.translate(e.pos.x+e.w/2, e.pos.y+e.h/2); ctx.rotate((1-e.spinDead)*18); ctx.translate(-e.w/2,-e.h/2);
      await e.sprite.drawScaled(0,0,e.w,e.h,false,e.alpha,null,'bottom'); ctx.restore();
    }else{
      await e.draw(e.w,e.h);
    }
  }
  ctx.restore();
  requestAnimationFrame(step);
}

// ====== „ÉÄ„É°„Éº„Ç∏ÊôÇ„ÅÆËøΩÂä†ÊºîÂá∫Ôºà„Éé„ÉÉ„ÇØ„Éê„ÉÉ„ÇØ„ÅØ applyDamage ÂÜÖÔºâ
const _applyDamage=Entity.prototype.applyDamage;
Entity.prototype.applyDamage=function(dmg,fromDir){ _applyDamage.call(this,dmg,fromDir);
  if(this.hp<=0 && this.team==='enemy'){ this.vel.x += fromDir>0?320:-320; this.vel.y=-520; }
  if(this.team==='player') updateHUD();
};

// ====== Ëµ∑Âãï
(async function init(){
  // ÁîªÂÉè„É≠„Éº„Éâ
  const list=[]; const push=a=>a.forEach(s=>list.push(s));
  push(ASSETS.player.idle); push(ASSETS.player.move); push(ASSETS.player.k1_upper); push(ASSETS.player.k1_combo1); push(ASSETS.player.k1_combo2);
  push(ASSETS.player.k2_prep); push(ASSETS.player.k2_kick); push(ASSETS.player.spin); push(ASSETS.player.hurt); push(ASSETS.player.fall); push(ASSETS.player.dead);
  push(ASSETS.enemy.idle); push(ASSETS.enemy.move); push(ASSETS.enemy.atkS); push(ASSETS.enemy.atkM); push(ASSETS.enemy.hurt); push(ASSETS.enemy.dead); list.push(ASSETS.tile);
  await Promise.all(list.map(s=>IC.load(s)));

  resizeCanvas();
  // ÂàùÊúüÈÖçÁΩÆÔºöÂú∞Èù¢‰∏ä
  player.pos.y=WORLD.groundY - player.h; enemy.pos.y=WORLD.groundY - enemy.h;

  requestAnimationFrame(t=>{ prev=t; requestAnimationFrame(step); });
})();

// iOS„Éï„Ç©„Éº„Ç´„ÇπÁ∂≠ÊåÅ
document.addEventListener('touchstart',()=>{}, {passive:false});
</script>
</body>
</html>
