<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, maximum-scale=1" />
<title>MOB Side Action – Rev14 (Full)</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{ --stage-w:420px; --stage-h:720px; --hud-bg:#0b0f17cc; --fg:#e9eef7; --grid-gap:10px; }
  html,body{height:100%;margin:0;background:#0a0d13;color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;overscroll-behavior:none}
  html,body{-webkit-user-select:none;-webkit-touch-callout:none;user-select:none}
  *{box-sizing:border-box}
  #root{position:fixed;inset:env(safe-area-inset-top,0) env(safe-area-inset-right,0) env(safe-area-inset-bottom,0) env(safe-area-inset-left,0);display:grid;place-items:center;padding:10px}
  #phone{width:var(--stage-w);height:var(--stage-h);position:relative;overflow:hidden;background:#060910;border:1px solid #0f1726;border-radius:20px;box-shadow:0 12px 48px rgba(0,0,0,.55);touch-action:none}
  .grid{position:absolute;inset:0;display:grid;grid-template-rows: 1fr 220px;gap:var(--grid-gap);padding:var(--grid-gap)}
  .gamewrap{position:relative;border-radius:14px;overflow:hidden;background:#05070c;outline:1px solid #0e1522}
  canvas#game{display:block;width:100%;height:100%}
  .controls{position:relative;border-radius:14px;background:var(--hud-bg);outline:1px solid #0e1522;backdrop-filter: blur(6px);padding:12px;display:grid;grid-template-columns: 1fr 1fr;gap:12px}
  .stickArea{position:relative;border-radius:12px;background:#0a121f;outline:1px solid #152033;display:grid;place-items:center;touch-action:none}
  .stick{width:120px;height:120px;border-radius:50%;background:#0d1828;outline:2px solid #22324d;position:relative}
  .stickThumb{width:64px;height:64px;border-radius:50%;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#1a2a45;outline:2px solid #2e4a73;box-shadow: inset 0 0 0 4px #0c1422}
  .buttons{display:grid;grid-template-columns: repeat(2,1fr);grid-template-rows: repeat(2,1fr);gap:12px}
  .btn{border:none;border-radius:14px;background:#0d1828;outline:2px solid #22324d;color:var(--fg);font-size:26px;display:grid;place-items:center;touch-action:none;box-shadow:inset 0 -4px 0 rgba(255,255,255,.04);transition:opacity .15s ease}
  .btn:active{transform:scale(.98)}
  .btn[disabled]{opacity:.35;pointer-events:none}
  .btn.attack1{background:#112033} .btn.attack2{background:#1a2436} .btn.skill{background:#132a22} .btn.jump{background:#2a1a1a}
  header.hud{position:absolute;left:0;right:0;top:0;padding:10px 14px;display:flex;gap:10px;align-items:center;z-index:10;pointer-events:none}
  .chip{background:var(--hud-bg);outline:1px solid #0e1522;border-radius:12px;padding:6px 10px;font-weight:600;font-size:12px;display:flex;gap:8px;align-items:center}
  .bar{--w:160px;--h:10px;width:var(--w);height:var(--h);border-radius:999px;outline:1px solid #1a263d;background:#0a1220;position:relative;overflow:hidden}
  .bar>i{position:absolute;left:0;top:0;bottom:0;border-radius:999px;background:linear-gradient(90deg,#ff9a9e,#ff6b6b)}
  .timer{margin-left:auto}
  .overhead{position:absolute;left:50%;transform:translateX(-50%);display:none;gap:6px;align-items:center;pointer-events:none}
  .gauge{width:64px;height:6px;border-radius:999px;outline:1px solid #1a263d;background:#0a1220;overflow:hidden}
  .gauge>i{display:block;height:100%;width:0%;background:linear-gradient(90deg,#69d0ff,#a0ffe6)}
  @media (max-height: 720px){ :root{ --stage-h: 650px; } }
</style>
</head>
<body>
  <div id="root">
    <div id="phone">
      <div class="grid">
        <div class="gamewrap">
          <header class="hud">
            <div class="chip">残機 <strong id="lives">3</strong></div>
            <div class="chip">HP <span class="bar"><i id="hpfill" style="width:100%"></i></span> <strong id="hpnum">1000</strong></div>
            <div class="chip timer">Time <strong id="time">00:00</strong></div>
          </header>
          <canvas id="game" width="420" height="480" aria-label="Game Canvas"></canvas>
        </div>
        <div class="controls">
          <div class="stickArea" id="stickArea" aria-label="Move Stick"><div class="stick"><div class="stickThumb" id="stickThumb"></div></div></div>
          <div class="buttons">
            <button class="btn attack1" id="btnA1" aria-label="攻撃① ■">■</button>
            <button class="btn attack2" id="btnA2" aria-label="攻撃② ▲">▲</button>
            <button class="btn skill"   id="btnSK" aria-label="スキル ●">●</button>
            <button class="btn jump"    id="btnJP" aria-label="ジャンプ ×">×</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ===================== Rev14 (Full) ======================
 - 既存敵を「突進攻撃」AIへ：中距離から突進、攻撃後2sクール（連撃なし）、CT中はバックステップ
 - 敵の頭上にHPバー表示
 - プレイヤーと敵の「すり抜け防止」：X方向の重なりを分離
 - 新敵「ワルMOB」追加：HP100 / 攻10 / 低頻度射撃（teki7.png弾）
 - 既存のUI/操作/スキルCD等は維持
========================================================== */
(function(){
  'use strict';
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const now=()=>performance.now();

  /* Effects */
  class Effects{
    constructor(){ this.sparks=[]; this.shakeT=0; this.shakeAmp=0; this.hitstop=0; }
    addSpark(x,y,strong=false){
      this.sparks.push({x,y,t:0,life:0.18,strong});
      if(strong){ this.shake(0.14,8); this.hitstop=Math.max(this.hitstop,0.08); }
      else{ this.shake(0.08,4); this.hitstop=Math.max(this.hitstop,0.05); }
      if(navigator.vibrate) navigator.vibrate(strong?18:10);
    }
    shake(dur,amp){ this.shakeT=Math.max(this.shakeT,dur); this.shakeAmp=Math.max(this.shakeAmp,amp); }
    getCamOffset(){ if(this.shakeT>0){ const a=this.shakeAmp*this.shakeT; return {x:(Math.random()*2-1)*a,y:(Math.random()*2-1)*a*0.6}; } return {x:0,y:0}; }
    update(dt){ if(this.hitstop>0)this.hitstop=Math.max(0,this.hitstop-dt); if(this.shakeT>0)this.shakeT=Math.max(0,this.shakeT-dt); for(const s of this.sparks){ s.t+=dt; } this.sparks=this.sparks.filter(s=>s.t<s.life); }
    draw(ctx,world){
      for(const s of this.sparks){
        const p=s.t/s.life; const w=s.strong?2:1; ctx.save();
        ctx.translate(s.x-world.camX, s.y-world.camY); ctx.globalAlpha=1-p; ctx.strokeStyle="#fff"; ctx.lineWidth=w;
        ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(0,6); ctx.stroke();
        ctx.restore();
      }
    }
  }

  class Assets{
    constructor(){ this.images=new Map(); }
    load(srcs){ return Promise.all(srcs.map(src=>new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>{this.images.set(src,img);res();}; img.onerror=rej; img.src=src; }))); }
    img(n){ return this.images.get(n); }
  }

  class Input{
    constructor(){
      this.left=0; this.right=0; this.jump=false;
      this.btn={a1:false,a2:false,skill:false};
      this.prev={a1:false,a2:false,skill:false};
      this.edge={a1:false, a2Release:false, skillRelease:false};
      this.pulseRelease={a2:false,skill:false};
      this.attack2Charging=false; this.skillCharging=false;
      this.attack2ChargeT=0; this.skillChargeT=0;
      this._initKeyboard(); this._initTouch();
    }
    _initKeyboard(){
      addEventListener('keydown',(e)=>{
        const k=e.key;
        if(k==='ArrowLeft'||k==='a'||k==='A') this.left=1;
        if(k==='ArrowRight'||k==='d'||k==='D') this.right=1;
        if(k===' '||k==='w'||k==='W'||k==='ArrowUp') this.jump=true;
        if(k==='j'||k==='J') this.btn.a1=true;
        if(k==='k'||k==='K'){ if(!this.btn.a2){ this.btn.a2=true; this.attack2Charging=true; this.attack2ChargeT=0; } }
        if(k==='l'||k==='L'){ if(!this.btn.skill){ this.btn.skill=true; this.skillCharging=true; this.skillChargeT=0; } }
      },{passive:false});
      addEventListener('keyup',(e)=>{
        const k=e.key;
        if(k==='ArrowLeft'||k==='a'||k==='A') this.left=(this.right?1:0);
        if(k==='ArrowRight'||k==='d'||k==='D') this.right=(this.left?1:0);
        if(k==='j'||k==='J') this.btn.a1=false;
        if(k==='k'||k==='K'){ if(this.btn.a2){ this.btn.a2=false; this.attack2Charging=false; this.pulseRelease.a2=true; } }
        if(k==='l'||k==='L'){ if(this.btn.skill){ this.btn.skill=false; this.skillCharging=false; this.pulseRelease.skill=true; } }
      },{passive:false});
    }
    _initTouch(){
      const stickArea=document.getElementById('stickArea');
      const thumb=document.getElementById('stickThumb');
      let stickId=-1, origin=null;
      const updateStick=t=>{
        if(!origin) return;
        const dx=t.clientX-origin.x, dy=t.clientY-origin.y;
        const rMax=40, len=Math.hypot(dx,dy);
        const nx=(len>rMax? dx/len*rMax:dx);
        const ny=(len>rMax? dy/len*rMax:dy);
        thumb.style.left=`calc(50% + ${nx}px)`; thumb.style.top=`calc(50% + ${ny}px)`;
        this.left =(nx<-8)?1:0; this.right=(nx>8)?1:0;
      };
      const onStart=e=>{
        for(const t of e.changedTouches){
          const r=stickArea.getBoundingClientRect();
          if(t.clientX>=r.left&&t.clientX<=r.right&&t.clientY>=r.top&&t.clientY<=r.bottom){
            stickId=t.identifier; origin={x:r.left+r.width/2,y:r.top+r.height/2}; updateStick(t);
          }
        }
      };
      const onMove=e=>{ for(const t of e.changedTouches){ if(t.identifier===stickId) updateStick(t); } };
      const onEnd =e=>{ for(const t of e.changedTouches){ if(t.identifier===stickId){ stickId=-1; origin=null; thumb.style.left='50%'; thumb.style.top='50%'; this.left=0; this.right=0; } } };
      stickArea.addEventListener('touchstart',e=>{e.preventDefault();onStart(e);},{passive:false});
      stickArea.addEventListener('touchmove', e=>{e.preventDefault();onMove(e); },{passive:false});
      stickArea.addEventListener('touchend',  e=>{e.preventDefault();onEnd(e);  },{passive:false});
      stickArea.addEventListener('touchcancel',e=>{e.preventDefault();onEnd(e);},{passive:false});

      const bind=(id,onDown,onUp)=>{
        const el=document.getElementById(id);
        el.addEventListener('pointerdown',e=>{e.preventDefault(); onDown(); el.setPointerCapture?.(e.pointerId);});
        el.addEventListener('pointerup',  e=>{e.preventDefault(); onUp(); el.releasePointerCapture?.(e.pointerId);});
        el.addEventListener('pointercancel',()=>{ onUp(); });
        el.addEventListener('touchstart',e=>{e.preventDefault(); onDown();},{passive:false});
        el.addEventListener('touchend',  e=>{e.preventDefault(); onUp();},{passive:false});
      };
      bind('btnA1', ()=>{ this.btn.a1=true; }, ()=>{ this.btn.a1=false; });
      bind('btnA2', ()=>{ if(!this.btn.a2){ this.btn.a2=true; this.attack2Charging=true; this.attack2ChargeT=0; } },
                     ()=>{ if(this.btn.a2){ this.btn.a2=false; this.attack2Charging=false; this.pulseRelease.a2=true; } });
      bind('btnSK', ()=>{ if(!this.btn.skill){ this.btn.skill=true; this.skillCharging=true; this.skillChargeT=0; } },
                     ()=>{ if(this.btn.skill){ this.btn.skill=false; this.skillCharging=false; this.pulseRelease.skill=true; } });
      bind('btnJP', ()=>{ this.jump=true; }, ()=>{});
    }
    consumeJump(){ const j=this.jump; this.jump=false; return j; }
    beginFrame(){
      this.edge.a1 =  this.btn.a1 && !this.prev.a1;
      this.edge.a2Release    = (!this.btn.a2 && this.prev.a2) || this.pulseRelease.a2;
      this.edge.skillRelease = (!this.btn.skill && this.prev.skill) || this.pulseRelease.skill;
      this.pulseRelease.a2=false; this.pulseRelease.skill=false;
      this.prev.a1=this.btn.a1; this.prev.a2=this.btn.a2; this.prev.skill=this.btn.skill;
    }
  }

  /* Constants */
  const GRAV=2000, MOVE=260, JUMP_V=760, MAX_FALL=1200;
  const EN_MOVE=140, GROUND_TOP_Y=360, FOOT_PAD=2;

  const rectsOverlap=(a,b)=>Math.abs(a.x-b.x)*2 < (a.w+b.w) && Math.abs(a.y-b.y)*2 < (a.h+b.h);

  /* Base Character */
  class CharacterBase{
    constructor(w,h){
      this.w=w; this.h=h; this.x=0; this.y=0; this.vx=0; this.vy=0;
      this.face=1; this.onGround=false; this.state='idle'; this.animT=0;
      this.hp=100; this.maxhp=100; this.dead=false; this.deathT=0; this.invulnT=0;
      this.spinAngle=0; this.spinSpeed=0; this.fade=1;
    }
    aabb(){ return {x:this.x, y:this.y, w:this.w*0.6, h:this.h*0.8}; }
    hurt(amount, dir, opts={}, effects){
      if(this.invulnT>0||this.dead) return false;
      this.hp=Math.max(0,this.hp-amount);
      const kbMul = opts.kbMul||1, kbuMul=opts.kbuMul||1;
      const baseKb  = 140 + amount*12;
      const baseKbu = opts.lift ? 360 : (amount>=15? 300 : 230);
      this.vx = dir * baseKb * kbMul;
      this.vy = - baseKbu * kbuMul;
      this.x += dir * 4; this.face = -dir;
      this.state='hurt'; this.animT=0; this.invulnT=0.28;
      if(effects) effects.addSpark(this.x, this.y-10, amount>=15);

      if(this.hp<=0){
        this.dead=true;
        this.vx = dir * (520 * (kbMul||1));
        this.vy = - (520 * (kbuMul||1));
        this.spinSpeed = 18; this.deathT = 0; this.fade = 1;
      }
      return true;
    }
    updatePhysics(dt){
      this.vy = Math.min(this.vy + GRAV*dt, MAX_FALL);
      this.x += this.vx*dt; this.y += this.vy*dt;
      const top=Math.floor(GROUND_TOP_Y);
      if(this.y + this.h/2 >= top + FOOT_PAD){
        this.y = top - this.h/2 + FOOT_PAD; this.vy=0; this.onGround=true;
      } else this.onGround=false;
      if(this.invulnT>0) this.invulnT=Math.max(0,this.invulnT-dt);
      if(this.dead){ this.deathT += dt; this.spinAngle += this.spinSpeed*dt; this.fade = clamp(1 - this.deathT/1.2, 0, 1); }
    }
    drawHPBar(ctx,world){
      // 小さいHPバー
      const w=36, h=4, x=this.x-world.camX, y=this.y-world.camY - this.h/2 - 10;
      const ratio=Math.max(0,this.hp/this.maxhp);
      ctx.save();
      ctx.translate(x,y);
      ctx.fillStyle='rgba(10,18,32,.7)'; ctx.fillRect(-w/2,-h/2,w,h);
      ctx.strokeStyle='#1a263d'; ctx.lineWidth=1; ctx.strokeRect(-w/2,-h/2,w,h);
      ctx.fillStyle='#7dd3fc'; ctx.fillRect(-w/2+1,-h/2+1,(w-2)*ratio,h-2);
      ctx.restore();
    }
  }

  /* Player */
  class Player extends CharacterBase{
    constructor(assets, world, effects){
      super(56,64);
      this.assets=assets; this.world=world; this.effects=effects;
      this.x=100; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD;
      this.hp=1000; this.maxhp=1000; this.lives=3;

      this.comboStep=0; this.comboGraceT=0; this.comboGraceMax=0.24; this.bufferA1=false;
      this.queueA2=null; this.queueSK=null;

      this.actionAir=false; this.actionAirVx=0; this.airVXCap=40; this.airDamp=0.90;

      this.a2LockoutT=0;
      this.skillCDT=0;

      this.frames={
        idle:['M1-1.png'], walk:['M1-2.png','M1-3.png','M1-4.png'],
        k1prep:'K1-3.png', k1a:'K1-1.png', k1b:'K1-2.png', k1c:'K1-4.png',
        k2prep:'K1-3.png', k2:'K1-5.png', spin:['h1.png','h2.png','h3.png','h4.png'],
      };

      // 頭上ゲージ（A2/スキル充電表示）
      this.overhead=this._createOverheadGauge();
      document.querySelector('.gamewrap').appendChild(this.overhead.root);
    }
    _getFramePath(key, i=0){ const v=this.frames[key]; return Array.isArray(v)? v[Math.max(0,Math.min(v.length-1,i))] : v; }
    _imgByKey(key,i=0){ return this.world.assets.img(this._getFramePath(key,i)); }

    _createOverheadGauge(){
      const root=document.createElement('div'); root.className='overhead';
      const g=document.createElement('div'); g.className='gauge';
      const i=document.createElement('i'); g.appendChild(i);
      const label=document.createElement('span'); label.style.fontSize='10px'; label.style.color='#b8c7e3';
      root.appendChild(g); root.appendChild(label);
      return {root, gauge:g, fill:i, label};
    }
    _posOverhead(){
      const w=this.world, headY=this.y-this.h/2-10;
      this.overhead.root.style.left=((this.x-w.camX)*w.screenScaleX)+'px';
      this.overhead.root.style.bottom=(w.gameH-(headY-w.camY))*w.screenScaleY+'px';
    }
    _showGauge(show, text='', ratio=0){
      this.overhead.root.style.display=show?'flex':'none';
      this.overhead.label.textContent=text; this.overhead.fill.style.width=((ratio*100)|0)+'%';
    }

    currentHitbox(){
      if(!(this.state==='atk'||this.state==='skill') || !this._actionSeq) return null;
      const cur=this._actionSeq[this._actionIndex]; if(!cur) return null;
      if(this.state==='skill'){
        const W=80,H=60; const x=this.x + this.face*(this.w*0.2);
        return {x, y:this.y, w:W, h:H, power:cur.power||0, dir:this.face, lift:cur.lift||0, kbMul:cur.kbMul||1.6, kbuMul:cur.kbuMul||1.3};
      }
      if(cur.kind==='hit' || cur.kind==='sp'){
        const w=50, h=40, x=this.x + this.face*(this.w*0.3 + w*0.5), y=this.y - 6;
        return {x,y,w,h, power:cur.power||0, dir:this.face, lift:cur.lift||0, kbMul:cur.kbMul||1, kbuMul:cur.kbuMul||1};
      }
      return null;
    }

    update(dt,input,world,enemies){
      input.beginFrame();
      this._posOverhead();

      if(this.a2LockoutT>0) this.a2LockoutT=Math.max(0,this.a2LockoutT-dt);
      const skBtn=document.getElementById('btnSK');
      if(this.skillCDT>0){ this.skillCDT=Math.max(0,this.skillCDT-dt); skBtn.setAttribute('disabled',''); }
      else { skBtn.removeAttribute('disabled'); }

      if(this.dead){ this.updatePhysics(dt); if(this.fade<=0){ this._respawn(world); } world.updateTimer(dt); return; }

      if(input.attack2Charging){ input.attack2ChargeT=Math.min(1,input.attack2ChargeT+dt); this._showGauge(true,'▲ Charge', input.attack2ChargeT); }
      else if(input.skillCharging && this.skillCDT<=0){ input.skillChargeT=Math.min(1,input.skillChargeT+dt); this._showGauge(true,'● Charge', input.skillChargeT); }
      else this._showGauge(false);

      if(input.edge.a2Release && input.attack2ChargeT>0){
        const charged = input.attack2ChargeT>=0.5;
        this.queueA2={charged, minShake: charged?0.6:0.35};
        input.attack2ChargeT=0;
      }
      if(input.edge.skillRelease && input.skillChargeT>0 && this.skillCDT<=0){
        this.queueSK={charged: input.skillChargeT>=0.5};
        input.skillChargeT=0;
      }

      // 攻撃/スキル中：ヒット処理（複数敵対応）
      if(this.state==='atk'||this.state==='skill'||this.state==='hurt'){
        const hb=this.currentHitbox();
        if(hb){
          for(const e of enemies){
            if(!e || e.dead || e.invulnT>0) continue;
            if(rectsOverlap({x:hb.x,y:hb.y,w:hb.w,h:hb.h}, e.aabb())){
              const hit = e.hurt(hb.power, hb.dir, {lift:hb.lift, kbMul:hb.kbMul, kbuMul:hb.kbuMul}, this.effects);
              if(hit && rectsOverlap(this.aabb(), e.aabb())){ e.x = this.x + hb.dir * (this.w*0.55); }
            }
          }
        }
        this._updateAction(dt,world);
        world.updateTimer(dt);
        return;
      }

      if(input.edge.a1) this.bufferA1=true;
      if(this.comboGraceT>0) this.comboGraceT=Math.max(0,this.comboGraceT-dt);

      if(this.queueSK){ const q=this.queueSK; this.queueSK=null; this.bufferA1=false; this._startSpin(q.charged); return; }
      if(this.queueA2 && this.a2LockoutT<=0){ const q=this.queueA2; this.queueA2=null; this.bufferA1=false; this._startA2(q.charged, q.minShake); return; }
      if(this.bufferA1 && this.comboStep<3){ this.bufferA1=false; this._startA1(); return; }

      let ax=0; if(input.left){ ax-=MOVE; this.face=-1; } if(input.right){ ax+=MOVE; this.face=1; }
      this.vx = ax!==0 ? (ax>0?MOVE:-MOVE) : 0;
      if(input.consumeJump() && this.onGround){ this.vy=-JUMP_V; this.onGround=false; }

      this.updatePhysics(dt);
      this.state = !this.onGround ? 'jump' : (Math.abs(this.vx)>1?'run':'idle');
      this.animT += dt;
      if(input.attack2Charging && this.state!=='atk' && this.state!=='skill'){ this.state='chargeA2'; }
      world.updateTimer(dt);
    }

    _startA1(){
      this.state='atk'; this.animT=0;
      this.comboStep=Math.min(this.comboStep+1,3);
      this.actionAir=!this.onGround; this.actionAirVx=this.actionAir? clamp(this.vx, -40, 40) : 0;
      const seq=[ {kind:'prep',dur:0.10,frame:'k1prep',dx:0,power:0} ];
      let frame='k1a', power=5, dx=0;
      if(this.comboStep===2){ frame='k1b'; power=8; dx=10; }
      else if(this.comboStep===3){ frame='k1c'; power=10; dx=10; }
      seq.push({kind:'hit',dur:0.25,frame,dx,power, kbMul:1.0, kbuMul:1.0});
      this._actionSeq=seq; this._actionIndex=0; this._actionTime=0;
    }

    _startA2(charged, minShake){
      this.state='atk'; this.animT=0;
      this.actionAir=!this.onGround; this.actionAirVx=this.actionAir? clamp(this.vx, -40, 40) : 0;
      const power=charged?18:15, lift=1, kbm=charged?1.2:1.1, kbum=charged?1.25:1.15;
      this._actionSeq=[
        {kind:'prepShake',dur:minShake,frame:'k2prep',dx:0,power:0},
        {kind:'hit',dur:0.34,frame:'k2',dx:12,power:power, lift, kbMul:kbm, kbuMul:kbum}
      ];
      this._actionIndex=0; this._actionTime=0;
      this.a2LockoutT = 0.5;
    }

    _startSpin(charged){
      this.state='skill'; this.animT=0;
      this.actionAir=!this.onGround; this.actionAirVx=this.actionAir? clamp(this.vx, -40, 40) : 0;
      const rounds=charged?4:2, power=charged?40:25;
      const kbm  = charged?1.9:1.6, kbum = charged?1.5:1.3;
      const frames=this.frames.spin; const seq=[];
      for(let r=0;r<rounds;r++){
        for(let i=0;i<frames.length;i++){
          const p = power*(i===1?1:0.6);
          const lift = (i===1?1:0);
          seq.push({kind:'sp',dur:0.07,frame:frames[i],dx:0,power:p, lift, kbMul:kbm, kbuMul:kbum});
        }
      }
      this._actionSeq=seq; this._actionIndex=0; this._actionTime=0;
    }

    _updateAction(dt){
      if(this.actionAir){ this.actionAirVx *= 0.90; this.x += this.actionAirVx*dt; }
      this.updatePhysics(dt);

      if(this._actionSeq){
        this._actionTime+=dt;
        const cur=this._actionSeq[this._actionIndex];
        if(cur){
          const dxScale=this.onGround?1:0.5;
          if(cur.dx) this.x += this.face*(cur.dx*dxScale*dt/cur.dur);
          if(this._actionTime>=cur.dur){
            this._actionIndex++; this._actionTime=0;
            if(this._actionIndex>=this._actionSeq.length){
              if(this.state==='skill'){ this.skillCDT=5.0; }
              if(this.state==='atk' && this.comboStep>0) this.comboGraceT=this.comboGraceMax;
              if(this.state==='atk' && this.comboStep>=3){ this.comboStep=0; this.bufferA1=false; }
              if(this.queueSK && this.skillCDT<=0){ const q=this.queueSK; this.queueSK=null; this._startSpin(q.charged); return; }
              if(this.queueA2 && this.a2LockoutT<=0){ const q=this.queueA2; this.queueA2=null; this._startA2(q.charged, q.minShake); return; }
              this.state='idle'; this._actionSeq=null;
            }
          }
        }
      }
      this.animT+=dt;
    }

    _respawn(world){
      this.dead=false; this.fade=1; this.spinAngle=0; this.spinSpeed=0;
      this.state='idle'; this.comboStep=0; this.comboGraceT=0; this.bufferA1=false;
      this.queueA2=null; this.queueSK=null; this.actionAir=false; this.actionAirVx=0; this.invulnT=0.6;
      this.hp=this.maxhp; document.getElementById('hpfill').style.width='100%'; document.getElementById('hpnum').textContent=this.hp;
      this.x=world.camX+80; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.vx=0; this.vy=0;
    }

    draw(ctx,world){
      ctx.save();
      ctx.translate(this.x-world.camX, this.y-world.camY);
      if(this.dead){ ctx.globalAlpha=this.fade; ctx.rotate(this.spinAngle); }
      if(this.face<0 && !this.dead) ctx.scale(-1,1);
      let ox=0, img=null;
      if(this.state==='chargeA2'){ img=this.world.assets.img(this.frames.k2prep); ox=Math.sin(this.animT*40)*2; }
      else if(this.state==='idle'){ img=this._imgByKey('idle',0); }
      else if(this.state==='run'){ const i=Math.floor(this.animT*10)%this.frames.walk.length; img=this._imgByKey('walk',i); }
      else if(this.state==='jump'){ img=this._imgByKey('walk',0); }
      else if((this.state==='atk'||this.state==='skill') && this._actionSeq){
        const cur=this._actionSeq[this._actionIndex]; const key=cur.frame;
        img=this.world.assets.img(this.frames[key]?this._getFramePath(key,0):key);
        if(cur.kind==='prepShake') ox+=Math.sin(this._actionTime*40)*2;
      } else img=this._imgByKey('idle',0);
      if(!img) img=this.world.assets.img('M1-1.png');
      const scale=this.h/img.height, w=img.width*scale, h=this.h;
      ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2+ox), Math.round(-h/2), Math.round(w), Math.round(h));
      ctx.restore();
    }
  }

  /* Enemy (Dash type) */
  class DashEnemy extends CharacterBase{
    constructor(world,effects){
      super(56,64);
      this.world=world; this.effects=effects;
      this.x=360; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1;
      this.maxhp=500; this.hp=500;
      this.cool=0; // 攻撃クール
      this._seq=null; this._idx=0; this._t=0;
      this.backstepT=0;
    }
    imgByKey(key){
      const a=this.world.assets, map={ idle:'EN1-1.png', walk2:'EN1-2.png', walk3:'EN1-3.png', atk1:'EN1-4.png', atk2:'EN1-5.png' };
      return a.img(map[key]||'EN1-1.png');
    }
    currentHitbox(){
      if(!this._seq) return null; const cur=this._seq[this._idx]; if(!cur) return null;
      if(cur.kind==='hit'){ // 突進の広めヒット
        const w=56,h=40; const x=this.x + this.face*(this.w*0.35 + w*0.5); const y=this.y - 6;
        return {x,y,w,h,power:10,dir:this.face, lift:0};
      }
      return null;
    }
    aabb(){ return {x:this.x, y:this.y, w:this.w*0.65, h:this.h*0.85}; }

    // 突進攻撃（レンジ: 80〜240）
    decide(player){
      if(this.cool>0 || this.state==='atk' || this.state==='hurt' || this.dead) return;
      const dx=player.x - this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1;
      if(adx>=80 && adx<=240){
        // 予備動作→突進→停止（連撃なし）
        this._seq=[
          {kind:'pose',dur:0.12,key:'atk1',dx:0},
          {kind:'dash',dur:0.22,key:'atk2',dx: (this.onGround? 480:260)}, // 速度ベース
          {kind:'hit', dur:0.10,key:'atk2',dx: 60}, // 追い
        ];
        this.cool=2.0; // 攻撃後のクール
        this.state='atk'; this._idx=0; this._t=0; this.vx=0;
      } else {
        // 間合い調整
        this.vx = (dx>0?EN_MOVE:-EN_MOVE);
      }
    }

    update(dt,player){
      if(this.dead){ this.updatePhysics(dt); return; }
      if(this.cool>0) this.cool=Math.max(0,this.cool-dt);

      if(this.state==='atk'){
        // シーケンス進行
        this.updatePhysics(dt);
        if(this._seq){
          this._t+=dt; const cur=this._seq[this._idx];
          if(cur){
            const scale=this.onGround?1:0.6;
            if(cur.kind==='dash'){
              // 突進は速度で
              this.vx = this.face * (cur.dx*scale);
            }else{
              if(cur.dx) this.x += this.face*(cur.dx*scale*dt/Math.max(0.001,cur.dur));
              this.vx *= 0.9;
            }
            if(this._t>=cur.dur){
              this._idx++; this._t=0; this.vx=0;
              if(this._idx>=this._seq.length){ this._seq=null; this.state='idle'; this.backstepT=0.35; }
            }
          }
        }
      } else if(this.state==='hurt'){
        this.updatePhysics(dt);
        if(this.onGround) this.state='idle';
      } else {
        // クール中はバックステップで離脱
        const dx=player.x - this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1;
        if(this.cool>0){
          if(this.backstepT>0){ // バクステ中
            this.backstepT=Math.max(0,this.backstepT-dt);
            const sp=260; this.vx = -this.face*sp;
          } else {
            // 小移動：様子見
            this.vx = (adx<120)? (-this.face*120) : 0;
          }
        } else {
          // 攻め寄る
          this.vx = adx>100 ? (dx>0?EN_MOVE:-EN_MOVE) : 0;
          // 毎フレーム決断
          this.decide(player);
        }
        this.updatePhysics(dt);
        this.state = !this.onGround ? 'jump' : (Math.abs(this.vx)>1?'run':'idle');
      }
      this.animT+=dt;
    }

    draw(ctx,world){
      ctx.save();
      ctx.translate(this.x-world.camX, this.y-world.camY);
      if(this.dead){ ctx.globalAlpha=this.fade; ctx.rotate(this.spinAngle); }
      if(this.face<0 && !this.dead) ctx.scale(-1,1);
      let img=null; 
      if(this.dead){ img=this.imgByKey('idle'); }
      else if(this.state==='atk' && this._seq){ const cur=this._seq[this._idx]; img=this.imgByKey(cur.key||'atk2');
      } else if(this.state==='run'){ const f=Math.floor(this.animT*10)%2; img=this.imgByKey(f? 'walk2':'walk3');
      } else { img=this.imgByKey('idle'); }
      const scale=this.h/img.height, w=img.width*scale, h=this.h;
      ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h));
      ctx.restore();
      this.drawHPBar(ctx,world);
    }
  }

  /* Projectile for WaruMOB */
  class Projectile{
    constructor(world,x,y,dir,img,power=10){
      this.world=world; this.x=x; this.y=y; this.dir=dir; this.vx=320*dir; this.vy=0;
      this.img=img; this.power=power; this.life=2.5; this.dead=false; this.w=24; this.h=16;
    }
    aabb(){ return {x:this.x, y:this.y, w:this.w*0.7, h:this.h*0.7}; }
    update(dt){ if(this.dead) return; this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt; if(this.life<=0) this.dead=true; }
    draw(ctx){
      if(this.dead) return;
      const img=this.img; if(!img) return;
      const scale=this.h/img.height, w=img.width*scale, h=this.h;
      ctx.save(); ctx.translate(this.x-this.world.camX,this.y-this.world.camY);
      if(this.dir<0) ctx.scale(-1,1);
      ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h));
      ctx.restore();
    }
  }

  /* WaruMOB (ranged) */
  class WaruMob extends CharacterBase{
    constructor(world,effects,assets,x=520){
      super(52,60);
      this.world=world; this.effects=effects; this.assets=assets;
      this.x=x; this.y=Math.floor(GROUND_TOP_Y)-this.h/2+FOOT_PAD; this.face=-1;
      this.maxhp=100; this.hp=100; this.attack=10;
      this.cool=0; // 攻撃間隔（低頻度）
      this._seq=null; this._idx=0; this._t=0;
      this.projectiles=[];
      this.step=0;
    }
    imgByKey(key){
      const a=this.assets;
      const map={ idle:'teki1.png', walk1:'teki1.png', walk2:'teki2.png', prep1:'teki1.png', prep2:'teki3.png' };
      return a.img(map[key]||'teki1.png');
    }
    addBullet(){
      const img=this.assets.img('teki7.png');
      const ox=this.face*28; const oy=-8;
      this.projectiles.push(new Projectile(this.world,this.x+ox,this.y+oy,this.face,img,this.attack));
    }
    currentHitbox(){ return null; } // 近接は無し
    aabb(){ return {x:this.x, y:this.y, w:this.w*0.6, h:this.h*0.85}; }

    update(dt,player){
      if(this.dead){ this.updatePhysics(dt); return; }
      if(this.cool>0) this.cool=Math.max(0,this.cool-dt);

      // 弾更新
      for(const p of this.projectiles) p.update(dt);
      this.projectiles=this.projectiles.filter(p=>!p.dead);

      if(this.state==='atk'){
        this.updatePhysics(dt);
        if(this._seq){
          this._t+=dt; const cur=this._seq[this._idx];
          if(cur){
            if(this._t>=cur.dur){
              this._idx++; this._t=0;
              if(this._idx===2){ // 発射タイミング
                this.addBullet();
              }
              if(this._idx>=this._seq.length){ this._seq=null; this.state='idle'; }
            }
          } else { this._seq=null; this.state='idle'; }
        }
      } else if(this.state==='hurt'){
        this.updatePhysics(dt);
        if(this.onGround) this.state='idle';
      } else {
        // 遅めの徘徊＋低頻度射撃
        const dx=player.x - this.x; const adx=Math.abs(dx); this.face=dx>=0?1:-1;
        const patrol=60; // 遅い
        this.vx = adx>180 ? (dx>0?patrol:-patrol) : 0;

        if(this.cool<=0 && adx<260){
          // 予備動作（2段）→発射
          this._seq=[ {kind:'pose',dur:0.18,key:'prep1'}, {kind:'pose',dur:0.22,key:'prep2'} ];
          this.cool=2.4; // 低頻度
          this.state='atk'; this._idx=0; this._t=0; this.vx=0;
        }

        this.updatePhysics(dt);
        this.state = !this.onGround ? 'jump' : (Math.abs(this.vx)>1?'run':'idle');
      }
      this.animT+=dt;
    }

    draw(ctx,world){
      // 本体
      ctx.save(); ctx.translate(this.x-world.camX, this.y-world.camY);
      if(this.dead){ ctx.globalAlpha=this.fade; ctx.rotate(this.spinAngle); }
      if(this.face<0 && !this.dead) ctx.scale(-1,1);
      let img=null;
      if(this.dead){ img=this.imgByKey('idle'); }
      else if(this.state==='atk' && this._seq){ const cur=this._seq[this._idx]; img=this.imgByKey(cur.key||'prep2'); }
      else if(this.state==='run'){ const f=Math.floor(this.animT*6)%2; img=this.imgByKey(f? 'walk1':'walk2'); }
      else { img=this.imgByKey('idle'); }
      const scale=this.h/img.height, w=img.width*scale, h=this.h;
      ctx.imageSmoothingEnabled=false; ctx.drawImage(img, Math.round(-w/2), Math.round(-h/2), Math.round(w), Math.round(h));
      ctx.restore();

      // HPバー
      this.drawHPBar(ctx,world);

      // 弾
      for(const p of this.projectiles) p.draw(ctx);
    }
  }

  /* World */
  class World{
    constructor(assets, canvas, effects){
      this.assets=assets; this.effects=effects;
      this.canvas=canvas; this.ctx=canvas.getContext('2d',{alpha:true});
      this.ctx.imageSmoothingEnabled=false;
      this.gameW=canvas.width; this.gameH=canvas.height;
      this.camX=0; this.camY=0; this.time=0; this._timerAcc=0;

      const r=canvas.getBoundingClientRect();
      this.screenScaleX=r.width/this.gameW; this.screenScaleY=r.height/this.gameH;

      const bg=this.assets.img('back1.png');
      if(bg){ this.bgScale = this.gameH / bg.height; this.bgDW = bg.width*this.bgScale; this.bgDH = bg.height*this.bgScale; }
      else { this.bgScale=1; this.bgDW=this.gameW; this.bgDH=this.gameH; }
      this.bgSpeed=1.0;
    }
    resize(){ const r=this.canvas.getBoundingClientRect(); this.screenScaleX=r.width/this.gameW; this.screenScaleY=r.height/this.gameH; }
    updateCam(p){
      const offs=this.effects.getCamOffset();
      const target=p.x - this.gameW*0.35 + offs.x;
      this.camX=Math.max(0, lerp(this.camX,target,0.12));
      this.camY=offs.y;
    }
    updateTimer(dt){
      this._timerAcc+=dt; if(this._timerAcc>=0.2){ this.time+=this._timerAcc; this._timerAcc=0;
        const t=Math.floor(this.time); const mm=String(Math.floor(t/60)).padStart(2,'0'); const ss=String(t%60).padStart(2,'0');
        document.getElementById('time').textContent=`${mm}:${ss}`; }
    }
    draw(player, enemies){
      const ctx=this.ctx; ctx.clearRect(0,0,this.gameW,this.gameH);
      const bg=this.assets.img('back1.png');
      if(bg){
        const w=Math.round(this.bgDW), h=Math.round(this.bgDH);
        const step=Math.max(1, w - 1);
        const startX = Math.floor((this.camX*this.bgSpeed - this.gameW*0.2)/step)*step;
        const endX   = this.camX*this.bgSpeed + this.gameW*1.2 + w;
        for(let x=startX; x<=endX; x+=step){
          ctx.drawImage(bg, 0,0,bg.width,bg.height, Math.round(x - this.camX*this.bgSpeed), 0, w, h);
        }
      } else {
        const g=ctx.createLinearGradient(0,0,0,this.gameH); g.addColorStop(0,'#0a1230'); g.addColorStop(1,'#0a0f18');
        ctx.fillStyle=g; ctx.fillRect(0,0,this.gameW,this.gameH);
      }
      // 床ライン目安
      ctx.fillStyle='#0b0f17'; const yTop=Math.floor(GROUND_TOP_Y); ctx.fillRect(0,yTop-1,this.gameW,1);

      for(const e of enemies) e.draw(ctx,this);
      player.draw(ctx,this);
      this.effects.draw(ctx,this);
    }
  }

  const updateHPUI=(hp,maxhp)=>{ const fill=document.getElementById('hpfill'); document.getElementById('hpnum').textContent=hp; fill.style.width=Math.max(0,Math.min(100,(hp/maxhp)*100))+'%'; };

  /* Game */
  class Game{
    constructor(){
      this.assets=new Assets(); this.canvas=document.getElementById('game');
      this.input=new Input(); this.effects=new Effects();
      this.player=null; this.enemies=[]; this.world=null; this.lastT=0;
      addEventListener('resize',()=>this.world?.resize());
    }
    async start(){
      const imgs=[
        'back1.png',
        'M1-1.png','M1-2.png','M1-3.png','M1-4.png',
        'K1-1.png','K1-2.png','K1-3.png','K1-4.png','K1-5.png',
        'h1.png','h2.png','h3.png','h4.png',
        'EN1-1.png','EN1-2.png','EN1-3.png','EN1-4.png','EN1-5.png','EN1-6.png',
        'teki1.png','teki2.png','teki3.png','teki7.png'
      ];
      await this.assets.load(imgs);
      this.world=new World(this.assets,this.canvas,this.effects);
      this.player=new Player(this.assets,this.world,this.effects);
      // 敵2体：突進型＋ワルMOB
      this.enemies=[ new DashEnemy(this.world,this.effects), new WaruMob(this.world,this.effects,this.assets,520) ];
      updateHPUI(this.player.hp,this.player.maxhp);

      this.lastT=now();
      const loop=()=>{
        const t=now(); let dt=(t-this.lastT)/1000; if(dt>0.05) dt=0.05; this.lastT=t;

        // 演出ヒットストップ
        if(this.effects.hitstop>0){
          this.effects.update(dt);
          this.world.updateCam(this.player);
          this.world.draw(this.player,this.enemies);
          requestAnimationFrame(loop);
          return;
        }

        // 更新
        this.player.update(dt,this.input,this.world,this.enemies);

        // 敵更新と敵→プレイヤー攻撃判定
        for(const e of this.enemies){
          e.update(dt,this.player);

          // DashEnemyの近接ヒット
          if(e instanceof DashEnemy && !e.dead){
            const hb=e.currentHitbox();
            if(hb && this.player.invulnT<=0){
              if(rectsOverlap({x:hb.x,y:hb.y,w:hb.w,h:hb.h}, this.player.aabb())){
                const hit=this.player.hurt(10, hb.dir, {lift:0}, this.effects);
                if(hit) updateHPUI(this.player.hp,this.player.maxhp);
              }
            }
          }

          // WaruMobの弾ヒット
          if(e instanceof WaruMob){
            for(const p of e.projectiles){
              if(!p.dead && this.player.invulnT<=0){
                if(rectsOverlap(p.aabb(), this.player.aabb())){
                  p.dead=true;
                  const hit=this.player.hurt(p.power, p.dir, {lift:0}, this.effects);
                  if(hit) updateHPUI(this.player.hp,this.player.maxhp);
                }
              }
            }
          }
        }

        // 死亡フェード後の掃除
        this.enemies=this.enemies.filter(e=>!(e.dead && e.fade<=0));

        // すり抜け防止：プレイヤーと各敵のX分離
        for(const e of this.enemies){
          if(e.dead || this.player.dead) continue;
          const a=this.player.aabb(), b=e.aabb();
          if(rectsOverlap(a,b)){
            const dx = (this.player.x - e.x);
            const dir = dx>=0? 1 : -1;
            const overlapX = (a.w + b.w)/2 - Math.abs(this.player.x - e.x);
            if(overlapX>0){
              // 互いに半分ずつ押し合い
              this.player.x += dir * (overlapX*0.6);
              e.x          -= dir * (overlapX*0.4);
              // 少しだけ反発
              this.player.vx += dir * 20;
              e.vx -= dir * 20;
            }
          }
        }

        this.effects.update(dt);
        this.world.updateCam(this.player);
        this.world.updateTimer(dt);
        this.world.draw(this.player, this.enemies);

        requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);
    }
  }

  // HPバーUI更新を伴う Player.hurt
  Player.prototype.hurt = function(amount,dir,opts,effects){
    const hit = CharacterBase.prototype.hurt.call(this,amount,dir,opts,effects);
    if(hit) updateHPUI(this.hp,this.maxhp);
    return hit;
  };

  new Game().start();
})();
</script>
</body>
</html>
