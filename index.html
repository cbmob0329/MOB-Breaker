<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
<title>MOB Action Prototype</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{
    --bg:#0a0d12;--panel:#0c111a;--ink:#e4ecff;--muted:#9bb1d0;--accent:#59d;--danger:#ff4d4d;
    --game-w:420px; /* internal logical width */
    --hud-h:64px;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;}
  *{box-sizing:border-box}
  body{display:flex;min-height:100dvh;}
  #app{flex:1;display:grid;grid-template-rows:1fr auto;gap:10px;padding:env(safe-area-inset-top) env(safe-area-inset-right) calc(env(safe-area-inset-bottom) + 6px) env(safe-area-inset-left)}

  /* GAME AREA (top) */
  .game-wrap{display:grid;place-items:center;}
  canvas#game{width:min(100%, var(--game-w));aspect-ratio:3/5; /* 420x700 */
    background:#0b0f17;border:1px solid #141b26;border-radius:14px;box-shadow:0 12px 40px rgba(0,0,0,.45);touch-action:none}

  /* HUD overlay */
  .hud{position:relative;width:min(100%, var(--game-w));margin:0 auto;margin-top:-52px;pointer-events:none}
  .hudbar{display:flex;gap:8px;align-items:center;justify-content:space-between;background:linear-gradient(180deg, rgba(12,17,26,.78), rgba(12,17,26,.62));
    border:1px solid #1a2536;border-radius:12px;padding:6px 10px;backdrop-filter:blur(4px)}
  .hud small{color:var(--muted)}
  .hpbar{position:relative;height:10px;background:#202a3a;border-radius:6px;overflow:hidden;width:58%}
  .hpbar>i{position:absolute;inset:0;background:linear-gradient(90deg, #2dd,#5af,#59d);transform-origin:left center}
  .lives{display:flex;gap:6px}
  .life{width:10px;height:10px;border-radius:50%;background:var(--accent);opacity:.9}

  /* CONTROL AREA (bottom) */
  .controls{display:grid;grid-template-columns:1fr 1fr;gap:10px;align-items:stretch;user-select:none; -webkit-user-select:none;}
  .pad{background:var(--panel);border:1px solid #162233;border-radius:14px;box-shadow:inset 0 0 0 1px #0f1622;position:relative;touch-action:none}
  .gridlines{position:absolute;inset:0;background:linear-gradient(transparent 49%, rgba(255,255,255,.05) 50%),
                                    linear-gradient(90deg, transparent 49%, rgba(255,255,255,.05) 50%);
    background-size:40px 40px;pointer-events:none;border-radius:14px}

  /* Virtual stick */
  .stick{position:absolute;left:16px;bottom:16px;width:140px;height:140px;border-radius:50%;background:#0e1725;border:1px solid #152135}
  .stick i{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:56px;height:56px;border-radius:50%;background:#15243a;border:1px solid #24406b;box-shadow:0 4px 16px rgba(0,0,0,.4)}

  /* Buttons */
  .btns{position:absolute;right:16px;bottom:16px;display:grid;grid-template-columns:repeat(2,72px);grid-auto-rows:72px;gap:12px}
  button.btn{appearance:none;border:0;border-radius:16px;background:#14243c;box-shadow:inset 0 0 0 1px #203556, 0 6px 18px rgba(0,0,0,.45);color:#cfe2ff;font-weight:800;font-size:22px;letter-spacing:1px}
  button.btn:active{transform:translateY(1px)}
  button.btn[data-type="atk1"]{background:#142a3c}
  button.btn[data-type="atk2"]{background:#15253f}
  button.btn[data-type="skill"]{background:#1a2648}
  button.btn[data-type="jump"]{background:#18333f}

  /* Anti-miss taps: make hit-area large */
  button.btn{touch-action:manipulation}

  footer.hint{opacity:.75;text-align:center;font-size:12px;margin-top:4px}
  code.k{background:#0e1726;padding:2px 6px;border-radius:6px;border:1px solid #15233a}
</style>
</head>
<body>
<div id="app">
  <section class="game-wrap">
    <canvas id="game" width="420" height="700" aria-label="game canvas"></canvas>
    <div class="hud" aria-hidden>
      <div class="hudbar">
        <div class="hpbar" title="HP"><i id="hpfill" style="transform:scaleX(1)"></i></div>
        <div class="lives" id="lives"></div>
        <div class="tim" id="timer">TIME 00:00</div>
      </div>
    </div>
  </section>

  <section class="controls" aria-label="controls">
    <div class="pad">
      <div class="gridlines"></div>
      <div class="stick" id="stick"><i id="sticknub"></i></div>
    </div>
    <div class="pad">
      <div class="gridlines"></div>
      <div class="btns">
        <button class="btn" id="btnA" data-type="atk1" aria-label="攻撃1">■</button>
        <button class="btn" id="btnB" data-type="atk2" aria-label="攻撃2">▲</button>
        <button class="btn" id="btnC" data-type="skill" aria-label="スキル">●</button>
        <button class="btn" id="btnJ" data-type="jump" aria-label="ジャンプ">×</button>
      </div>
    </div>
    <footer class="hint">操作: <code class="k">←/A</code><code class="k">→/D</code><code class="k">Space/↑/W=ジャンプ</code> <code class="k">J=■</code> <code class="k">K=▲(長押しで強化)</code> <code class="k">L=●(長押しで強化)</code></footer>
  </section>
</div>
<script>
// =====================
// Asset Loader (reuses Image objects to keep GC low)
// =====================
const ASSETS = {
  // Player idle & move
  'M1-1.png': 'M1-1.png',
  'M1-2.png': 'M1-2.png',
  'M1-3.png': 'M1-3.png',
  'M1-4.png': 'M1-4.png',
  // Player attacks
  'K1-1.png': 'K1-1.png',
  'K1-2.png': 'K1-2.png',
  'K1-3.png': 'K1-3.png',
  'K1-4.png': 'K1-4.png',
  'K1-5.png': 'K1-5.png',
  // Skill spin frames
  'h1.png':'h1.png','h2.png':'h2.png','h3.png':'h3.png','h4.png':'h4.png',
  // Enemy
  'EN1-1.png':'EN1-1.png','EN1-2.png':'EN1-2.png','EN1-3.png':'EN1-3.png',
  'EN1-4.png':'EN1-4.png','EN1-5.png':'EN1-5.png','EN1-6.png':'EN1-6.png',
  // Stage tile (loop)
  'S1.png':'S1.png'
};
const images = new Map();
function loadImages(callback){
  let left = Object.keys(ASSETS).length; if(left===0){callback();return}
  for(const [k,src] of Object.entries(ASSETS)){
    const img = new Image();
    img.onload=()=>{ if(--left===0) callback(); };
    img.onerror=()=>{ console.warn('Missing image',src,'— using placeholder.'); if(--left===0) callback(); };
    img.src = src; images.set(k,img);
  }
}

// Helper: draw sprite with optional flip & red flash overlay
function drawSprite(ctx,img,x,y,w,h,flip=false,alpha=1,flash=false,rotation=0){
  ctx.save();
  ctx.translate(x,y);
  if(rotation!==0) ctx.rotate(rotation);
  if(flip){ ctx.scale(-1,1); x= -w/2; } else { x= -w/2; }
  const yoff = -h; // draw from feet
  ctx.globalAlpha = alpha;
  if(img && img.complete && img.naturalWidth>0){
    const iw=img.naturalWidth, ih=img.naturalHeight; // maintain aspect
    const aspect = iw/ih; const targetAspect = w/h; // keep original aspect if needed
    // We assume provided assets are already trimmed; scale to target box maintaining ratio
    let dw=w, dh=h; if(Math.abs(aspect-targetAspect)>0.05){
      if(aspect>targetAspect){ dh = w/aspect; } else { dw = h*aspect; }
    }
    ctx.drawImage(img, x+(w-dw)/2, yoff+(h-dh), dw, dh);
  }else{
    // placeholder
    ctx.fillStyle = '#22344e'; ctx.fillRect(x, yoff, w, h);
    ctx.strokeStyle = '#3a5a8f'; ctx.strokeRect(x+0.5, yoff+0.5, w-1, h-1);
  }
  if(flash){
    ctx.globalCompositeOperation='source-atop';
    ctx.fillStyle='rgba(255,60,60,0.6)';
    ctx.fillRect(-w/2, yoff, w, h);
    ctx.globalCompositeOperation='source-over';
  }
  ctx.restore();
}

// =====================
// Game constants & helpers
// =====================
const W=420,H=700; // canvas logical size (3:5)
const GRAV=2000; // px/s^2
const JUMP_V= -780; // px/s
const MOVE_SPEED = 210; // walk speed
const ENEMY_SPEED = 140;
const AIR_CONTROL = 0.6;
const GROUND_Y = 560; // world ground baseline
const WORLD_LEN = 6000; // long stage for scroll

// Player stats
const PLAYER_MAX_HP = 1000;
const ENEMY_MAX_HP = 500;

// Attack data
const ATTACKS = {
  // ■: single press uppercut (K1-1 after K1-3)
  light:{ wind:'K1-3.png', act:'K1-1.png', windT:0.12, actT:0.18, move:40, dmg:5, lockMove:true },
  // ■■▲ etc handled via input buffer; full-chain auto-finishes, no cancels
  combo1:{ wind:'K1-3.png', act:'K1-2.png', windT:0.20, actT:0.20, move:120, dmg:8, lockMove:true },
  combo2:{ wind:'K1-3.png', act:'K1-4.png', windT:0.20, actT:0.20, move:80, dmg:10, lockMove:true },
  // ▲: rising kick with charge
  heavy:{ wind:'K1-3.png', act:'K1-5.png', windT:0.50, actT:0.30, move:60, dmg:15, chargeExtra:{ windT:1.00, dmg:+10, glow:true } }
};

const SKILL = {
  frames:['h1.png','h2.png','h3.png','h4.png'],
  cycleT:0.08,
  dmgTap:25, roundsTap:2,
  dmgHold:40, roundsHold:4,
};

// Utility
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const now=()=>performance.now()/1000;

// =====================
// Camera
// =====================
const camera={x:0,y:0};
function cameraFollow(px){ camera.x = clamp(px - W*0.4, 0, WORLD_LEN - W); }

// =====================
// Stage (simple tiled ground from S1.png)
// =====================
const stage={ tileW:256, tileH:96, groundY:GROUND_Y, imgKey:'S1.png' };
function drawStage(ctx){
  const img=images.get(stage.imgKey);
  const viewStart = Math.floor(camera.x / stage.tileW) * stage.tileW;
  const viewEnd = camera.x + W + stage.tileW;
  // sky
  const grad = ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,'#06101d'); grad.addColorStop(1,'#0a1626');
  ctx.fillStyle=grad; ctx.fillRect(0,0,W,H);
  // ground tiles
  for(let x=viewStart; x<viewEnd; x+=stage.tileW){
    const sx = x - camera.x;
    if(img && img.complete && img.naturalWidth>0){
      ctx.drawImage(img, sx, stage.groundY - stage.tileH, stage.tileW, stage.tileH);
    }else{
      ctx.fillStyle='#1a2639'; ctx.fillRect(sx, stage.groundY - stage.tileH, stage.tileW, stage.tileH);
      ctx.strokeStyle='#22324e'; ctx.strokeRect(sx+0.5, stage.groundY-stage.tileH+0.5, stage.tileW-1, stage.tileH-1);
    }
  }
}

// =====================
// Entities
// =====================
class Entity{
  constructor(x){
    this.x=x; this.y=stage.groundY; this.vx=0; this.vy=0; this.dir=1; // 1:right, -1:left
    this.w=56; this.h=86; // visual box (keeps aspect)
    this.hp=1; this.maxhp=1; this.alive=true;
    this.state='idle';
    this.animTime=0; this.frame=0; this.hurt=0; this.inv=0;
    this.knockVX=0; this.knockVY=0; this.spin=0; // KO spin
  }
  bbox(){ return {x:this.x-18,y:this.y-this.h,width:36,height:this.h}; }
  takeDamage(dmg, fromDir){
    if(!this.alive) return;
    if(this.inv>0) return;
    this.hp -= dmg; this.hurt = 0.25; this.inv=0.2; // brief i-frames
    // small pop + knockback
    this.vy = -220; this.vx = 0; this.knockVX = fromDir * 180; this.knockVY = -120;
    if(this.hp<=0){ this.alive=false; this.state='ko'; this.spin = 0; this.vx = fromDir*220; this.vy = -420; }
  }
  physics(dt){
    // gravity
    this.vy += GRAV*dt;
    this.y += this.vy*dt; this.x += (this.vx + this.knockVX)*dt; this.knockVX *= Math.pow(0.001, dt); // quick decay
    if(this.y>stage.groundY){ this.y=stage.groundY; this.vy=0; }
    // world bounds
    this.x = clamp(this.x, 16, WORLD_LEN-16);
  }
}

class Player extends Entity{
  constructor(x){
    super(x); this.hp=PLAYER_MAX_HP; this.maxhp=PLAYER_MAX_HP; this.lives=3;
    this.moveInput=0; this.wantJump=false; this.onGround=true; this.lockMove=false; this.flip=false;
    this.comboBuffer=[]; this.comboStep=0; this.comboTimer=0; this.heavyCharge=0; this.skillHold=0; this.skillActive=false; this.skillTime=0; this.skillIndex=0; this.skillRounds=0; this.glow=0;
  }
  update(dt){
    // State timers
    this.animTime += dt; if(this.hurt>0) this.hurt-=dt; if(this.inv>0) this.inv-=dt; if(this.glow>0) this.glow-=dt;

    // Ground check
    this.onGround = (this.y>=stage.groundY-0.5);

    // Movement input -> velocity (disabled during certain actions)
    let speed = MOVE_SPEED; let ctrl = this.onGround?1:AIR_CONTROL;
    if(!this.lockMove && !this.skillActive){ this.vx = this.moveInput * speed * ctrl; }
    if(this.moveInput!==0) this.dir = this.moveInput>0?1:-1;
    this.flip = (this.dir<0); // flip when facing left using right-facing sprites only

    // Jump
    if(this.wantJump && this.onGround && !this.skillActive){ this.vy = JUMP_V; this.wantJump=false; }

    // Attack chain auto-finish (no cancel mid)
    if(this.state.startsWith('atk')){
      this.comboTimer -= dt;
      if(this.comboTimer<=0){ // proceed to next phase / finish
        if(this.state==='atk_wind'){
          // switch to active frame
          this.state='atk_act'; this.animTime=0;
        }else{
          // finished current attack; advance combo buffer if exists
          if(this.comboStep===0 && this.comboBuffer[0]==='light2'){
            this.startAttack('combo1'); this.comboStep=1;
          } else if(this.comboStep===1 && this.comboBuffer[1]==='light3'){
            this.startAttack('combo2'); this.comboStep=2;
          } else { this.state='idle'; this.lockMove=false; this.comboBuffer.length=0; this.comboStep=0; }
        }
      }
    }

    // Heavy charge visual
    if(this.state==='heavy_charge'){ this.heavyCharge += dt; if(this.heavyCharge>1) this.heavyCharge=1; this.glow=0.1; }

    // Skill spin
    if(this.skillActive){
      this.skillTime += dt; const cycle=SKILL.cycleT; if(this.skillTime>=cycle){ this.skillTime-=cycle; this.skillIndex=(this.skillIndex+1)%SKILL.frames.length; if(this.skillIndex===0){ this.skillRounds--; if(this.skillRounds<=0){ this.skillActive=false; this.state='idle'; this.lockMove=false; } } }
    }

    // Physics integration
    this.physics(dt);

    // Respawn on fall
    if(this.y>H+200){ this.respawn(); }
  }
  respawn(){ this.lives--; this.hp=this.maxhp; this.x=100; this.y=stage.groundY; this.vx=this.vy=0; this.state='idle'; this.lockMove=false; this.skillActive=false; this.comboBuffer.length=0; this.comboStep=0; }

  startAttack(kind){
    // Cannot cancel if already attacking
    if(this.state.startsWith('atk')) return;
    const A = ATTACKS[kind]; if(!A) return;
    this.state='atk_wind'; this.animTime=0; this.lockMove=!!A.lockMove; this.comboTimer=A.windT; this.currentAtk=A; this.heavyCharge=0;
  }
  startHeavy(charge=false){
    if(this.state.startsWith('atk') || this.skillActive) return;
    if(charge){ this.state='heavy_charge'; this.lockMove=true; this.heavyCharge=0; }
    else { this.commitHeavy(false); }
  }
  commitHeavy(fromCharge){
    // transition to heavy attack using charge bonus if any
    const A=ATTACKS.heavy; const charged = fromCharge && this.heavyCharge>=0.5;
    const windT = charged?A.chargeExtra.windT:A.windT;
    const dmg = A.dmg + (charged?(A.chargeExtra.dmg||0):0);
    this.state='atk_wind'; this.animTime=0; this.lockMove=true; this.comboTimer=windT; this.currentAtk={...A,dmg,windT}; this.glow = charged?0.6:0;
  }
  startSkill(hold=false){
    if(this.state.startsWith('atk')||this.state==='heavy_charge'||this.skillActive) return;
    this.skillActive=true; this.lockMove=true; this.skillTime=0; this.skillIndex=0; this.state='skill';
    this.skillRounds = hold?SKILL.roundsHold:SKILL.roundsTap;
    this.skillDamage = hold?SKILL.dmgHold:SKILL.dmgTap;
  }
}

class Enemy extends Entity{
  constructor(x){ super(x); this.maxhp=ENEMY_MAX_HP; this.hp=this.maxhp; this.aiTimer=0; this.cd=0; this.plan='idle'; this.dir=-1; this.w=54; this.h=82; }
  update(dt, player){
    if(!this.alive){ // KO spin & fade
      this.spin += dt*18; this.vx *= 0.99; this.vy += GRAV*dt; this.x += this.vx*dt; this.y += this.vy*dt; if(this.y>H+200) this.alpha=0; return; }
    if(this.hurt>0) this.hurt-=dt; if(this.inv>0) this.inv-=dt;

    // Simple AI with gaps so it can't infinite lock
    this.aiTimer -= dt; if(this.aiTimer<=0){
      const dx = player.x - this.x; const adx = Math.abs(dx);
      if(adx>160){ this.plan='chase'; this.dir = dx>0?1:-1; this.aiTimer=0.2; }
      else if(adx>60){ // decide to poke or wait
        this.plan = Math.random()<0.5? 'poke':'idle'; this.aiTimer=0.4+Math.random()*0.6;
      } else { // in range -> choose small/medium or reset
        const r=Math.random();
        if(r<0.4) { this.plan='small'; this.aiTimer=0.3; }
        else if(r<0.7){ this.plan='medium'; this.aiTimer=0.35; }
        else { this.plan='idle'; this.aiTimer=0.5; }
        this.dir = dx>0?1:-1;
      }
    }

    // Execute plan with cooldown to create gaps
    if(this.cd>0) this.cd-=dt;
    switch(this.plan){
      case 'chase': this.vx=this.dir*ENEMY_SPEED; break;
      case 'poke': this.vx=this.dir*80; break;
      default: this.vx=0; break;
    }

    // Attacks trigger but include enforced downtime
    if(this.cd<=0 && (this.plan==='small'||this.plan==='medium')){
      this.cd = 0.5; // gap so no stun-lock
      this.state = this.plan==='small'?'atk_s':'atk_m';
      this.animTime=0;
    }

    // Attack active movement windows
    if(this.state==='atk_s'){
      this.animTime += dt;
      if(this.animTime<0.3){ this.vx=this.dir*120; }
      else { this.state='idle'; }
    } else if(this.state==='atk_m'){
      this.animTime += dt;
      if(this.animTime<0.3){ this.vx=this.dir*80; }
      else { this.state='idle'; }
    }

    // Physics
    this.physics(dt);
  }
}

// =====================
// Collision / Hit detection (simple AABB)
// =====================
function rectsOverlap(a,b){ return a.x < b.x+b.width && a.x+a.width > b.x && a.y < b.y+b.height && a.y+a.height > b.y; }

// Attack hitboxes (brief during active frames)
function tryPlayerHitsEnemy(player, enemy){
  let hit=false, dmg=0;
  if(!enemy.alive) return;
  // Skill spin always active during skill
  if(player.skillActive){
    const hb = {x:player.x + player.dir*28 - 18, y:player.y-player.h, width:36, height:player.h};
    const eb = enemy.bbox();
    if(rectsOverlap(hb,eb)) { hit=true; dmg=player.skillDamage * (1/ (SKILL.frames.length)); /* per-cycle chip */ }
  }
  // Attacks when in active phase
  if(player.state==='atk_act' && player.currentAtk){
    const rng = 30 + (player.currentAtk.move||0)*0.2;
    const hb = {x:player.x + player.dir*(18+rng) - 18, y:player.y-player.h*0.9, width:36, height:player.h*0.8};
    const eb = enemy.bbox();
    if(rectsOverlap(hb,eb)) { hit=true; dmg=player.currentAtk.dmg; }
  }
  if(hit){ enemy.takeDamage(dmg, player.dir); // enemy reaction
    // slight float on medium (▲)
    if(player.currentAtk && player.currentAtk===ATTACKS.heavy){ enemy.vy = -260; }
  }
}

function tryEnemyHitsPlayer(enemy, player){
  if(!enemy.alive) return;
  // small attack window (0.3s) using EN1-4->1-5
  if(enemy.state==='atk_s' && enemy.animTime<0.3){
    const hb = {x:enemy.x + enemy.dir*26 - 16, y:enemy.y-enemy.h*0.9, width:32, height:enemy.h*0.7};
    const pb = player.bbox(); if(rectsOverlap(hb,pb)) { player.takeDamage(5, enemy.dir); }
  }
  if(enemy.state==='atk_m' && enemy.animTime<0.3){
    const hb = {x:enemy.x + enemy.dir*28 - 18, y:enemy.y-enemy.h*0.9, width:36, height:enemy.h*0.8};
    const pb = player.bbox(); if(rectsOverlap(hb,pb)) { player.takeDamage(8, enemy.dir); }
  }
}

Player.prototype.takeDamage = function(dmg, fromDir){
  if(this.inv>0 || !this.alive) return;
  this.hp -= dmg; this.hurt=0.25; this.inv=0.18; // blink and brief i-frames
  this.vy = -180; this.knockVX = fromDir*200; this.knockVY = -120;
  if(this.hp<=0){ // KO blow-away with spin + fade
    this.lives = Math.max(0, this.lives-1);
    this.state='ko'; this.alive=false; this.spin=0; this.vx=fromDir*260; this.vy=-520;
    setTimeout(()=>{ // fade-out then respawn
      this.alive=true; this.state='idle'; this.spin=0; this.hp=this.maxhp; this.x=100; this.y=stage.groundY; this.vx=this.vy=0; cameraFollow(this.x);
    }, 1200);
  }
}

// =====================
// Rendering
// =====================
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
ctx.imageSmoothingEnabled=false;

const player = new Player(100);
const enemy = new Enemy(520);

// HUD init
const hpfill = document.getElementById('hpfill');
const livesEl = document.getElementById('lives');
function refreshHUD(){
  const r = clamp(player.hp/player.maxhp,0,1);
  hpfill.style.transform = `scaleX(${r})`;
  livesEl.innerHTML = '';
  for(let i=0;i<player.lives;i++){ const d=document.createElement('div'); d.className='life'; livesEl.appendChild(d); }
}

let startT = performance.now();
function fmtTime(ms){ const s = Math.floor(ms/1000); const m = String(Math.floor(s/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; }

function draw(){
  // Background & stage
  drawStage(ctx);

  // Entities
  // Enemy sprite selection
  let eImgKey='EN1-1.png';
  if(enemy.state==='atk_s'){ eImgKey = (enemy.animTime<0.15)?'EN1-4.png':'EN1-5.png'; }
  else if(enemy.state==='atk_m'){ eImgKey = (enemy.animTime<0.15)?'EN1-4.png':'EN1-6.png'; }
  else if(Math.abs(enemy.vx)>5){ eImgKey = (Math.floor(enemy.animTime*10)%2)?'EN1-2.png':'EN1-3.png'; }
  const eImg = images.get(eImgKey);

  const pOnGround = player.onGround;
  // Player sprite selection
  let pKey = 'M1-1.png';
  if(player.skillActive){ pKey = SKILL.frames[player.skillIndex]; }
  else if(player.state==='atk_wind') { pKey = player.currentAtk?.wind || 'K1-3.png'; }
  else if(player.state==='atk_act') { pKey = player.currentAtk?.act || 'K1-1.png'; }
  else if(player.state==='heavy_charge'){ pKey='K1-3.png'; }
  else if(!pOnGround){ pKey='M1-4.png'; }
  else if(Math.abs(player.vx)>10){ const t=Math.floor(player.animTime*10)%3; pKey=['M1-2.png','M1-3.png','M1-4.png'][t]; }
  const pImg = images.get(pKey);

  // Apply camera
  ctx.save(); ctx.translate(-camera.x,0);

  // Draw enemy
  drawSprite(ctx, eImg, enemy.x, enemy.y, enemy.w, enemy.h, enemy.dir<0, 1, enemy.hurt>0);

  // Draw player (glow if charged)
  if(player.glow>0){
    ctx.save(); ctx.globalAlpha = 0.3+0.4*Math.sin(performance.now()/60);
    ctx.shadowColor = '#8ff'; ctx.shadowBlur=20; ctx.fillStyle='#9ef';
    ctx.beginPath(); ctx.ellipse(player.x, player.y-player.h*0.6, 40, 52, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
  const flash = player.hurt>0 && Math.floor(performance.now()/50)%2===0;
  drawSprite(ctx, pImg, player.x, player.y, player.w, player.h, player.flip, 1, flash);

  ctx.restore();

  // UI overlays
  const tms = performance.now()-startT; document.getElementById('timer').textContent = 'TIME '+fmtTime(tms);
  refreshHUD();

  // Charge/skill meters
  // Head meter for skill/charge
  ctx.save();
  ctx.translate(player.x - camera.x, player.y - player.h - 22);
  if(player.state==='heavy_charge' || player.skillActive){
    ctx.fillStyle='#0d2238'; ctx.fillRect(-22,-8,44,6); ctx.fillStyle='#6df';
    let val=0; if(player.state==='heavy_charge') val = player.heavyCharge; else { val = 1 - (player.skillRounds/(player.skillRounds>0?player.skillRounds:1)); }
    ctx.fillRect(-22,-8, 44*clamp(val,0,1),6);
  }
  ctx.restore();
}

// =====================
// Main loop
// =====================
let last=now();
function tick(){
  const t=now(); let dt=t-last; last=t; if(dt>0.05) dt=0.05; // clamp

  // Update entities
  player.update(dt);
  enemy.update(dt, player);

  // Contact & hits
  tryPlayerHitsEnemy(player, enemy);
  tryEnemyHitsPlayer(enemy, player);

  // Camera
  cameraFollow(player.x);

  // Clear frame
  ctx.clearRect(0,0,W,H);
  draw();

  requestAnimationFrame(tick);
}

// =====================
// Input (keyboard + virtual controls) — designed to not miss taps
// =====================
const keys = new Set();
window.addEventListener('keydown',e=>{ keys.add(e.code); handleKeys(); });
window.addEventListener('keyup',e=>{ keys.delete(e.code); handleKeys(true); });
function handleKeys(up=false){
  const left = keys.has('ArrowLeft')||keys.has('KeyA');
  const right = keys.has('ArrowRight')||keys.has('KeyD');
  player.moveInput = (right?1:0) - (left?1:0);
  if(keys.has('Space')||keys.has('ArrowUp')||keys.has('KeyW')){ if(up){/* ignore */} else player.wantJump=true; }
  if(keys.has('KeyJ')) doAtk1();
  if(keys.has('KeyK')){ if(up){ commitHeavyIfCharging(); } else startHeavyOrCharge(); }
  if(keys.has('KeyL')){ if(up){ commitSkillHold(true); } else startSkillTap(); }
}

// Virtual stick
const stick = document.getElementById('stick');
const nub = document.getElementById('sticknub');
let stickId=null;
function stickSet(dx){
  player.moveInput = clamp(dx/48, -1, 1);
}
function stickReset(){ player.moveInput=0; nub.style.transform='translate(-50%,-50%)'; }
function pointerPos(e, el){ const r=el.getBoundingClientRect(); const x=(e.clientX|| (e.touches?e.touches[0].clientX:0)) - r.left; const y=(e.clientY|| (e.touches?e.touches[0].clientY:0)) - r.top; return {x,y}; }

function stickStart(e){ e.preventDefault(); const p=e.changedTouches?e.changedTouches[0]:e; stickId=p.identifier??'mouse'; const {x,y}=pointerPos(p,stick); const cx=70, cy=70; const dx=x-cx, dy=y-cy; const len=Math.hypot(dx,dy); const max=40; const k = len>max? max/len:1; nub.style.transform=`translate(${(dx*k)}px, ${(dy*k)}px)`; stickSet(dx); }
function stickMove(e){ if(stickId===null) return; const touches = e.changedTouches?Array.from(e.changedTouches):[e]; const p = touches.find(t=> (t.identifier??'mouse')===stickId); if(!p) return; e.preventDefault(); const {x,y}=pointerPos(p,stick); const dx=x-70, dy=y-70; const len=Math.hypot(dx,dy); const max=40; const k = len>max? max/len:1; nub.style.transform=`translate(${(dx*k)}px, ${(dy*k)}px)`; stickSet(dx); }
function stickEnd(e){ if(stickId===null) return; const touches = e.changedTouches?Array.from(e.changedTouches):[e]; const p = touches.find(t=> (t.identifier??'mouse')===stickId); if(!p) return; e.preventDefault(); stickId=null; stickReset(); }
stick.addEventListener('pointerdown',stickStart);stick.addEventListener('pointermove',stickMove);stick.addEventListener('pointerup',stickEnd);stick.addEventListener('pointercancel',stickEnd);
stick.addEventListener('touchstart',stickStart,{passive:false});stick.addEventListener('touchmove',stickMove,{passive:false});stick.addEventListener('touchend',stickEnd,{passive:false});stick.addEventListener('touchcancel',stickEnd,{passive:false});

// Buttons (debounced, no-miss using pointerdown)
function wireBtn(id, onDown, onUp){ const el=document.getElementById(id); el.addEventListener('pointerdown', e=>{ e.preventDefault(); onDown(); el.setPointerCapture(e.pointerId); }); el.addEventListener('pointerup', e=>{ e.preventDefault(); if(onUp) onUp(); }); el.addEventListener('touchstart', e=>{ e.preventDefault(); onDown(); }, {passive:false}); el.addEventListener('touchend', e=>{ e.preventDefault(); if(onUp) onUp(); }, {passive:false}); }

function doAtk1(){
  // If idle, start light; if already finished first, buffer next steps
  if(player.state==='idle' && !player.skillActive){ player.startAttack('light'); player.comboBuffer=[ 'light2','light3' ]; player.comboStep=0; }
}
function startHeavyOrCharge(){ if(player.state==='idle' && !player.skillActive){ player.startHeavy(true); } }
function commitHeavyIfCharging(){ if(player.state==='heavy_charge'){ player.commitHeavy(true); } }
function startSkillTap(){ if(player.state==='idle' && !player.skillActive){ player.startSkill(false); } }
function commitSkillHold(){ if(player.state==='idle' && !player.skillActive){ player.startSkill(true); } }

wireBtn('btnA', doAtk1);
wireBtn('btnB', ()=>startHeavyOrCharge(), ()=>commitHeavyIfCharging());
wireBtn('btnC', ()=>startSkillTap(), ()=>{/* long press handled by holding then separate hold button? Use keyboard L for hold; or tap twice quickly to simulate */});
wireBtn('btnJ', ()=>{ player.wantJump=true; });

// =====================
// Start game
// =====================
loadImages(()=>{ requestAnimationFrame(tick); });
</script>
</body>
</html>
