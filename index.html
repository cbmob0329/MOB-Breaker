<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>MOB Side Action – Fixed Floor</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{
    --controls-h: clamp(180px, 34dvh, 260px);
    --pad-gap: 8px;
    --hud:#0f1118cc; --fg:#e7ecf3; --accent:#39c6ff; --danger:#ff4d4f;
    --btn:#141824cc; --btn-hi:#1b2030cc;
  }
  html,body{height:100%;margin:0;background:#000;color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overscroll-behavior:none}
  body{touch-action:none;-webkit-user-select:none;user-select:none}

  #root{
    position:fixed; inset:0;
    display:grid;
    grid-template-rows: 1fr var(--controls-h);
    gap: var(--pad-gap);
    padding:
      calc(env(safe-area-inset-top,0px) + var(--pad-gap))
      var(--pad-gap)
      calc(env(safe-area-inset-bottom,0px) + var(--pad-gap))
      var(--pad-gap);
    box-sizing:border-box;
    height:100dvh;
  }

  #gameWrap{
    position:relative; min-height:0;
    display:grid; place-items:center;
    background:#000; border-radius:16px;
  }
  canvas#game{
    width:100%;
    height:100%;
    max-width:520px;
    background:#060913;
    border-radius:16px;
    box-shadow:0 10px 40px rgba(0,0,0,.5);
    touch-action:none;
  }

  .overlay{position:absolute;inset:0;pointer-events:none}
  .hud{
    position:absolute;left:8px;right:8px;top:8px;display:flex;justify-content:space-between;gap:8px;
    background:var(--hud);backdrop-filter:blur(6px);padding:8px 10px;border-radius:12px;align-items:center;pointer-events:none
  }
  .hud .lives,.hud .timer{font-weight:700;letter-spacing:.5px}
  .gauge{height:6px;background:#1b2133;border-radius:999px;overflow:hidden;min-width:90px}
  .gauge>i{display:block;height:100%;width:0;background:linear-gradient(90deg,#6af,#4f9);transition:width .1s}

  #controls{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap: var(--pad-gap);
    height: var(--controls-h);
  }
  .pad{position:relative;background:var(--hud);border-radius:16px;padding:10px;backdrop-filter:blur(6px);height:100%}
  .pad.right{
    display:grid;grid-template-areas:"atk1 skill" "atk2 skill";
    grid-template-columns:1fr 1fr;grid-auto-rows:1fr;gap:10px;height:100%;
  }
  .stickBase,.stickThumb{position:absolute;border-radius:999px;pointer-events:auto;touch-action:none}
  .stickBase{width:140px;height:140px;left:10px;top:10px;background:#101522;border:2px solid #1f2a44aa}
  .stickThumb{width:72px;height:72px;left:44px;top:44px;background:#1a2440;border:2px solid #2e3b63aa;transition:transform .02s}

  .btn{
    pointer-events:auto;touch-action:none;background:var(--btn);border:2px solid #1f2a44aa;border-radius:14px;
    display:grid;place-items:center;font-weight:800;font-size:20px;user-select:none
  }
  .btn:active{background:var(--btn-hi)}
  .btn[data-kind="atk1"]{grid-area:atk1}
  .btn[data-kind="atk2"]{grid-area:atk2}
  .btn[data-kind="skill"]{grid-area:skill;font-size:22px}

  .legend{position:absolute;inset:auto 10px 10px auto;font-size:12px;opacity:.8}

  @media (max-width:360px){
    :root{ --controls-h: clamp(170px, 38dvh, 220px); }
    .stickBase{width:120px;height:120px}
    .stickThumb{width:64px;height:64px;left:38px;top:38px}
  }
</style>
</head>
<body>
<div id="root">
  <div id="gameWrap">
    <canvas id="game" width="450" height="800"></canvas>
    <div class="overlay">
      <div class="hud" id="hud">
        <div class="lives">残機 <span id="lives">∞</span> <span class="badge" style="padding:2px 6px;border-radius:8px;background:#1a2133;font-size:12px;margin-left:6px">無敵デバッグ</span></div>
        <div class="timer">TIME <span id="time">00:00</span></div>
        <div class="gauge" title="Skill Gauge"><i id="gauge"></i></div>
      </div>
    </div>
  </div>

  <div id="controls">
    <div class="pad left" id="padLeft">
      <div class="stickBase" id="stickBase"></div>
      <div class="stickThumb" id="stickThumb"></div>
      <div class="legend">左：移動 / 右：反転自動対応</div>
    </div>
    <div class="pad right">
      <div class="btn" data-kind="atk1" id="btnAtk1">■</div>
      <div class="btn" data-kind="atk2" id="btnAtk2">▲</div>
      <div class="btn" data-kind="skill" id="btnSkill">●</div>
    </div>
  </div>
</div>

<script>
(() => {
  const DPR = Math.max(1, Math.floor(devicePixelRatio || 1));
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });

  // === 可変ステージ床（端末の画面高さに追従） ===
  let stageFloorY = 620; // デフォ
  function updateStageGeometry(){
    const rect = canvas.getBoundingClientRect();
    const cssW = rect.width, cssH = rect.height;
    canvas.width = Math.round(cssW * DPR);
    canvas.height = Math.round(cssH * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);

    // 画面下から少し上に床を置く（UIに被らない余白 120px）
    // 最低でも画面高の60%より下に固定して見えるようにする
    const desired = Math.max(Math.floor(cssH * 0.6), cssH - 140);
    stageFloorY = desired;
    // プレースホルダで開始位置が床より上に来るようにも使う
  }
  updateStageGeometry(); addEventListener('resize', updateStageGeometry);

  // ---- 画像ローダ（なければ色板） ----
  const images = {};
  const wanted = [
    'M1-1.png','M1-2.png','M1-3.png','M1-4.png',
    'K1-1.png','K1-2.png','K1-3.png','K1-4.png','K1-5.png',
    'h1.png','h2.png','h3.png','h4.png',
    'EN1-1.png','EN1-2.png','EN1-3.png','EN1-4.png','EN1-5.png','EN1-6.png',
    'S1.png'
  ];
  function loadImg(name, tint='#888'){
    return new Promise(res=>{
      const img = new Image();
      img.onload = ()=>{ images[name]=img; res(); };
      img.onerror = ()=>{
        const c=document.createElement('canvas'); c.width=64; c.height=64;
        const x=c.getContext('2d');
        x.fillStyle='#111'; x.fillRect(0,0,64,64);
        x.fillStyle=tint; x.fillRect(4,4,56,56);
        x.fillStyle='#0008'; x.fillRect(4,40,56,20);
        images[name]=c; res();
      };
      img.src = name;
    });
  }
  const tint = {
    'M1-1.png':'#8ef','M1-2.png':'#8ef','M1-3.png':'#8ef','M1-4.png':'#8ef',
    'K1-1.png':'#adf','K1-2.png':'#adf','K1-3.png':'#adf','K1-4.png':'#adf','K1-5.png':'#adf',
    'h1.png':'#f77','h2.png':'#f77','h3.png':'#f77','h4.png':'#f77',
    'EN1-1.png':'#fc9','EN1-2.png':'#fc9','EN1-3.png':'#fc9','EN1-4.png':'#fc9','EN1-5.png':'#fc9','EN1-6.png':'#fc9',
    'S1.png':'#6bd'
  };

  // 入力
  const keys = new Set();
  addEventListener('keydown', e=>{
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','z','x','c','Z','X','C','Shift','Enter'].includes(e.key)) e.preventDefault();
    keys.add(e.key);
  });
  addEventListener('keyup', e=> keys.delete(e.key));

  // 仮想スティック
  const padLeft = document.getElementById('padLeft');
  const base = document.getElementById('stickBase');
  const thumb = document.getElementById('stickThumb');
  let stickActive=false, stickVecX=0, stickVecY=0;
  function stickCenter(){ return { x: base.offsetLeft+base.offsetWidth/2, y: base.offsetTop+base.offsetHeight/2 }; }
  function setStickFromPoint(px,py){
    const c = stickCenter();
    const dx = px - c.x, dy = py - c.y;
    const R = base.offsetWidth*0.5 - 8;
    const d = Math.hypot(dx,dy) || 1;
    const nx = Math.max(-1, Math.min(1, dx / R));
    const ny = Math.max(-1, Math.min(1, dy / R));
    stickVecX = Math.abs(dx) < 6 ? 0 : nx;
    stickVecY = Math.abs(dy) < 6 ? 0 : ny;
    const mag = Math.min(1, d / R);
    const tx = (R * mag) * (dx/d);
    const ty = (R * mag) * (dy/d);
    thumb.style.transform = `translate(${tx}px, ${ty}px)`;
  }
  function resetStick(){ stickActive=false; stickVecX=0; stickVecY=0; thumb.style.transform='translate(0,0)'; }
  padLeft.addEventListener('pointerdown', e=>{ stickActive=true; padLeft.setPointerCapture(e.pointerId); setStickFromPoint(e.offsetX,e.offsetY); });
  padLeft.addEventListener('pointermove', e=>{ if(stickActive) setStickFromPoint(e.offsetX,e.offsetY); });
  padLeft.addEventListener('pointerup', resetStick);
  padLeft.addEventListener('pointercancel', resetStick);

  // 右ボタン
  const btnAtk1 = document.getElementById('btnAtk1');
  const btnAtk2 = document.getElementById('btnAtk2');
  const btnSkill = document.getElementById('btnSkill');
  let skillPressStart = 0, skillHolding=false;
  function press(el, down, up){
    el.addEventListener('pointerdown', e=>{ e.preventDefault(); el.setPointerCapture(e.pointerId); down(); });
    el.addEventListener('pointerup', up);
    el.addEventListener('pointercancel', up);
  }
  press(btnAtk1, ()=>{ pushInput('A'); }, ()=>{});
  press(btnAtk2, ()=>{ pushInput('B'); }, ()=>{});
  press(btnSkill,
    ()=>{ skillHolding=true; skillPressStart = performance.now(); },
    ()=>{
      const held = performance.now() - skillPressStart;
      skillHolding=false;
      if (held > 220){ player.gauge = clamp(player.gauge + 0.25, 0, 1); }
      const kind = (player.gauge >= 0.75) ? 'SPIN_L' : 'SPIN_S';
      beginAttack(kind);
      if (kind==='SPIN_L') player.gauge = 0;
    }
  );

  // キー
  addEventListener('keydown', e=>{
    if (e.repeat) return;
    if (e.key==='z' || e.key==='Z') pushInput('A');
    if (e.key==='x' || e.key==='X') pushInput('B');
    if (e.key==='c' || e.key==='C' || e.key===' ') {
      beginAttack( player.gauge>=0.75 ? 'SPIN_L' : 'SPIN_S' );
      if (player.gauge>=0.75) player.gauge=0;
    }
    if (e.key==='ArrowUp' || e.key==='Shift' || e.key==='Enter'){
      if (player.canJump && player.grounded){ player.vy = JUMP_V; player.grounded=false; player.canJump=false; }
    }
  });

  // 物理＆定数
  const GRAVITY = 0.55, MOVE_SPEED = 2.6, AIR_CTRL = 0.75, JUMP_V = -10.2, MAX_FALL=16;
  const HIT_FLASH_T = 120, HIT_KNOCK = 3.0, HIT_POP = -4.5, ENEMY_HP = 50;

  const world = { camX:0, camY:0, t:0, last:performance.now(), timerSec:0 };

  const clamp=(v,a,b)=> v<a?a: v>b?b:v;
  function drawSprite(img, x, y, w=64, h=64, flipX=false, alpha=1, tintRed=0){
    ctx.save(); ctx.globalAlpha = alpha;
    if (flipX) { ctx.translate(x + w, y); ctx.scale(-1, 1); x = 0; y = 0; } else { ctx.translate(x, y); }
    ctx.drawImage(img, 0, 0, w, h);
    if (tintRed>0){ ctx.globalCompositeOperation='multiply'; ctx.fillStyle=`rgba(255,0,0,${tintRed})`; ctx.fillRect(0,0,w,h); ctx.globalCompositeOperation='source-over'; }
    ctx.restore();
  }

  const Anim = {
    idle: ['M1-1.png'],
    move: ['M1-2.png','M1-3.png','M1-4.png'],
    atk1_upper: ['K1-1.png'],
    stance: ['K1-3.png'],
    rushKick: ['K1-2.png'],
    killKick: ['K1-4.png'],
    upKick: ['K1-5.png'],
    spin: ['h1.png','h2.png','h3.png','h4.png'],
  };
  const EnemyAnim = {
    idle:['EN1-1.png'],
    move:['EN1-2.png','EN1-3.png'],
    atkS:['EN1-4.png','EN1-5.png'],
    atkM:['EN1-4.png','EN1-6.png'],
  };
  function aabb(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

  // エンティティ
  const player = { x:120,y:0,w:64,h:64,vx:0,vy:0,dir:1,grounded:false,canJump:true,
    anim:'idle',animT:0,animI:0,invincible:true,comboState:null,comboT:0,gauge:0,actionLockT:0
  };

  const ATTACKS = {
    A1:{ dmg:5, len:180, hitbox:{x:18,y:10,w:40,h:54}, impulse:{x:0.6,y:0}, anim:'atk1_upper' },
    A2:{ dmg:8, len:220, hitbox:{x:20,y:8,w:44,h:50}, impulse:{x:1.8,y:0}, anim:'rushKick', pre:'stance', preLen:120 },
    A3:{ dmg:10,len:240, hitbox:{x:18,y:8,w:46,h:50}, impulse:{x:2.2,y:0}, anim:'killKick', pre:'stance', preLen:120 },
    B1:{ dmg:15,len:260, hitbox:{x:16,y:-6,w:40,h:40}, impulse:{x:0.9,y:-1.0}, anim:'upKick', pre:'stance', preLen:300, shake:true },
    SPIN_S:{ dmg:25,len:500, anim:'spin', loops:2, radial:true },
    SPIN_L:{ dmg:40,len:900, anim:'spin', loops:4, radial:true },
  };
  let activeHit=null;
  function beginAttack(kind){
    const k = ATTACKS[kind]; if (!k) return;
    player.actionLockT = k.len; player.animT=0; player.animI=0; player.anim = (k.pre ? k.pre : k.anim);
    if (k.pre) setTimeout(()=>{ player.anim = k.anim; }, k.preLen||0);
    if (k.impulse) player.vx += player.dir * k.impulse.x;
    activeHit = { kind, used:false, t:k.len, radial:!!k.radial };
  }

  const inputQueue=[];
  function pushInput(tag){ inputQueue.push({tag, t: performance.now()}); }

  const enemies=[];
  function makeEnemy(x){ return { x, y:0, w:60,h:60, vx:0,vy:0, dir:-1, hp:ENEMY_HP, aiT:0, anim:'idle',animT:0,animI:0, hitT:0, dead:false, spinR:0, fade:1, attackPhase:0, attackT:0 }; }
  function ensureEnemies(){
    let alive = enemies.filter(e=>!e.dead).length;
    for(let i=0;i<4-alive;i++){
      const sx = world.camX + canvas.clientWidth + 120 + i*80;
      const e = makeEnemy(sx);
      e.y = stageFloorY - e.h; // 床に合わせる
      enemies.push(e);
    }
  }

  // 地面コリジョン（床ライン=stageFloorY）
  function collideWithGround(ent){
    const floorY = stageFloorY - ent.h;
    if (ent.y >= floorY && ent.vy >= 0){ ent.y = floorY; ent.vy = 0; ent.grounded = true; if (ent===player) player.canJump=true; }
    else ent.grounded=false;
  }

  function drawGround(){
    const img = images['S1.png']; const wTile=64, hTile=64; const y=stageFloorY;
    const startX = Math.floor((world.camX - 50) / wTile) * wTile;
    const endX = world.camX + canvas.clientWidth + 100;
    for(let x=startX; x<endX; x+=wTile){
      ctx.drawImage(img, x - world.camX, y - world.camY, wTile, hTile);
      ctx.drawImage(img, x - world.camX, y - world.camY + hTile, wTile, hTile);
    }
  }

  function formatTime(sec){ const m=(sec/60)|0, s=sec%60; return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; }

  // 画像読み込み→開始
  Promise.all(wanted.map(n=>loadImg(n, tint[n]||'#888'))).then(start);

  function update(dt){
    world.t += dt; world.timerSec += dt/1000;

    const wantLeft = keys.has('ArrowLeft') || (stickVecX < -0.25);
    const wantRight= keys.has('ArrowRight')|| (stickVecX > 0.25);
    const wantJump = keys.has('ArrowUp');

    let move = 0; if (wantLeft) move -= 1; if (wantRight) move += 1;
    const accel = player.grounded ? MOVE_SPEED : MOVE_SPEED * AIR_CTRL;
    player.vx = move * accel; if (move!==0) player.dir = move;

    if (wantJump && player.canJump && player.grounded){ player.vy = JUMP_V; player.grounded=false; player.canJump=false; }
    if (!wantJump && player.grounded) player.canJump=true;

    player.vy = clamp(player.vy + GRAVITY, -99, MAX_FALL);
    player.x += player.vx; player.y += player.vy;
    collideWithGround(player);

    // カメラ
    const vw = canvas.clientWidth;
    const targetCamX = player.x + player.w*0.5 - vw*0.5;
    world.camX += (targetCamX - world.camX) * 0.12;

    // 落下死→リスポーン（床よりかなり落ちたら）
    if (player.y > stageFloorY + 400){
      player.x = world.camX + 120; player.y = stageFloorY - player.h; player.vx=0; player.vy=0; player.dir=1;
    }

    // アニメ
    player.animT += dt; if (player.animT>120){ player.animT=0; player.animI=(player.animI+1)%4; }

    if (player.actionLockT > 0){
      player.actionLockT -= dt;
      if (player.actionLockT < 120 && activeHit && !activeHit.radial) {
        const last = inputQueue.pop();
        if (last){
          if (last.tag==='B'){ beginAttack('B1'); }
          else if (last.tag==='A'){
            const prev = activeHit.kind;
            if (prev==='A1') beginAttack('A2');
            else if (prev==='A2') beginAttack('A3');
            else beginAttack('A1');
          }
        }
      }
    }else{
      if (Math.abs(player.vx)>0.1) player.anim='move'; else player.anim='idle';
    }
    if (skillHolding) player.gauge = clamp(player.gauge + dt/4000, 0, 1);

    // 攻撃ヒット
    if (activeHit){
      activeHit.t -= dt;
      const k = ATTACKS[activeHit.kind];
      if (activeHit.t<=0){ activeHit=null; }
      else{
        if (k.radial){
          const radius = 48;
          for (const e of enemies){
            if (e.dead) continue;
            const dx = (e.x+e.w/2) - (player.x+player.w/2);
            const dy = (e.y+e.h/2) - (player.y+player.h/2);
            if (Math.hypot(dx,dy) < radius + Math.min(e.w,e.h)*0.5){
              dealDamage(e, k.dmg, Math.sign(dx)||player.dir, true);
            }
          }
        } else {
          const hb = { x: player.x + (player.dir>0? 20: (player.w- (20+ (k.hitbox?.w||40)) ) ),
                       y: player.y + (k.hitbox?.y||8),
                       w: (k.hitbox?.w||40), h: (k.hitbox?.h||40) };
          for (const e of enemies){
            if (e.dead) continue;
            if (aabb(hb, e)){ dealDamage(e, k.dmg, player.dir, k===ATTACKS.B1); }
          }
        }
      }
    }

    // 敵AI
    for (const e of enemies){
      if (e.dead){
        e.spinR += 0.3; e.vy += GRAVITY*0.6; e.y += e.vy; e.x += e.vx;
        e.fade -= dt/600; if (e.fade<=0){ e.fade = 0; e.remove = true; }
        continue;
      }
      e.animT += dt; if (e.animT>160){ e.animT=0; e.animI=(e.animI+1)%4; }
      if (e.hitT>0) e.hitT -= dt;

      const dist = player.x - e.x; e.dir = dist>0 ? 1 : -1;
      if (Math.abs(dist) > 80){ e.vx = 1.5 * e.dir; e.anim='move'; }
      else {
        e.vx = 0;
        if (e.attackT<=0){ e.attackPhase = 0; e.attackT = 300 + Math.random()*300; }
        else {
          e.attackT -= dt;
          if (e.attackT<200 && e.attackPhase===0){ e.anim='atkS'; tryEnemyHit(e, 6); e.attackPhase=1; }
          if (e.attackT<40 && e.attackPhase===1){ e.anim='atkM'; tryEnemyHit(e,10); e.attackPhase=2; }
          if (e.attackT<=0){ e.anim='idle'; }
        }
      }
      e.vy = clamp(e.vy + GRAVITY, -99, MAX_FALL);
      e.x += e.vx; e.y += e.vy;
      collideWithGround(e);
    }
    for (let i=enemies.length-1;i>=0;i--) if (enemies[i].remove) enemies.splice(i,1);
    ensureEnemies();

    // HUD
    document.getElementById('time').textContent = formatTime(world.timerSec|0);
    document.getElementById('gauge').style.width = `${Math.round(player.gauge*100)}%`;
  }

  function dealDamage(e, dmg, dir, popUp){
    if (e.dead) return;
    e.hp -= dmg; e.hitT = HIT_FLASH_T; e.vx = HIT_KNOCK * (dir||1); e.vy = popUp ? (HIT_POP - 1.5) : HIT_POP;
    if (e.hp <= 0){
      e.dead = true; e.vx = 3.5*(dir||1); e.vy = -6.0; e.fade = 1;
    }
  }
  function tryEnemyHit(e, dmg){ /* プレイヤー無敵のため演出省略 */ }

  function render(){
    ctx.fillStyle='#060913'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
    drawGround();

    const pFrames = Anim[player.anim] || Anim.idle;
    const pImg = images[pFrames[player.animI % pFrames.length]] || images['M1-1.png'];
    drawSprite(pImg, Math.round(player.x - world.camX), Math.round(player.y - 0), player.w, player.h, player.dir<0, 1, 0);

    for(const e of enemies){
      const eFrames = EnemyAnim[e.anim] || EnemyAnim.idle;
      const eImg = images[eFrames[e.animI % eFrames.length]] || images['EN1-1.png'];
      const tint = e.hitT>0 ? (e.hitT/HIT_FLASH_T) : 0; const alpha = e.fade ?? 1;
      drawSprite(eImg, Math.round(e.x - world.camX), Math.round(e.y - 0), e.w, e.h, e.dir<0, alpha, tint);
      if (!e.dead){
        const hpW = 46, hpH = 5, bx = e.x - world.camX + (e.w-hpW)/2, by = e.y - 8;
        ctx.fillStyle='#000a'; ctx.fillRect(bx-1,by-1,hpW+2,hpH+2);
        ctx.fillStyle='#222b'; ctx.fillRect(bx,by,hpW,hpH);
        ctx.fillStyle='#f55'; ctx.fillRect(bx,by,(hpW*(e.hp/ENEMY_HP))|0,hpH);
      }
    }
  }

  function loop(ts){
    const dt = Math.max(8, Math.min(24, ts - world.last)); world.last = ts;
    update(dt); render(); requestAnimationFrame(loop);
  }

  function start(){
    // 初期スポーンを床に合わせる
    player.y = stageFloorY - player.h;
    for(let i=0;i<4;i++){ const e = makeEnemy(player.x + 200 + i*120); e.y = stageFloorY - e.h; enemies.push(e); }
    requestAnimationFrame(t=>{ world.last=t; loop(t); });
  }
})();
</script>
</body>
</html>
